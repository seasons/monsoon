enum BrandTier {
  Tier0
  Tier1
  Tier2
  Niche
  Upcoming
  Retro
  Boutique
  Local
  Discovery
}

enum Department {
  Clothes
  Bags
  Accessories
  Jewelry
}

enum LocationType {
  Office
  Warehouse
  Cleaner
  Customer
}

enum CustomerStatus {
  Invited
  Created
  Waitlisted
  Authorized
  Active
  Suspended
  Paused
  Deactivated
}

enum UserRole {
  Admin
  Customer
  Partner
}

enum InventoryStatus {
  NonReservable
  Reservable
  Reserved
  Stored
  Offloaded
}

enum PhysicalProductStatus {
  New
  Used
  Damaged
  Clean
  Lost
}

enum PhysicalProductOffloadMethod {
  SoldToUser
  SoldToThirdParty
  ReturnedToVendor
  Recycled
  Unknown
}

enum ProductStatus {
  Available
  NotAvailable
  Stored
  Offloaded
}

enum ReservationStatus {
  New
  InQueue
  OnHold
  Packed
  Shipped
  InTransit
  Received
  Cancelled
  Completed
}

enum BagItemStatus {
  Added
  Reserved
  Received
}

enum Plan {
  AllAccess
  Essential
}

enum ProductType {
  Top
  Bottom
  Accessory
  Shoe
}

enum BottomSizeType {
  WxL
  US
  EU
  JP
  Letter
}

enum QuestionType {
  MultipleChoice
  FreeResponse
}

enum PushNotificationStatus {
  Blocked
  Granted
  Denied
}

enum Rating {
  Disliked
  Ok
  Loved
}

enum LetterSize {
  XS
  S
  M
  L
  XL
  XXL
}

enum ProductArchitecture {
  Fashion
  Showstopper
  Staple
}

enum WarehouseLocationType {
	Conveyor
  Rail
  Bin
}

type Brand {
  id: ID! @id
  slug: String! @unique
  brandCode: String! @unique
  description: String
  isPrimaryBrand: Boolean! @default(value: false)
  logo: Json
  name: String!
  basedIn: String
  products: [Product!]!
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Category {
  id: ID! @id
  slug: String! @unique
  name: String! @unique
  image: Json
  description: String
  visible: Boolean! @default(value: false)
  products: [Product!]!
  children: [Category!]! @relation(name: "CategoryToChildren")
}

type Color {
  id: ID! @id
  slug: String! @unique
  name: String!
  colorCode: String! @unique
  hexCode: String!
  productVariants: [ProductVariant!]!
}

type Collection {
  id: ID! @id
  slug: String! @unique
  images: Json!
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
  products: [Product!]!
}

type CollectionGroup {
  id: ID! @id
  slug: String! @unique
  title: String
  collectionCount: Int
  collections: [Collection!]!
}

type HomepageProductRail {
  id: ID! @id
  slug: String! @unique
  name: String!
  products: [Product!]!
}

type Image {
  id: ID! @id
  caption: String
  url: String
  originalHeight: Int
  originalUrl: String! @unique
  originalWidth: Int
  title: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Location {
  id: ID! @id
  slug: String! @unique
  name: String!
  company: String
  description: String
  address1: String!
  address2: String
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  user: User
  lat: Float
  lng: Float
  physicalProducts: [PhysicalProduct!]!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Tag {
  id: ID! @id
  name: String! @unique
  description: String
  products: [Product!]!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Product {
  id: ID! @id
  slug: String! @unique
  name: String!
  brand: Brand!
  category: Category!
  type: ProductType
  description: String
  externalURL: String
  images: [Image!]
  modelHeight: Int
  retailPrice: Int
  model: ProductModel
  modelSize: Size @relation(name: "ProductModelSize")
  color: Color! @relation(name: "ProductPrimaryColor")
  secondaryColor: Color @relation(name: "ProductSecondaryColor")
  tags: [Tag!]!
  functions: [ProductFunction!]!
  innerMaterials: [String!]! @scalarList(strategy: RELATION)
  outerMaterials: [String!]! @scalarList(strategy: RELATION)
  variants: [ProductVariant!]! @relation(link: TABLE, onDelete: CASCADE)
  status: ProductStatus @default(value: Available)
  season: String
  architecture: ProductArchitecture
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ProductModel {
  id: ID! @id
  name: String! @unique
  height: Float!
  products: [Product!]! @relation(link: TABLE)
}

type ProductFunction {
  id: ID! @id
  name: String @unique
}

type ProductVariant {
  id: ID! @id
  sku: String @unique
  color: Color!
  internalSize: Size @relation(name: "ProductVariantSize")
  manufacturerSizes: [Size!] @relation(name: "ProductVariantManufacturerSize")
  weight: Float
  height: Float
  productID: String!
  product: Product! @relation(onDelete: SET_NULL)
  retailPrice: Float
  physicalProducts: [PhysicalProduct!]! @relation(link: TABLE, onDelete: CASCADE)
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
  offloaded: Int!
  stored: Int!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type PhysicalProduct {
  id: ID! @id
  seasonsUID: String! @unique
  location: Location
  productVariant: ProductVariant! @relation(onDelete: SET_NULL)
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  offloadMethod: PhysicalProductOffloadMethod
  offloadNotes: String
  barcode: String!
  sequenceNumber: Int!
  warehouseLocation: WarehouseLocation
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type WarehouseLocationConstraint {
  id: ID! @id
  category: Category!
  limit: Int!
  locations: [WarehouseLocation!]
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type WarehouseLocation {
  id: ID! @id
  type: WarehouseLocationType!
  barcode: String! @unique
  locationCode: String!
  itemCode: String!
	physicalProducts: [PhysicalProduct!]
  constraints: [WarehouseLocationConstraint!]
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type User {
  id: ID! @id
  auth0Id: String! @unique
  email: String! @unique
  firstName: String!
  lastName: String!
  role: UserRole! @default(value: Customer)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  pushNotifications: PushNotificationStatus! @default(value: Denied)
}

type CustomerDetail {
  id: ID! @id
  phoneNumber: String
  birthday: DateTime
  # Height in inches
  height: Int
  weight: String
  bodyType: String
  averageTopSize: String
  averageWaistSize: String
  averagePantLength: String
  preferredPronouns: String
  profession: String
  # How often do you go out?
  partyFrequency: String
  # Do you travel a lot?
  travelFrequency: String
  # How often do you buy clothes?
  shoppingFrequency: String
  # How much do you spend?
  averageSpend: String
  style: String
  commuteStyle: String
  shippingAddress: Location
  phoneOS: String
  insureShipment: Boolean! @default(value: false)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type BagItem {
  id: ID! @id
  customer: Customer! @relation(name: "CustomerToBagItem")
  productVariant: ProductVariant!
  position: Int
  saved: Boolean
  status: BagItemStatus!
}

type Customer {
  id: ID! @id
  user: User! @unique
  status: CustomerStatus
  detail: CustomerDetail
  billingInfo: BillingInfo
  plan: Plan
  bagItems: [BagItem] @relation(name: "CustomerToBagItem")
  reservations: [Reservation] @relation(name: "CustomerToReservation")
}

type RecentlyViewedProduct {
  id: ID! @id
  product: Product!
  customer: Customer!
  viewCount: Int! @default(value: 0)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}


type Reservation {
  id: ID! @id
  user: User!
  customer: Customer! @relation(name: "CustomerToReservation")
  sentPackage: Package
    @relation(name: "SeasonsToCustomerPackage", onDelete: CASCADE)
  returnedPackage: Package
    @relation(name: "CustomerToSeasonsPackage", onDelete: CASCADE)
  location: Location
  products: [PhysicalProduct!]!
  reservationNumber: Int! @unique
  shipped: Boolean!
  status: ReservationStatus!
  shippedAt: DateTime
  receivedAt: DateTime
  reminderSentAt: DateTime
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Package {
  id: ID! @id
  items: [PhysicalProduct!]
  shippingLabel: Label!
  fromAddress: Location! @relation(name: "SenderAddress")
  toAddress: Location! @relation(name: "RecipientAddress")
  weight: Float
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Label {
  id: ID! @id
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

type BillingInfo {
  id: ID! @id
  brand: String!
  name: String
  last_digits: String!
  expiration_month: Int!
  expiration_year: Int!
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
}

type ProductRequest {
  id: ID! @id
  brand: String
  description: String
  images: [String!] @scalarList(strategy: RELATION)
  name: String
  price: Int
  priceCurrency: String
  productID: String
  reason: String!
  sku: String
  url: String!
  user: User!
}

type ProductVariantWant {
  id: ID! @id
  productVariant: ProductVariant!
  user: User!
  isFulfilled: Boolean!
}

type TopSize {
  id: ID! @id
  letter: LetterSize
  sleeve: Float
  shoulder: Float
  chest: Float
  neck: Float
  length: Float
}

type BottomSize {
  id: ID! @id
  type: BottomSizeType
  value: String
  waist: Float
  rise: Float
  hem: Float
  inseam: Float
}

type Size {
  id: ID! @id
  slug: String! @unique
  productType: ProductType
  top: TopSize
  bottom: BottomSize
  display: String!
}

type ReservationFeedback {
  id: ID! @id
  comment: String
  feedbacks: [ProductVariantFeedback!]!
    @relation(link: TABLE, onDelete: CASCADE)
  rating: Rating
  user: User!
  reservation: Reservation!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  respondedAt: DateTime
}

type ProductVariantFeedback {
  id: ID! @id
  isCompleted: Boolean!
  questions: [ProductVariantFeedbackQuestion!]! @relation(link: TABLE)
  reservationFeedback: ReservationFeedback!
  variant: ProductVariant!
}

type ProductVariantFeedbackQuestion {
  id: ID! @id
  options: [String!] @scalarList(strategy: RELATION)
  question: String!
  responses: [String!] @scalarList(strategy: RELATION)
  type: QuestionType!
  variantFeedback: ProductVariantFeedback!
}

