enum ProductTierName {
  Standard
  Luxury
}

enum BrandTier {
  Tier0
  Tier1
  Tier2
  Niche
  Upcoming
  Retro
  Boutique
  Local
  Discovery
}

enum Department {
  Clothes
  Bags
  Accessories
  Jewelry
}

enum LocationType {
  Office
  Warehouse
  Cleaner
  Customer
}

enum CustomerStatus {
  Invited
  Created
  Waitlisted
  Authorized
  Active
  Suspended
  PaymentFailed
  Paused
  Deactivated
}

enum UserRole {
  Admin
  Customer
  Partner
  Marketer
}

enum InventoryStatus {
  NonReservable
  Reservable
  Reserved
  Stored
  Offloaded
}

enum PhysicalProductStatus {
  New
  Used
  Dirty
  Damaged
  PermanentlyDamaged
  Clean
  Lost
  Sold
}

enum PhysicalProductOffloadMethod {
  SoldToUser
  SoldToThirdParty
  ReturnedToVendor
  Recycled
  Unknown
}

enum ProductStatus {
  Available
  NotAvailable
  Stored
  Offloaded
}

enum PackageStatus {
  Queued
  Shipped
  Delivered
  Blocked
  Received
  Cancelled
}

enum ReservationStatus {
  Queued
  Packed
  Shipped
  Delivered
  Completed
  Cancelled
  Blocked
  Unknown

  Received
}

enum BagItemStatus {
  Added
  Reserved
  Received
}

enum Plan {
  AllAccess
  Essential
}

enum ProductType {
  Top
  Bottom
  Accessory
  Shoe
}

enum BottomSizeType {
  WxL
  US
  EU
  JP
  Letter
}

enum QuestionType {
  MultipleChoice
  FreeResponse
}

enum Rating {
  Disliked
  Ok
  Loved
}

enum LetterSize {
  XXS
  XS
  S
  M
  L
  XL
  XXL
  XXXL
}

enum ProductArchitecture {
  Fashion
  Showstopper
  Staple
}

enum WarehouseLocationType {
  Conveyor
  Rail
  Bin
}

enum PhotographyStatus {
  Done
  InProgress
  ReadyForEditing
  ReadyToShoot
  Steam
}

enum EmailId {
  CompleteAccount
  BuyUsedOrderConfirmation
  DaySevenAuthorizationFollowup
  DaySixAuthorizationFollowup
  DayFiveAuthorizationFollowup
  DayFourAuthorizationFollowup
  DayThreeAuthorizationFollowup
  DayTwoAuthorizationFollowup
  FreeToReserve
  Paused
  PriorityAccess
  ReferralConfirmation
  ReservationConfirmation
  ReservationReturnConfirmation
  ResumeConfirmation
  ResumeReminder
  ReturnReminder
  Rewaitlisted
  SubmittedEmail
  TwentyFourHourAuthorizationFollowup
  Waitlisted
  WelcomeToSeasons
  UnpaidMembership
  ReturnToGoodStanding
}

enum PackageTransitEventStatus {
  Delivered
  Failure
  PreTransit
  Returned
  Transit
  Unknown
}

enum PackageTransitEventSubStatus {
  AddressIssue
  ContactCarrier
  Delayed
  Delivered
  DeliveryAttempted
  DeliveryRescheduled
  DeliveryScheduled
  InformationReceived
  LocationInaccessible
  NoticeLeft
  Other
  OutForDelivery
  PackageAccepted
  PackageArrived
  PackageDamaged
  PackageDeparted
  PackageDisposed
  PackageForwarded
  PackageHeld
  PackageLost
  PackageProcessed
  PackageProcessing
  PackageUnclaimed
  PackageUndeliverable
  PickupAvailable
  RescheduleDelivery
  ReturnToSender
}

enum ReservationPhase {
  BusinessToCustomer
  CustomerToBusiness
}

enum UserPushNotificationInterestType {
  Bag
  Blog
  Brand
  General
  NewProduct
}

enum InAdmissableReason {
  Untriageable
  UnsupportedPlatform
  AutomaticAdmissionsFlagOff
  UnserviceableZipcode
  InsufficientInventory
  OpsThresholdExceeded
}

enum ShippingCode {
  UPSGround
  UPSSelect
}

type Brand {
  id: ID! @id
  slug: String! @unique
  brandCode: String! @unique
  description: String
  isPrimaryBrand: Boolean! @default(value: false)
  logo: Json
  logoImage: Image @relation(name: "BrandToLogoImage")
  name: String!
  designer: String
  basedIn: String
  products: [Product!]!
  images: [Image!] @relation(name: "BrandToBrandImages")
  since: DateTime
  tier: BrandTier!
  published: Boolean! @default(value: true)
  featured: Boolean! @default(value: false)
  websiteUrl: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  externalShopifyIntegration: ExternalShopifyIntegration
}

type Category {
  id: ID! @id
  slug: String! @unique
  name: String! @unique
  image: Json
  description: String
  visible: Boolean! @default(value: false)
  products: [Product!]!
  children: [Category!]! @relation(name: "CategoryToChildren")
  updatedAt: DateTime @updatedAt
}

type Color {
  id: ID! @id
  slug: String! @unique
  name: String!
  colorCode: String! @unique
  hexCode: String!
  productVariants: [ProductVariant!]!
}

type Collection {
  id: ID! @id
  slug: String! @unique
  images: [Image!]
  title: String
  subTitle: String
  displayTextOverlay: Boolean! @default(value: false)
  textOverlayColor: String
  descriptions: [String]! @scalarList(strategy: RELATION)
  products: [Product!]!
  published: Boolean! @default(value: false)
  placements: [CollectionPlacement!] @scalarList(strategy: RELATION)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime @updatedAt
}

enum CollectionPlacement {
  Homepage
}

type Image {
  id: ID! @id
  caption: String
  url: String! @unique
  height: Int
  width: Int
  title: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Location {
  id: ID! @id
  slug: String @unique
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  country: String
  state: String
  zipCode: String!
  locationType: LocationType
  user: User
  lat: Float
  lng: Float
  physicalProducts: [PhysicalProduct!]!
  shippingOptions: [ShippingOption!]
    @relation(name: "ShippingOptionToDestinationLocation", onDelete: CASCADE)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Tag {
  id: ID! @id
  name: String! @unique
  description: String
  products: [Product!]!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Product {
  id: ID! @id
  architecture: ProductArchitecture
  brand: Brand!
  category: Category!
  color: Color! @relation(name: "ProductPrimaryColor")
  description: String
  externalURL: String
  functions: [ProductFunction!]!
  buyNewEnabled: Boolean! @default(value: false)
  images: [Image!]
  innerMaterials: [String!]! @scalarList(strategy: RELATION)
  materialCategory: ProductMaterialCategory
  model: ProductModel
  modelSize: Size @relation(name: "ProductModelSize")
  name: String!
  outerMaterials: [String!]! @scalarList(strategy: RELATION)
  photographyStatus: PhotographyStatus
  productFit: ProductFit
  publishedAt: DateTime
  retailPrice: Int
  season: ProductSeason
  secondaryColor: Color @relation(name: "ProductSecondaryColor")
  slug: String! @unique
  status: ProductStatus @default(value: Available)
  tags: [Tag!]!
  tier: ProductTier @relation(name: "ProductToProductTier", onDelete: SET_NULL)
  type: ProductType
  variants: [ProductVariant!]! @relation(link: TABLE, onDelete: CASCADE)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ProductTier {
  id: ID! @id
  tier: ProductTierName!
  price: Int! # price in cents
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Season {
  id: ID! @id
  year: Int
  seasonCode: SeasonCode
}

type ProductSeason {
  id: ID! @id
  vendorSeason: Season @relation(name: "ProductSeasonVendorSeason")
  internalSeason: Season @relation(name: "ProductSeasonInternalSeason")
  wearableSeasons: [SeasonString!] @scalarList(strategy: RELATION)
}

type ProductMaterialCategory {
  id: ID! @id
  slug: String! @unique
  lifeExpectancy: Float!
  category: Category!
  products: [Product!]! @relation(link: TABLE)
}

type ProductModel {
  id: ID! @id
  name: String! @unique
  height: Float!
  products: [Product!]! @relation(link: TABLE)
}

type ProductFunction {
  id: ID! @id
  name: String @unique
}

type ProductVariantPrice {
  id: ID! @id
  retailPrice: Float
}

type ExternalShopifyIntegration {
  id: ID! @id
  shopName: String! @unique
  enabled: Boolean!
  accessToken: String
  scope: [String!] @scalarList(strategy: RELATION)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ShopifyProductVariantSelectedOption {
  id: ID! @id
  name: String!
  value: String!
}

type ShopifyProductVariant {
  id: ID! @id
  externalId: String @unique
  displayName: String
  selectedOptions: [ShopifyProductVariantSelectedOption!]
    @relation(name: "ShopifyProductVariantToVariantSelectedOption")
  shop: ExternalShopifyIntegration
  brand: Brand
  title: String
  image: Image
  cachedPrice: Float
  cachedAvailableForSale: Boolean
  cacheExpiresAt: DateTime
}

type ProductVariant {
  id: ID! @id
  sku: String @unique
  displayShort: String!
  color: Color!
  internalSize: Size @relation(name: "ProductVariantSize")
  manufacturerSizes: [Size!] @relation(name: "ProductVariantManufacturerSize")
  weight: Float
  height: Float
  productID: String!
  product: Product! @relation(onDelete: SET_NULL)
  retailPrice: Float
  price: ProductVariantPrice
  shopifyProductVariant: ShopifyProductVariant
    @relation(name: "ShopifyProductVariantToVariant")
  physicalProducts: [PhysicalProduct!]!
    @relation(link: TABLE, onDelete: CASCADE)
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
  offloaded: Int!
  stored: Int!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type PhysicalProductPrice {
  id: ID! @id
  buyUsedEnabled: Boolean! @default(value: false)
  buyUsedPrice: Float
}

enum PhysicalProductDamageType {
  BarcodeMissing
  ButtonMissing
  Stain
  Smell
  Tear
  Other
}

type PhysicalProductQualityReport {
  id: ID! @id
  user: User!
  damageType: PhysicalProductDamageType
  damageTypes: [PhysicalProductDamageType!] @scalarList(strategy: RELATION)
  notes: String
  physicalProduct: PhysicalProduct!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type PhysicalProduct {
  id: ID! @id
  seasonsUID: String! @unique
  location: Location
  productVariant: ProductVariant! @relation(onDelete: SET_NULL)
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  offloadMethod: PhysicalProductOffloadMethod
  offloadNotes: String
  sequenceNumber: Int!
  warehouseLocation: WarehouseLocation
  barcoded: Boolean @default(value: false)
  dateOrdered: DateTime
  dateReceived: DateTime
  unitCost: Float
  price: PhysicalProductPrice
  reports: [PhysicalProductQualityReport!]!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ProductNotification {
  id: ID! @id
  type: ProductNotificationType!
  customer: Customer! @relation(name: "CustomerToProductNotification")
  physicalProduct: PhysicalProduct
    @relation(name: "PhysicalProductToProductNotification")
  productVariant: ProductVariant
    @relation(name: "ProductVariantToProductNotification")
  shouldNotify: Boolean! @default(value: true)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

enum ProductFit {
  RunsBig
  TrueToSize
  RunsSmall
}

enum ProductNotificationType {
  Restock
  AvailableForPurchase
}

type WarehouseLocationConstraint {
  id: ID! @id
  category: Category!
  limit: Int!
  locations: [WarehouseLocation!]
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type WarehouseLocation {
  id: ID! @id
  type: WarehouseLocationType!
  barcode: String! @unique
  locationCode: String!
  itemCode: String!
  physicalProducts: [PhysicalProduct!]
  constraints: [WarehouseLocationConstraint!]
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type PaymentPlan {
  id: ID! @id
  description: String
  planID: String! @unique
  status: String
  name: String
  price: Int
  itemCount: Int
  tagline: String
  tier: PaymentPlanTier
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

enum PaymentPlanTier {
  Essential
  AllAccess
  Pause
}

type EmailReceipt {
  id: ID! @id
  emailId: EmailId!
  user: User! @relation(name: "UserToEmailReceipts")
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

enum SmsStatus {
  Queued
  Sending
  Sent
  Failed
  Delivered
  Undelivered
  Receiving
  Received
  Accepted
  Scheduled
  Read
  PartiallyDelivered
}

type SmsReceipt {
  id: ID! @id
  # externalId = external id provided by the SMS service
  externalId: String
  # body = body of the message
  body: String!
  # mediaUrls = image urls attached to message
  mediaUrls: [String!] @scalarList(strategy: RELATION)
  # status = delivery status
  status: SmsStatus!
  smsId: String
  sentAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type PushNotificationReceipt {
  #id of the notification
  id: ID! @id
  # e.g BagStack, Faq, Webview
  route: String
  # screen on the route
  screen: String
  # uri, e.g https://blog.seasons.nyc/posts/can-the-industry-fix-seasons
  uri: String
  users: [User!] @relation(name: "UserToPushNotificationReceipts")
  # interest = interest we sent it to
  interest: String
  # body = body of the message
  body: String!
  # title = title of the message
  title: String
  # id we pass as a param
  recordID: String
  # slug we pass as a param
  recordSlug: String
  # key/identifier of the notification payload
  notificationKey: String
  sentAt: DateTime!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

enum SeasonCode {
  # For Vendor and Internal Seasons
  FW # Fall winter
  SS # Spring Summer
  # For Vendor Seasons only
  PS # Pre spring
  PF # Pre Fall
  HO # Holiday
  AW # Autumn Winter
}

enum SeasonString {
  Spring
  Summer
  Winter
  Fall
}

enum UserVerificationMethod {
  SMS
  Email
  None
}

enum UserVerificationStatus {
  Approved
  Denied
  Pending
}

enum PushNotificationStatus {
  Blocked
  Granted
  Denied
}

enum FitPicStatus {
  Submitted
  Published
  Unpublished
}

type FitPic {
  id: ID! @id
  image: Image!
  includeInstagramHandle: Boolean! @default(value: false)
  location: Location
  products: [Product!] @scalarList(strategy: RELATION)
  reports: [FitPicReport!]!
    @relation(name: "FitPicToFitPicReport", onDelete: CASCADE)
  status: FitPicStatus! @default(value: Submitted)
  user: User! @relation(name: "UserToFitPic")
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

enum FitPicReportStatus {
  Pending
  Reviewed
}

type FitPicReport {
  id: ID! @id
  reporter: User!
  reported: FitPic! @relation(name: "FitPicToFitPicReport")
  status: FitPicReportStatus! @default(value: Pending)
  reportedAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type InterestedUser {
  id: ID! @id
  email: String!
  zipcode: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type User {
  id: ID! @id
  auth0Id: String! @unique
  email: String! @unique
  firstName: String!
  lastName: String!
  role: UserRole! @default(value: Customer)
  roles: [UserRole!]! @scalarList(strategy: RELATION)
  pushNotificationStatus: PushNotificationStatus! @default(value: Denied)
  pushNotifications: [PushNotificationReceipt!]
    @relation(name: "UserToPushNotificationReceipts", onDelete: CASCADE)
  emails: [EmailReceipt!] @relation(name: "UserToEmailReceipts")
  sendSystemEmails: Boolean! @default(value: true)
  pushNotification: UserPushNotification
  verificationStatus: UserVerificationStatus! @default(value: Pending)
  verificationMethod: UserVerificationMethod! @default(value: None)
  smsReceipts: [SmsReceipt!]!
    @relation(name: "UserToSmsReceipts", onDelete: CASCADE)
  fitPics: [FitPic!]! @relation(name: "UserToFitPic", onDelete: CASCADE)
  deviceData: UserDeviceData
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type UserDeviceData {
  id: ID! @id
  iOSVersion: String
}

type StylePreferences {
  id: ID! @id
  styles: [String] @scalarList(strategy: RELATION)
  patterns: [String] @scalarList(strategy: RELATION)
  colors: [String] @scalarList(strategy: RELATION)
  brands: [String] @scalarList(strategy: RELATION)
}

enum CustomerStyle {
  AvantGarde
  Bold
  Classic
  Minimalist
  Streetwear
  Techwear
}

type CustomerDetail {
  id: ID! @id
  phoneNumber: String
  birthday: DateTime
  # Height in inches
  height: Int
  # The weight range [min, max], where max = min + 10
  weight: [Int] @scalarList(strategy: RELATION)
  bodyType: String
  averageTopSize: String # to be deprecated in favor of topSizes
  topSizes: [String] @scalarList(strategy: RELATION)
  averageWaistSize: String # to be deprecated in favor of waistSizes
  waistSizes: [Int] @scalarList(strategy: RELATION)
  averagePantLength: String
  preferredPronouns: String
  profession: String
  # How often do you go out?
  partyFrequency: String
  # Do you travel a lot?
  travelFrequency: String
  # How often do you buy clothes?
  shoppingFrequency: String
  # How much do you spend?
  averageSpend: String
  style: String
  styles: [CustomerStyle!] @scalarList(strategy: RELATION)
  commuteStyle: String
  stylePreferences: StylePreferences
  shippingAddress: Location
  phoneOS: String
  insureShipment: Boolean! @default(value: false)
  instagramHandle: String
  impactId: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type BagItem {
  id: ID! @id
  customer: Customer! @relation(name: "CustomerToBagItem")
  productVariant: ProductVariant!
  position: Int
  saved: Boolean
  status: BagItemStatus!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type CustomerAdmissionsData {
  id: ID! @id
  inServiceableZipcode: Boolean!
  admissable: Boolean!
  inAdmissableReason: InAdmissableReason
  allAccessEnabled: Boolean! @default(value: true)
  customer: Customer!
    @relation(name: "CustomerToCustomerAdmissionsData", onDelete: SET_NULL)
  authorizationsCount: Int!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  authorizationWindowClosesAt: DateTime
}

type UTMData {
  id: ID! @id
  customer: Customer! @relation(name: "CustomerToUTMData", onDelete: SET_NULL)
  source: String
  medium: String
  campaign: String
  term: String
  content: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Customer {
  id: ID! @id
  user: User! @unique @relation(name: "CustomerToUser", onDelete: CASCADE)
  status: CustomerStatus
  detail: CustomerDetail
    @relation(name: "CustomerToCustomerDetail", onDelete: CASCADE)
  billingInfo: BillingInfo
  plan: Plan
  membership: CustomerMembership
    @relation(name: "CustomerToCustomerMembership", onDelete: CASCADE)
  bagItems: [BagItem] @relation(name: "CustomerToBagItem")
  reservations: [Reservation] @relation(name: "CustomerToReservation")
  referralLink: String @unique
  referrerId: String
  referrer: Customer
    @relation(name: "CustomerReferrals", fields: [referrerId], references: [id])
  referrees: [Customer] @relation(name: "CustomerReferrals")

  ## A list of all the products we've shown this person via email
  emailedProducts: [Product!]!
    @relation(name: "CustomerToEmailedProducts", onDelete: SET_NULL)
  admissions: CustomerAdmissionsData
    @relation(
      name: "CustomerToCustomerAdmissionsData"
      link: INLINE
      onDelete: SET_NULL
    )
  authorizedAt: DateTime
  utm: UTMData
    @relation(name: "CustomerToUTMData", link: INLINE, onDelete: CASCADE)
  notificationBarReceipts: [CustomerNotificationBarReceipt]
    @relation(
      name: "CustomerToCustomerNotificationBarReceipts"
      link: TABLE
      onDelete: CASCADE
    )
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

enum NotificationBarID {
  PastDueInvoice
  TestDismissable
}
type CustomerNotificationBarReceipt {
  id: ID! @id
  notificationBarId: NotificationBarID!
  viewCount: Int! @default(value: 0)
  clickCount: Int! @default(value: 0)
  customer: Customer!
    @relation(
      name: "CustomerToCustomerNotificationBarReceipts"
      onDelete: SET_NULL
    )
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type CustomerMembershipSubscriptionData {
  id: ID! @id
  planID: String!
  subscriptionId: String!
  currentTermStart: DateTime!
  currentTermEnd: DateTime!
  nextBillingAt: DateTime
  status: String!
  planPrice: Int!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type CustomerMembership {
  id: ID! @id
  plan: PaymentPlan
  subscriptionId: String!
  subscription: CustomerMembershipSubscriptionData
    @relation(
      name: "CustomerToCustomerMembershipSubscriptionData"
      onDelete: CASCADE
    )
  customer: Customer!
    @relation(
      name: "CustomerToCustomerMembership"
      link: INLINE
      onDelete: SET_NULL
    )
  pauseRequests: [PauseRequest]
    @relation(name: "CustomerMembershipToPauseRequest", onDelete: CASCADE)
  giftId: String
}

enum PauseType {
  WithItems
  WithoutItems
}

type PauseRequest {
  id: ID! @id
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  pausePending: Boolean!
  pauseType: PauseType! @default(value: WithoutItems)
  pauseDate: DateTime
  resumeDate: DateTime
  notified: Boolean! @default(value: false)
  membership: CustomerMembership!
    @relation(name: "CustomerMembershipToPauseRequest")
}

type RecentlyViewedProduct {
  id: ID! @id
  product: Product!
  customer: Customer!
  viewCount: Int! @default(value: 0)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

enum OrderType {
  Used
  New
  External
}

enum OrderLineItemRecordType {
  PhysicalProduct
  ProductVariant
  ExternalProduct
  Package
}

enum OrderStatus {
  Drafted
  Submitted
  Fulfilled
  Returned
  Cancelled
}

enum OrderCancelReason {
  Customer # The customer wanted to cancel the order
  Declined # Payment was declined
  Fraud # The order was fraudulent
  Inventory # There was insufficient inventory
  Other # Some other reason not listed
}

enum OrderPaymentStatus {
  Paid
  PartiallyPaid
  Refunded
  NotPaid
}

type OrderLineItem {
  id: ID! @id
  recordID: ID!
  recordType: OrderLineItemRecordType!
  needShipping: Boolean
  taxRate: Float
  taxName: String
  taxPercentage: Float
  taxPrice: Int
  price: Int!
  currencyCode: String!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Order {
  id: ID! @id
  customer: Customer!
  sentPackage: Package
  lineItems: [OrderLineItem!]!
  orderNumber: String! @unique
  type: OrderType!
  status: OrderStatus! @default(value: Drafted)
  subTotal: Int
  total: Int
  cancelReason: OrderCancelReason
  couponID: String
  paymentStatus: OrderPaymentStatus! @default(value: NotPaid)
  note: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Reservation {
  id: ID! @id
  user: User!
  customer: Customer! @relation(name: "CustomerToReservation")
  sentPackage: Package
    @relation(link: INLINE, name: "SeasonsToCustomerPackage", onDelete: CASCADE)
  returnedPackage: Package
    @relation(link: INLINE, name: "CustomerToSeasonsPackage", onDelete: CASCADE)
  products: [PhysicalProduct!]!
  packageEvents: [PackageTransitEvent!]
  reservationNumber: Int! @unique
  phase: ReservationPhase!
  shipped: Boolean!
  status: ReservationStatus!
  shippedAt: DateTime
  receivedAt: DateTime
  reminderSentAt: DateTime
  statusUpdatedAt: DateTime
  receipt: ReservationReceipt
    @relation(
      link: INLINE
      name: "ReservationReceiptToReservation"
      onDelete: CASCADE
    )
  lastLocation: Location
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  shippingOption: ShippingOption
    @relation(
      link: INLINE
      name: "ShippingMethodToReservation"
      onDelete: SET_NULL
    )
}

type ReservationFeedback {
  id: ID! @id
  comment: String
  feedbacks: [ProductVariantFeedback!]!
    @relation(link: TABLE, onDelete: CASCADE)
  rating: Rating
  user: User!
  reservation: Reservation!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  respondedAt: DateTime
}

type ProductVariantFeedback {
  id: ID! @id
  isCompleted: Boolean!
  questions: [ProductVariantFeedbackQuestion!]! @relation(link: TABLE)
  reservationFeedback: ReservationFeedback!
  variant: ProductVariant!
}

type ProductVariantFeedbackQuestion {
  id: ID! @id
  options: [String!] @scalarList(strategy: RELATION)
  question: String!
  responses: [String!] @scalarList(strategy: RELATION)
  type: QuestionType!
  variantFeedback: ProductVariantFeedback!
}

type ReservationReceipt {
  id: ID! @id
  reservation: Reservation! @relation(name: "ReservationReceiptToReservation")
  items: [ReservationReceiptItem!] @relation(link: TABLE, onDelete: CASCADE)
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ReservationReceiptItem {
  id: ID! @id
  product: PhysicalProduct!
  productStatus: PhysicalProductStatus!
  notes: String
}

type UserPushNotificationInterest {
  id: ID! @id
  type: UserPushNotificationInterestType!
  value: String! # e.g. CDGS,
  user: User!
  status: Boolean! @default(value: true)
}

type UserPushNotification {
  id: ID! @id
  interests: [UserPushNotificationInterest!]!
  status: Boolean! @default(value: true)
  history: [PushNotificationReceipt!]!
}

type Package {
  id: ID! @id
  items: [PhysicalProduct!]
  transactionID: String!
  shippingLabel: Label!
  fromAddress: Location! @relation(name: "SenderAddress")
  toAddress: Location! @relation(name: "RecipientAddress")
  weight: Float
  cost: Int #cents
  events: [PackageTransitEvent!]
  status: PackageStatus
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type PackageTransitEvent {
  id: ID! @id
  status: PackageTransitEventStatus!
  subStatus: PackageTransitEventSubStatus!
  package: Package!
  reservation: Reservation
  data: Json!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ShippingMethod {
  id: ID! @id
  code: ShippingCode!
  displayText: String!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ShippingOption {
  id: ID! @id
  origin: Location
    @relation(name: "ShippingOptionToOriginLocation", onDelete: SET_NULL) # defaults to warehouse location
  destination: Location
    @relation(name: "ShippingOptionToDestinationLocation", onDelete: SET_NULL)
  shippingMethod: ShippingMethod
  externalCost: Int
  averageDuration: Int #days
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Label {
  id: ID! @id
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

type BillingInfo {
  id: ID! @id
  brand: String!
  name: String
  last_digits: String!
  expiration_month: Int!
  expiration_year: Int!
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type ProductRequest {
  id: ID! @id
  brand: String
  description: String
  images: [String!] @scalarList(strategy: RELATION)
  name: String
  price: Int
  priceCurrency: String
  productID: String
  reason: String!
  sku: String
  url: String!
  user: User!
}

type ProductVariantWant {
  id: ID! @id
  productVariant: ProductVariant!
  user: User!
  isFulfilled: Boolean!
}

type TopSize {
  id: ID! @id
  letter: LetterSize
  sleeve: Float
  shoulder: Float
  chest: Float
  neck: Float
  length: Float
}

type BottomSize {
  id: ID! @id
  type: BottomSizeType
  value: String
  waist: Float
  rise: Float
  hem: Float
  inseam: Float
}

type Size {
  id: ID! @id
  slug: String! @unique
  productType: ProductType
  top: TopSize
  bottom: BottomSize
  display: String!
}

# Helper table for audit logs. Should only ever have 0 or 1 records.
# In the event that it has a record, stores a link to the admin currently making a change
type ActiveAdminUser {
  id: ID! @id
  admin: User!
}

enum AdminAction {
  Insert
  Delete
  Update
  Truncate
}

type AdminActionLog {
  actionId: Int! @id(strategy: AUTO)
  entityId: String!
  tableName: String!
  activeAdminUser: User!
  triggeredAt: DateTime!
  action: AdminAction!
  rowData: Json!
  changedFields: Json
  statementOnly: Boolean!
}

enum SyncTimingType {
  Drip
  Next
}

type SyncTiming {
  id: ID! @id
  type: SyncTimingType!
  syncedAt: DateTime!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

type Launch {
  id: ID! @id
  brand: Brand
  published: Boolean! @default(value: false)
  collection: Collection
  launchAt: DateTime!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}
