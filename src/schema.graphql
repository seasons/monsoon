# import Brand, Category, User, Bag, Collection, CustomerDetail, ProductFunction, SavedProduct from "./prisma/prisma.graphql"
# import BlogCollection, BlogPost, Query from "./modules/Blog/blog.graphql"
# import SearchOptions, SearchResultType, SearchResult, Query from "./modules/Search/search.graphql"
# import Query, Mutation from "./modules/Customer/customer.graphql"
# import Query, Mutation from "./modules/User/user.graphql"
# import Reservation, Query, Mutation from "./modules/Reservation/reservation.graphql"

directive @isAuthenticated on FIELD_DEFINITION
directive @hasRole(roles: [String]) on FIELD_DEFINITION

scalar Upload

type Product {
  id: ID!
  slug: String!
  name: String!
  brand: Brand!
  category: Category!
  type: ProductType
  description: String
  externalURL: String
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: Color!
  secondaryColor: Color
  tags: [Tag!]!
  images: Json!
  resizedImages(width: Int, height: Int, size: ImageSize): [Image!]!
  functions(
    where: ProductFunctionWhereInput
    orderBy: ProductFunctionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [ProductFunction!]
  innerMaterials: [String!]!
  outerMaterials: [String!]!
  variants(
    where: ProductVariantWhereInput
    orderBy: ProductVariantOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [ProductVariant!]
  status: ProductStatus
  isSaved: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductVariant {
  id: ID!
  sku: String
  color: Color!
  size: String
  internalSize: Size
  manufacturerSizes(
    where: SizeWhereInput
    orderBy: SizeOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Size!]
  weight: Float
  height: Float
  productID: String!
  product: Product!
  retailPrice: Float
  physicalProducts(
    where: PhysicalProductWhereInput
    orderBy: PhysicalProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [PhysicalProduct!]
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
  isSaved: Boolean!
  isInBag: Boolean!
  isWanted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input WarehouseLocationConnectWhereUniqueInput {
  connect: WarehouseLocationWhereUniqueInput
}

input PhysicalProductUpdateInput {
  seasonsUID: String
  location: LocationUpdateOneWithoutPhysicalProductsInput
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
  offloadMethod: PhysicalProductOffloadMethod
  offloadNotes: String
  barcode: String
  sequenceNumber: Int
  warehouseLocation: WarehouseLocationConnectWhereUniqueInput
}

type Query {
  brand(where: BrandWhereUniqueInput!): Brand
  brands(
    where: BrandWhereInput
    orderBy: BrandOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Brand]!
  brandsConnection(
    where: BrandWhereInput
    orderBy: BrandOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): BrandConnection!
  bottomSize(where: BottomSizeWhereUniqueInput!): BottomSize
  bottomSizes(
    where: BottomSizeWhereInput
    orderBy: BottomSizeOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [BottomSize]!
  category(where: CategoryWhereUniqueInput!): Category
  categories(
    where: CategoryWhereInput
    orderBy: CategoryOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Category]!
  categoriesConnection(
    where: CategoryWhereInput
    orderBy: CategoryOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): CategoryConnection!
  collection(where: CollectionWhereUniqueInput!): Collection
  collections(
    where: CollectionWhereInput
    orderBy: CollectionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Collection]!
  colors(
    where: ColorWhereInput
    orderBy: ColorOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Color]!
  generatedVariantSKUs(input: ProductVariantSKUsInput!): [String!]
  homepageProductRail(
    where: HomepageProductRailWhereUniqueInput!
  ): HomepageProductRail
  homepageProductRails(
    where: HomepageProductRailWhereInput
    orderBy: HomepageProductRailOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [HomepageProductRail]!
  package(where: PackageWhereUniqueInput!): Package
  packages(
    where: PackageWhereInput
    orderBy: PackageOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Package]!
  packagesConnection(
    where: PackageWhereInput
    orderBy: PackageOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): PackageConnection!
  physicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  physicalProducts(
    where: PhysicalProductWhereInput
    orderBy: PhysicalProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [PhysicalProduct]!
  product(where: ProductWhereUniqueInput!): Product
  products(
    category: String
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    sizes: [String!]
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Product]!
  productsConnection(
    sizes: [String!]
    category: String
    brand: String
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    skip: Int
    sizes: [String!]
    after: String
    before: String
    first: Int
    last: Int
  ): ProductConnection!
  productFunctions(
    where: ProductFunctionWhereInput
    orderBy: ProductFunctionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [ProductFunction]!
  productModels(
    where: ProductModelWhereInput
    orderBy: ProductModelOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [ProductModel]!
  productRequests(
    where: ProductRequestWhereInput
    orderBy: ProductRequestOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [ProductRequest]!
  size(where: SizeWhereUniqueInput!): Size
  sizes(
    where: SizeWhereInput
    orderBy: SizeOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Size]!
  sizesConnection(
    where: SizeWhereInput
    orderBy: SizeOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): SizeConnection!
  topSize(where: TopSizeWhereUniqueInput!): TopSize
  topSizes(
    where: TopSizeWhereInput
    orderBy: TopSizeOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [TopSize]!
  user(where: UserWhereUniqueInput!): User
  users(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [User]! @hasRole(roles: ["Admin"])
  usersConnection(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!

  # Custom Fields
  faq: Faq
  homepage: Homepage
  chargebeeCheckout(
    planID: PlanID!
    userIDHash: String!
  ): ChargebeeHostedPagePayload
  chargebeeUpdatePaymentPage: ChargebeeHostedPagePayload
  reservationFeedback: ReservationFeedback
}

type ChargebeeHostedPagePayload {
  created_at: DateTime!
  embed: Boolean!
  expires_at: Int!
  id: String!
  object: String!
  resource_version: DateTime!
  state: String!
  type: String!
  updated_at: DateTime!
  url: String!
}

type Mutation {
  beamsData: BeamsData!
  checkItemsAvailability(items: [ID!]!): Boolean! @hasRole(roles: ["Customer"])
  addToBag(item: ID!): BagItem! @hasRole(roles: ["Customer"])
  removeFromBag(item: ID!, saved: Boolean): BagItem!
    @hasRole(roles: ["Customer"])
  saveProduct(item: ID!, save: Boolean!): BagItem @hasRole(roles: ["Customer"])
  updateProduct(
    where: ProductWhereUniqueInput!
    data: ProductUpdateInput!
  ): Product! @hasRole(roles: ["Admin"])
  updatePhysicalProduct(
    where: PhysicalProductWhereUniqueInput!
    data: PhysicalProductUpdateInput!
  ): PhysicalProduct @hasRole(roles: ["Admin"])
  addViewedProduct(item: ID!): RecentlyViewedProduct!
  acknowledgeCompletedChargebeeHostedCheckout(
    hostedPageID: String!
  ): BillingInfoPayload @hasRole(roles: ["Customer"])
  refundInvoice(input: RefundInvoiceInput): Boolean! @hasRole(roles: ["Admin"])
  addProductRequest(reason: String!, url: String!): ProductRequest!
  validateAddress(input: ValidateAddressInput!): ValidationPayload!
  addProductVariantWant(variantID: ID!): ProductVariantWant!
  updateReservationFeedback(
    feedbackID: ID!
    input: ReservationFeedbackUpdateInput!
  ): ReservationFeedback! @hasRole(roles: ["Admin"])
  upsertProduct(input: UpsertProductInput!): Product @hasRole(roles: ["Admin"])
  uploadImage(image: Upload!): String @hasRole(roles: ["Admin"])
}

input RefundInvoiceInput {
  invoiceId: String!
  refundAmount: Int
  comment: String
  customerNotes: String
  reasonCode: CreditNoteReasonCodeInput
}

input ProductVariantSKUsInput {
  brandID: String!
  colorID: String!
  sizeNames: [String!]!
}

input UpsertProductInput {
  name: String!
  images: [Upload!]!
  brandID: String!
  categoryID: String!
  type: ProductType!
  description: String!
  modelID: String!
  retailPrice: Int!
  modelSizeName: String!
  modelSizeDisplay: String!
  bottomSizeType: BottomSizeType
  colorID: String!
  secondaryColorID: String
  tags: [String!]!
  functions: [String!]!
  innerMaterials: [String!]!
  outerMaterials: [String!]!
  status: ProductStatus!
  season: String!
  architecture: String!
  variants: [UpsertVariantInput!]!
}

input UpsertVariantInput {
  sku: String!
  internalSizeName: String!
  # Top Size values
  sleeve: Float
  shoulder: Float
  chest: Float
  neck: Float
  length: Float
  # Bottom Size values
  bottomSizeType: BottomSizeType
  waist: Float
  rise: Float
  hem: Float
  inseam: Float
  weight: Float!
  total: Int!
  physicalProducts: [UpsertPhysicalProductInput!]!
}

input UpsertPhysicalProductInput {
  seasonsUID: String!
  inventoryStatus: InventoryStatus!
  physicalProductStatus: PhysicalProductStatus!
}

type BeamsData {
  email: String!
  beamsToken: String!
}

type BillingInfoPayload {
  billingInfo: BillingInfo
  plan: Plan
}

input ValidateAddressInput {
  location: LocationCreateInput!
  email: String!
}

type ValidationPayload {
  isValid: Boolean!
  code: String
  text: String
}

type Image {
  height: Int
  width: Int
  url: String
  originalHeight: Int
  originalWidth: Int
  entityID: String
  entityType: String
}

type Homepage {
  sections: [HomepageSection!]!
}

type HomepageSection {
  type: HomePageSectionType!
  results: [HomepageResult!]!
  title: String
}

union HomepageResult = Product | Collection | Brand

enum TransactionStatus {
  InProgress
  Success
  Voided
  Failure
  Timeout
  NeedsAttention
}

enum InvoiceStatus {
  Paid
  Posted
  PaymentDue
  NotPaid
  Voided
  Pending
}

enum TransactionType {
  Authorization
  Payment
  Refund
  PaymentReversal
}

enum HomePageSectionType {
  CollectionGroups
  Products
  HomepageProductRails
  Brands
}

enum PlanID {
  AllAccess
  Essential
}

enum Event {
  CompletedWaitlistForm
}

enum CreditNoteReasonCodeInput {
  ProductUnsatisfactory
  ServiceUnsatisfactory
  OrderChange
  OrderCancellation
  Waiver
  Other
}

enum CreditNoteReasonCode {
  SubscriptionChange
  ProductUnsatisfactory
  ServiceUnsatisfactory
  OrderChange
  OrderCancellation
  Waiver
  Other
}

enum CreditNoteStatus {
  Adjusted
  Refunded
  RefundDue
  Voided
}

type Faq {
  sections: [FaqSection!]!
}

type FaqSection {
  title: String!
  subsections: [FaqSubsection!]!
}

type FaqSubsection {
  title: String!
  text: String!
}

enum ImageSize {
  Thumb
  Small
  Medium
  Large
  XLarge
}

type Invoice {
  id: String!
  subscriptionId: String
  recurring: Boolean
  status: InvoiceStatus
  closingDate: DateTime
  dueDate: DateTime
  amount: Int
  transactions: [Transaction]
  creditNotes: [CreditNote]
}

type Transaction {
  id: String!
  amount: Int
  lastFour: String
  date: DateTime
  status: TransactionStatus
  type: TransactionType!
  settledAt: DateTime
}

type CreditNote {
  id: String!
  reasonCode: CreditNoteReasonCode
  date: DateTime
  total: Int
  status: CreditNoteStatus
}
