# import Brand, Category, User, Bag, Collection, CustomerDetail, ProductFunction, SavedProduct from "./prisma/prisma.graphql"
# import BlogCollection, BlogPost, Query from "./modules/Blog/blog.graphql"
# import SearchOptions, SearchResultType, SearchResult, Query from "./modules/Search/search.graphql"
# import Query, Mutation from "./modules/Customer/customer.graphql"
# import Query, Mutation from "./modules/User/user.graphql"
# import Reservation, Query, Mutation from "./modules/Reservation/reservation.graphql"
# import Product, ProductVariant, Query, Mutation from "./modules/Product/product.graphql"
# import Image, Mutation from "./modules/Image/image.graphql"
# import Query from "./modules/Homepage/homepage.graphql"

directive @isAuthenticated on FIELD_DEFINITION
directive @hasRole(roles: [String]) on FIELD_DEFINITION

type Query {
  faq: Faq
  chargebeeCheckout(
    planID: PlanID!
    userIDHash: String!
  ): ChargebeeHostedPagePayload
  chargebeeUpdatePaymentPage: ChargebeeHostedPagePayload

  package(where: PackageWhereUniqueInput!): Package
  packages(
    where: PackageWhereInput
    orderBy: PackageOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Package]!
  packagesConnection(
    where: PackageWhereInput
    orderBy: PackageOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): PackageConnection!
}

type ChargebeeHostedPagePayload {
  created_at: DateTime!
  embed: Boolean!
  expires_at: Int!
  id: String!
  object: String!
  resource_version: DateTime!
  state: String!
  type: String!
  updated_at: DateTime!
  url: String!
}

type Mutation {
  beamsData: BeamsData!
  acknowledgeCompletedChargebeeHostedCheckout(
    hostedPageID: String!
  ): BillingInfoPayload @hasRole(roles: ["Customer"])
  refundInvoice(input: RefundInvoiceInput): Boolean! @hasRole(roles: ["Admin"])
  validateAddress(input: ValidateAddressInput!): ValidationPayload!
}

input RefundInvoiceInput {
  invoiceId: String!
  refundAmount: Int
  comment: String
  customerNotes: String
  reasonCode: CreditNoteReasonCodeInput
}

input AddressInput {
  city: String!
  postalCode: String!
  state: String!
  street1: String!
  street2: String
}

input ReserveItemsOptions {
  dryRun: Boolean
}

type BeamsData {
  email: String!
  beamsToken: String!
}

type BillingInfoPayload {
  billingInfo: BillingInfo
  plan: Plan
}

input ValidateAddressInput {
  location: LocationCreateInput!
  email: String!
}

type ValidationPayload {
  isValid: Boolean!
  code: String
  text: String
}

enum TransactionStatus {
  InProgress
  Success
  Voided
  Failure
  Timeout
  NeedsAttention
}

enum InvoiceStatus {
  Paid
  Posted
  PaymentDue
  NotPaid
  Voided
  Pending
}

enum TransactionType {
  Authorization
  Payment
  Refund
  PaymentReversal
}

enum PlanID {
  AllAccess
  Essential
}

enum Event {
  CompletedWaitlistForm
}

enum CreditNoteReasonCodeInput {
  ProductUnsatisfactory
  ServiceUnsatisfactory
  OrderChange
  OrderCancellation
  Waiver
  Other
}

enum CreditNoteReasonCode {
  SubscriptionChange
  ProductUnsatisfactory
  ServiceUnsatisfactory
  OrderChange
  OrderCancellation
  Waiver
  Other
}

enum CreditNoteStatus {
  Adjusted
  Refunded
  RefundDue
  Voided
}

type Faq {
  sections: [FaqSection!]!
}

type FaqSection {
  title: String!
  subsections: [FaqSubsection!]!
}

type FaqSubsection {
  title: String!
  text: String!
}

type Invoice {
  id: String!
  subscriptionId: String
  recurring: Boolean
  status: InvoiceStatus
  closingDate: DateTime
  dueDate: DateTime
  amount: Int
  transactions: [Transaction]
  creditNotes: [CreditNote]
}

type Transaction {
  id: String!
  amount: Int
  lastFour: String
  date: DateTime
  status: TransactionStatus
  type: TransactionType!
  settledAt: DateTime
}

type CreditNote {
  id: String!
  reasonCode: CreditNoteReasonCode
  date: DateTime
  total: Int
  status: CreditNoteStatus
}
