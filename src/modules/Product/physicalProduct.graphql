type Query {
  physicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  physicalProducts(
    where: PhysicalProductWhereInput
    orderBy: PhysicalProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [PhysicalProduct]!
  physicalProductsConnection(
    where: PhysicalProductWhereInput
    orderBy: PhysicalProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): PhysicalProductConnection!
  warehouseLocations(
    where: WarehouseLocationWhereInput
    orderBy: WarehouseLocationOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [WarehouseLocation]! @hasRole(roles: [Admin])
  generatedSeasonsUIDs(input: PhysicalProductSeasonsUIDsInput!): [String!]
  surpriseProductVariants: [ProductVariant]!
}

type Mutation {
  updatePhysicalProduct(
    where: PhysicalProductWhereUniqueInput!
    data: PhysicalProductUpdateInput!
  ): PhysicalProduct @hasRole(roles: [Admin])
  updateManyPhysicalProducts(
    data: PhysicalProductUpdateManyMutationInput!
    where: PhysicalProductWhereInput
  ): BatchPayload! @hasRole(roles: [Admin])
}

type PhysicalProductPrice {
  id: ID!
  buyUsedPrice: Float
  buyUsedEnabled: Boolean!
}

type PhysicalProduct {
  id: ID!
  seasonsUID: String!
  location: Location
  productVariant: ProductVariant
  warehouseLocation: WarehouseLocation
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  offloadMethod: PhysicalProductOffloadMethod
  offloadNotes: String
  sequenceNumber: Int!
  barcoded: Boolean!
  barcode: String!
  dateOrdered: DateTime
  dateReceived: DateTime
  unitCost: Float
  price: PhysicalProductPrice
  reservations(orderBy: ReservationOrderByInput): [Reservation!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input WarehouseLocationConnectWhereUniqueInput {
  connect: WarehouseLocationWhereUniqueInput
  disconnect: Boolean
}

input PhysicalProductPriceInput {
  buyUsedPrice: Float
  buyUsedEnabled: Boolean!
}

input PhysicalProductUpdateInput {
  seasonsUID: String
  location: LocationUpdateOneWithoutPhysicalProductsInput
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
  offloadMethod: PhysicalProductOffloadMethod
  offloadNotes: String
  barcode: String
  barcoded: Boolean
  sequenceNumber: Int
  warehouseLocation: WarehouseLocationConnectWhereUniqueInput
  dateOrdered: DateTime
  dateReceived: DateTime
  unitCost: Float
  price: PhysicalProductPriceInput
}

input UpsertPhysicalProductInput {
  dateOrdered: DateTime
  dateReceived: DateTime
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  seasonsUID: String!
  unitCost: Float
  price: PhysicalProductPriceInput
}

input PhysicalProductSeasonsUIDsInput {
  brandID: ID!
  colorCode: String!
  sizes: [PhysicalProductSeasonsUIDSizes!]!
}

input PhysicalProductSeasonsUIDSizes {
  sizeName: String!
  count: Int!
}
