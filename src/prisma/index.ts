// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  activeAdminUser: (where?: ActiveAdminUserWhereInput) => Promise<boolean>;
  adminActionLog: (where?: AdminActionLogWhereInput) => Promise<boolean>;
  bagItem: (where?: BagItemWhereInput) => Promise<boolean>;
  billingInfo: (where?: BillingInfoWhereInput) => Promise<boolean>;
  bottomSize: (where?: BottomSizeWhereInput) => Promise<boolean>;
  brand: (where?: BrandWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  collection: (where?: CollectionWhereInput) => Promise<boolean>;
  color: (where?: ColorWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  customerAdmissionsData: (
    where?: CustomerAdmissionsDataWhereInput
  ) => Promise<boolean>;
  customerDetail: (where?: CustomerDetailWhereInput) => Promise<boolean>;
  customerMembership: (
    where?: CustomerMembershipWhereInput
  ) => Promise<boolean>;
  emailReceipt: (where?: EmailReceiptWhereInput) => Promise<boolean>;
  externalShopifyIntegration: (
    where?: ExternalShopifyIntegrationWhereInput
  ) => Promise<boolean>;
  fitPic: (where?: FitPicWhereInput) => Promise<boolean>;
  fitPicReport: (where?: FitPicReportWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  interestedUser: (where?: InterestedUserWhereInput) => Promise<boolean>;
  label: (where?: LabelWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  package: (where?: PackageWhereInput) => Promise<boolean>;
  packageTransitEvent: (
    where?: PackageTransitEventWhereInput
  ) => Promise<boolean>;
  pauseRequest: (where?: PauseRequestWhereInput) => Promise<boolean>;
  paymentPlan: (where?: PaymentPlanWhereInput) => Promise<boolean>;
  physicalProduct: (where?: PhysicalProductWhereInput) => Promise<boolean>;
  physicalProductPrice: (
    where?: PhysicalProductPriceWhereInput
  ) => Promise<boolean>;
  physicalProductQualityReport: (
    where?: PhysicalProductQualityReportWhereInput
  ) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productFunction: (where?: ProductFunctionWhereInput) => Promise<boolean>;
  productMaterialCategory: (
    where?: ProductMaterialCategoryWhereInput
  ) => Promise<boolean>;
  productModel: (where?: ProductModelWhereInput) => Promise<boolean>;
  productNotification: (
    where?: ProductNotificationWhereInput
  ) => Promise<boolean>;
  productRequest: (where?: ProductRequestWhereInput) => Promise<boolean>;
  productSeason: (where?: ProductSeasonWhereInput) => Promise<boolean>;
  productTier: (where?: ProductTierWhereInput) => Promise<boolean>;
  productVariant: (where?: ProductVariantWhereInput) => Promise<boolean>;
  productVariantFeedback: (
    where?: ProductVariantFeedbackWhereInput
  ) => Promise<boolean>;
  productVariantFeedbackQuestion: (
    where?: ProductVariantFeedbackQuestionWhereInput
  ) => Promise<boolean>;
  productVariantPrice: (
    where?: ProductVariantPriceWhereInput
  ) => Promise<boolean>;
  productVariantWant: (
    where?: ProductVariantWantWhereInput
  ) => Promise<boolean>;
  pushNotificationReceipt: (
    where?: PushNotificationReceiptWhereInput
  ) => Promise<boolean>;
  recentlyViewedProduct: (
    where?: RecentlyViewedProductWhereInput
  ) => Promise<boolean>;
  reservation: (where?: ReservationWhereInput) => Promise<boolean>;
  reservationFeedback: (
    where?: ReservationFeedbackWhereInput
  ) => Promise<boolean>;
  reservationReceipt: (
    where?: ReservationReceiptWhereInput
  ) => Promise<boolean>;
  reservationReceiptItem: (
    where?: ReservationReceiptItemWhereInput
  ) => Promise<boolean>;
  season: (where?: SeasonWhereInput) => Promise<boolean>;
  shippingMethod: (where?: ShippingMethodWhereInput) => Promise<boolean>;
  shippingOption: (where?: ShippingOptionWhereInput) => Promise<boolean>;
  shopifyProductVariant: (
    where?: ShopifyProductVariantWhereInput
  ) => Promise<boolean>;
  size: (where?: SizeWhereInput) => Promise<boolean>;
  smsReceipt: (where?: SmsReceiptWhereInput) => Promise<boolean>;
  stylePreferences: (where?: StylePreferencesWhereInput) => Promise<boolean>;
  syncTiming: (where?: SyncTimingWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  topSize: (where?: TopSizeWhereInput) => Promise<boolean>;
  uTMData: (where?: UTMDataWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userPushNotification: (
    where?: UserPushNotificationWhereInput
  ) => Promise<boolean>;
  userPushNotificationInterest: (
    where?: UserPushNotificationInterestWhereInput
  ) => Promise<boolean>;
  warehouseLocation: (where?: WarehouseLocationWhereInput) => Promise<boolean>;
  warehouseLocationConstraint: (
    where?: WarehouseLocationConstraintWhereInput
  ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activeAdminUser: (
    where: ActiveAdminUserWhereUniqueInput
  ) => ActiveAdminUserNullablePromise;
  activeAdminUsers: (args?: {
    where?: ActiveAdminUserWhereInput;
    orderBy?: ActiveAdminUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActiveAdminUser>;
  activeAdminUsersConnection: (args?: {
    where?: ActiveAdminUserWhereInput;
    orderBy?: ActiveAdminUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActiveAdminUserConnectionPromise;
  adminActionLog: (
    where: AdminActionLogWhereUniqueInput
  ) => AdminActionLogNullablePromise;
  adminActionLogs: (args?: {
    where?: AdminActionLogWhereInput;
    orderBy?: AdminActionLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AdminActionLog>;
  adminActionLogsConnection: (args?: {
    where?: AdminActionLogWhereInput;
    orderBy?: AdminActionLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdminActionLogConnectionPromise;
  bagItem: (where: BagItemWhereUniqueInput) => BagItemNullablePromise;
  bagItems: (args?: {
    where?: BagItemWhereInput;
    orderBy?: BagItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BagItem>;
  bagItemsConnection: (args?: {
    where?: BagItemWhereInput;
    orderBy?: BagItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BagItemConnectionPromise;
  billingInfo: (
    where: BillingInfoWhereUniqueInput
  ) => BillingInfoNullablePromise;
  billingInfoes: (args?: {
    where?: BillingInfoWhereInput;
    orderBy?: BillingInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BillingInfo>;
  billingInfoesConnection: (args?: {
    where?: BillingInfoWhereInput;
    orderBy?: BillingInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BillingInfoConnectionPromise;
  bottomSize: (where: BottomSizeWhereUniqueInput) => BottomSizeNullablePromise;
  bottomSizes: (args?: {
    where?: BottomSizeWhereInput;
    orderBy?: BottomSizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BottomSize>;
  bottomSizesConnection: (args?: {
    where?: BottomSizeWhereInput;
    orderBy?: BottomSizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BottomSizeConnectionPromise;
  brand: (where: BrandWhereUniqueInput) => BrandNullablePromise;
  brands: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Brand>;
  brandsConnection: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BrandConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  collection: (where: CollectionWhereUniqueInput) => CollectionNullablePromise;
  collections: (args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Collection>;
  collectionsConnection: (args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CollectionConnectionPromise;
  color: (where: ColorWhereUniqueInput) => ColorNullablePromise;
  colors: (args?: {
    where?: ColorWhereInput;
    orderBy?: ColorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Color>;
  colorsConnection: (args?: {
    where?: ColorWhereInput;
    orderBy?: ColorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ColorConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  customerAdmissionsData: (
    where: CustomerAdmissionsDataWhereUniqueInput
  ) => CustomerAdmissionsDataNullablePromise;
  customerAdmissionsDatas: (args?: {
    where?: CustomerAdmissionsDataWhereInput;
    orderBy?: CustomerAdmissionsDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerAdmissionsData>;
  customerAdmissionsDatasConnection: (args?: {
    where?: CustomerAdmissionsDataWhereInput;
    orderBy?: CustomerAdmissionsDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerAdmissionsDataConnectionPromise;
  customerDetail: (
    where: CustomerDetailWhereUniqueInput
  ) => CustomerDetailNullablePromise;
  customerDetails: (args?: {
    where?: CustomerDetailWhereInput;
    orderBy?: CustomerDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerDetail>;
  customerDetailsConnection: (args?: {
    where?: CustomerDetailWhereInput;
    orderBy?: CustomerDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerDetailConnectionPromise;
  customerMembership: (
    where: CustomerMembershipWhereUniqueInput
  ) => CustomerMembershipNullablePromise;
  customerMemberships: (args?: {
    where?: CustomerMembershipWhereInput;
    orderBy?: CustomerMembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerMembership>;
  customerMembershipsConnection: (args?: {
    where?: CustomerMembershipWhereInput;
    orderBy?: CustomerMembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerMembershipConnectionPromise;
  emailReceipt: (
    where: EmailReceiptWhereUniqueInput
  ) => EmailReceiptNullablePromise;
  emailReceipts: (args?: {
    where?: EmailReceiptWhereInput;
    orderBy?: EmailReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EmailReceipt>;
  emailReceiptsConnection: (args?: {
    where?: EmailReceiptWhereInput;
    orderBy?: EmailReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmailReceiptConnectionPromise;
  externalShopifyIntegration: (
    where: ExternalShopifyIntegrationWhereUniqueInput
  ) => ExternalShopifyIntegrationNullablePromise;
  externalShopifyIntegrations: (args?: {
    where?: ExternalShopifyIntegrationWhereInput;
    orderBy?: ExternalShopifyIntegrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExternalShopifyIntegration>;
  externalShopifyIntegrationsConnection: (args?: {
    where?: ExternalShopifyIntegrationWhereInput;
    orderBy?: ExternalShopifyIntegrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExternalShopifyIntegrationConnectionPromise;
  fitPic: (where: FitPicWhereUniqueInput) => FitPicNullablePromise;
  fitPics: (args?: {
    where?: FitPicWhereInput;
    orderBy?: FitPicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FitPic>;
  fitPicsConnection: (args?: {
    where?: FitPicWhereInput;
    orderBy?: FitPicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FitPicConnectionPromise;
  fitPicReport: (
    where: FitPicReportWhereUniqueInput
  ) => FitPicReportNullablePromise;
  fitPicReports: (args?: {
    where?: FitPicReportWhereInput;
    orderBy?: FitPicReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FitPicReport>;
  fitPicReportsConnection: (args?: {
    where?: FitPicReportWhereInput;
    orderBy?: FitPicReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FitPicReportConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  interestedUser: (
    where: InterestedUserWhereUniqueInput
  ) => InterestedUserNullablePromise;
  interestedUsers: (args?: {
    where?: InterestedUserWhereInput;
    orderBy?: InterestedUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InterestedUser>;
  interestedUsersConnection: (args?: {
    where?: InterestedUserWhereInput;
    orderBy?: InterestedUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InterestedUserConnectionPromise;
  label: (where: LabelWhereUniqueInput) => LabelNullablePromise;
  labels: (args?: {
    where?: LabelWhereInput;
    orderBy?: LabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Label>;
  labelsConnection: (args?: {
    where?: LabelWhereInput;
    orderBy?: LabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LabelConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationNullablePromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  package: (where: PackageWhereUniqueInput) => PackageNullablePromise;
  packages: (args?: {
    where?: PackageWhereInput;
    orderBy?: PackageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Package>;
  packagesConnection: (args?: {
    where?: PackageWhereInput;
    orderBy?: PackageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PackageConnectionPromise;
  packageTransitEvent: (
    where: PackageTransitEventWhereUniqueInput
  ) => PackageTransitEventNullablePromise;
  packageTransitEvents: (args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PackageTransitEvent>;
  packageTransitEventsConnection: (args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PackageTransitEventConnectionPromise;
  pauseRequest: (
    where: PauseRequestWhereUniqueInput
  ) => PauseRequestNullablePromise;
  pauseRequests: (args?: {
    where?: PauseRequestWhereInput;
    orderBy?: PauseRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PauseRequest>;
  pauseRequestsConnection: (args?: {
    where?: PauseRequestWhereInput;
    orderBy?: PauseRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PauseRequestConnectionPromise;
  paymentPlan: (
    where: PaymentPlanWhereUniqueInput
  ) => PaymentPlanNullablePromise;
  paymentPlans: (args?: {
    where?: PaymentPlanWhereInput;
    orderBy?: PaymentPlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PaymentPlan>;
  paymentPlansConnection: (args?: {
    where?: PaymentPlanWhereInput;
    orderBy?: PaymentPlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentPlanConnectionPromise;
  physicalProduct: (
    where: PhysicalProductWhereUniqueInput
  ) => PhysicalProductNullablePromise;
  physicalProducts: (args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PhysicalProduct>;
  physicalProductsConnection: (args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhysicalProductConnectionPromise;
  physicalProductPrice: (
    where: PhysicalProductPriceWhereUniqueInput
  ) => PhysicalProductPriceNullablePromise;
  physicalProductPrices: (args?: {
    where?: PhysicalProductPriceWhereInput;
    orderBy?: PhysicalProductPriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PhysicalProductPrice>;
  physicalProductPricesConnection: (args?: {
    where?: PhysicalProductPriceWhereInput;
    orderBy?: PhysicalProductPriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhysicalProductPriceConnectionPromise;
  physicalProductQualityReport: (
    where: PhysicalProductQualityReportWhereUniqueInput
  ) => PhysicalProductQualityReportNullablePromise;
  physicalProductQualityReports: (args?: {
    where?: PhysicalProductQualityReportWhereInput;
    orderBy?: PhysicalProductQualityReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PhysicalProductQualityReport>;
  physicalProductQualityReportsConnection: (args?: {
    where?: PhysicalProductQualityReportWhereInput;
    orderBy?: PhysicalProductQualityReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhysicalProductQualityReportConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productFunction: (
    where: ProductFunctionWhereUniqueInput
  ) => ProductFunctionNullablePromise;
  productFunctions: (args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductFunction>;
  productFunctionsConnection: (args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductFunctionConnectionPromise;
  productMaterialCategory: (
    where: ProductMaterialCategoryWhereUniqueInput
  ) => ProductMaterialCategoryNullablePromise;
  productMaterialCategories: (args?: {
    where?: ProductMaterialCategoryWhereInput;
    orderBy?: ProductMaterialCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductMaterialCategory>;
  productMaterialCategoriesConnection: (args?: {
    where?: ProductMaterialCategoryWhereInput;
    orderBy?: ProductMaterialCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductMaterialCategoryConnectionPromise;
  productModel: (
    where: ProductModelWhereUniqueInput
  ) => ProductModelNullablePromise;
  productModels: (args?: {
    where?: ProductModelWhereInput;
    orderBy?: ProductModelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductModel>;
  productModelsConnection: (args?: {
    where?: ProductModelWhereInput;
    orderBy?: ProductModelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductModelConnectionPromise;
  productNotification: (
    where: ProductNotificationWhereUniqueInput
  ) => ProductNotificationNullablePromise;
  productNotifications: (args?: {
    where?: ProductNotificationWhereInput;
    orderBy?: ProductNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductNotification>;
  productNotificationsConnection: (args?: {
    where?: ProductNotificationWhereInput;
    orderBy?: ProductNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductNotificationConnectionPromise;
  productRequest: (
    where: ProductRequestWhereUniqueInput
  ) => ProductRequestNullablePromise;
  productRequests: (args?: {
    where?: ProductRequestWhereInput;
    orderBy?: ProductRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductRequest>;
  productRequestsConnection: (args?: {
    where?: ProductRequestWhereInput;
    orderBy?: ProductRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductRequestConnectionPromise;
  productSeason: (
    where: ProductSeasonWhereUniqueInput
  ) => ProductSeasonNullablePromise;
  productSeasons: (args?: {
    where?: ProductSeasonWhereInput;
    orderBy?: ProductSeasonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductSeason>;
  productSeasonsConnection: (args?: {
    where?: ProductSeasonWhereInput;
    orderBy?: ProductSeasonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductSeasonConnectionPromise;
  productTier: (
    where: ProductTierWhereUniqueInput
  ) => ProductTierNullablePromise;
  productTiers: (args?: {
    where?: ProductTierWhereInput;
    orderBy?: ProductTierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductTier>;
  productTiersConnection: (args?: {
    where?: ProductTierWhereInput;
    orderBy?: ProductTierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductTierConnectionPromise;
  productVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantNullablePromise;
  productVariants: (args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductVariant>;
  productVariantsConnection: (args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductVariantConnectionPromise;
  productVariantFeedback: (
    where: ProductVariantFeedbackWhereUniqueInput
  ) => ProductVariantFeedbackNullablePromise;
  productVariantFeedbacks: (args?: {
    where?: ProductVariantFeedbackWhereInput;
    orderBy?: ProductVariantFeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductVariantFeedback>;
  productVariantFeedbacksConnection: (args?: {
    where?: ProductVariantFeedbackWhereInput;
    orderBy?: ProductVariantFeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductVariantFeedbackConnectionPromise;
  productVariantFeedbackQuestion: (
    where: ProductVariantFeedbackQuestionWhereUniqueInput
  ) => ProductVariantFeedbackQuestionNullablePromise;
  productVariantFeedbackQuestions: (args?: {
    where?: ProductVariantFeedbackQuestionWhereInput;
    orderBy?: ProductVariantFeedbackQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductVariantFeedbackQuestion>;
  productVariantFeedbackQuestionsConnection: (args?: {
    where?: ProductVariantFeedbackQuestionWhereInput;
    orderBy?: ProductVariantFeedbackQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductVariantFeedbackQuestionConnectionPromise;
  productVariantPrice: (
    where: ProductVariantPriceWhereUniqueInput
  ) => ProductVariantPriceNullablePromise;
  productVariantPrices: (args?: {
    where?: ProductVariantPriceWhereInput;
    orderBy?: ProductVariantPriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductVariantPrice>;
  productVariantPricesConnection: (args?: {
    where?: ProductVariantPriceWhereInput;
    orderBy?: ProductVariantPriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductVariantPriceConnectionPromise;
  productVariantWant: (
    where: ProductVariantWantWhereUniqueInput
  ) => ProductVariantWantNullablePromise;
  productVariantWants: (args?: {
    where?: ProductVariantWantWhereInput;
    orderBy?: ProductVariantWantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductVariantWant>;
  productVariantWantsConnection: (args?: {
    where?: ProductVariantWantWhereInput;
    orderBy?: ProductVariantWantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductVariantWantConnectionPromise;
  pushNotificationReceipt: (
    where: PushNotificationReceiptWhereUniqueInput
  ) => PushNotificationReceiptNullablePromise;
  pushNotificationReceipts: (args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PushNotificationReceipt>;
  pushNotificationReceiptsConnection: (args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PushNotificationReceiptConnectionPromise;
  recentlyViewedProduct: (
    where: RecentlyViewedProductWhereUniqueInput
  ) => RecentlyViewedProductNullablePromise;
  recentlyViewedProducts: (args?: {
    where?: RecentlyViewedProductWhereInput;
    orderBy?: RecentlyViewedProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RecentlyViewedProduct>;
  recentlyViewedProductsConnection: (args?: {
    where?: RecentlyViewedProductWhereInput;
    orderBy?: RecentlyViewedProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RecentlyViewedProductConnectionPromise;
  reservation: (
    where: ReservationWhereUniqueInput
  ) => ReservationNullablePromise;
  reservations: (args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reservation>;
  reservationsConnection: (args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReservationConnectionPromise;
  reservationFeedback: (
    where: ReservationFeedbackWhereUniqueInput
  ) => ReservationFeedbackNullablePromise;
  reservationFeedbacks: (args?: {
    where?: ReservationFeedbackWhereInput;
    orderBy?: ReservationFeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReservationFeedback>;
  reservationFeedbacksConnection: (args?: {
    where?: ReservationFeedbackWhereInput;
    orderBy?: ReservationFeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReservationFeedbackConnectionPromise;
  reservationReceipt: (
    where: ReservationReceiptWhereUniqueInput
  ) => ReservationReceiptNullablePromise;
  reservationReceipts: (args?: {
    where?: ReservationReceiptWhereInput;
    orderBy?: ReservationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReservationReceipt>;
  reservationReceiptsConnection: (args?: {
    where?: ReservationReceiptWhereInput;
    orderBy?: ReservationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReservationReceiptConnectionPromise;
  reservationReceiptItem: (
    where: ReservationReceiptItemWhereUniqueInput
  ) => ReservationReceiptItemNullablePromise;
  reservationReceiptItems: (args?: {
    where?: ReservationReceiptItemWhereInput;
    orderBy?: ReservationReceiptItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReservationReceiptItem>;
  reservationReceiptItemsConnection: (args?: {
    where?: ReservationReceiptItemWhereInput;
    orderBy?: ReservationReceiptItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReservationReceiptItemConnectionPromise;
  season: (where: SeasonWhereUniqueInput) => SeasonNullablePromise;
  seasons: (args?: {
    where?: SeasonWhereInput;
    orderBy?: SeasonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Season>;
  seasonsConnection: (args?: {
    where?: SeasonWhereInput;
    orderBy?: SeasonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SeasonConnectionPromise;
  shippingMethod: (
    where: ShippingMethodWhereUniqueInput
  ) => ShippingMethodNullablePromise;
  shippingMethods: (args?: {
    where?: ShippingMethodWhereInput;
    orderBy?: ShippingMethodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShippingMethod>;
  shippingMethodsConnection: (args?: {
    where?: ShippingMethodWhereInput;
    orderBy?: ShippingMethodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShippingMethodConnectionPromise;
  shippingOption: (
    where: ShippingOptionWhereUniqueInput
  ) => ShippingOptionNullablePromise;
  shippingOptions: (args?: {
    where?: ShippingOptionWhereInput;
    orderBy?: ShippingOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShippingOption>;
  shippingOptionsConnection: (args?: {
    where?: ShippingOptionWhereInput;
    orderBy?: ShippingOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShippingOptionConnectionPromise;
  shopifyProductVariant: (
    where: ShopifyProductVariantWhereUniqueInput
  ) => ShopifyProductVariantNullablePromise;
  shopifyProductVariants: (args?: {
    where?: ShopifyProductVariantWhereInput;
    orderBy?: ShopifyProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShopifyProductVariant>;
  shopifyProductVariantsConnection: (args?: {
    where?: ShopifyProductVariantWhereInput;
    orderBy?: ShopifyProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShopifyProductVariantConnectionPromise;
  size: (where: SizeWhereUniqueInput) => SizeNullablePromise;
  sizes: (args?: {
    where?: SizeWhereInput;
    orderBy?: SizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Size>;
  sizesConnection: (args?: {
    where?: SizeWhereInput;
    orderBy?: SizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SizeConnectionPromise;
  smsReceipt: (where: SmsReceiptWhereUniqueInput) => SmsReceiptNullablePromise;
  smsReceipts: (args?: {
    where?: SmsReceiptWhereInput;
    orderBy?: SmsReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SmsReceipt>;
  smsReceiptsConnection: (args?: {
    where?: SmsReceiptWhereInput;
    orderBy?: SmsReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SmsReceiptConnectionPromise;
  stylePreferences: (
    where: StylePreferencesWhereUniqueInput
  ) => StylePreferencesNullablePromise;
  stylePreferenceses: (args?: {
    where?: StylePreferencesWhereInput;
    orderBy?: StylePreferencesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StylePreferences>;
  stylePreferencesesConnection: (args?: {
    where?: StylePreferencesWhereInput;
    orderBy?: StylePreferencesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StylePreferencesConnectionPromise;
  syncTiming: (where: SyncTimingWhereUniqueInput) => SyncTimingNullablePromise;
  syncTimings: (args?: {
    where?: SyncTimingWhereInput;
    orderBy?: SyncTimingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SyncTiming>;
  syncTimingsConnection: (args?: {
    where?: SyncTimingWhereInput;
    orderBy?: SyncTimingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SyncTimingConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  topSize: (where: TopSizeWhereUniqueInput) => TopSizeNullablePromise;
  topSizes: (args?: {
    where?: TopSizeWhereInput;
    orderBy?: TopSizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TopSize>;
  topSizesConnection: (args?: {
    where?: TopSizeWhereInput;
    orderBy?: TopSizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TopSizeConnectionPromise;
  uTMData: (where: UTMDataWhereUniqueInput) => UTMDataNullablePromise;
  uTMDatas: (args?: {
    where?: UTMDataWhereInput;
    orderBy?: UTMDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UTMData>;
  uTMDatasConnection: (args?: {
    where?: UTMDataWhereInput;
    orderBy?: UTMDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UTMDataConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userPushNotification: (
    where: UserPushNotificationWhereUniqueInput
  ) => UserPushNotificationNullablePromise;
  userPushNotifications: (args?: {
    where?: UserPushNotificationWhereInput;
    orderBy?: UserPushNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserPushNotification>;
  userPushNotificationsConnection: (args?: {
    where?: UserPushNotificationWhereInput;
    orderBy?: UserPushNotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserPushNotificationConnectionPromise;
  userPushNotificationInterest: (
    where: UserPushNotificationInterestWhereUniqueInput
  ) => UserPushNotificationInterestNullablePromise;
  userPushNotificationInterests: (args?: {
    where?: UserPushNotificationInterestWhereInput;
    orderBy?: UserPushNotificationInterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserPushNotificationInterest>;
  userPushNotificationInterestsConnection: (args?: {
    where?: UserPushNotificationInterestWhereInput;
    orderBy?: UserPushNotificationInterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserPushNotificationInterestConnectionPromise;
  warehouseLocation: (
    where: WarehouseLocationWhereUniqueInput
  ) => WarehouseLocationNullablePromise;
  warehouseLocations: (args?: {
    where?: WarehouseLocationWhereInput;
    orderBy?: WarehouseLocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WarehouseLocation>;
  warehouseLocationsConnection: (args?: {
    where?: WarehouseLocationWhereInput;
    orderBy?: WarehouseLocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WarehouseLocationConnectionPromise;
  warehouseLocationConstraint: (
    where: WarehouseLocationConstraintWhereUniqueInput
  ) => WarehouseLocationConstraintNullablePromise;
  warehouseLocationConstraints: (args?: {
    where?: WarehouseLocationConstraintWhereInput;
    orderBy?: WarehouseLocationConstraintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WarehouseLocationConstraint>;
  warehouseLocationConstraintsConnection: (args?: {
    where?: WarehouseLocationConstraintWhereInput;
    orderBy?: WarehouseLocationConstraintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WarehouseLocationConstraintConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActiveAdminUser: (
    data: ActiveAdminUserCreateInput
  ) => ActiveAdminUserPromise;
  updateActiveAdminUser: (args: {
    data: ActiveAdminUserUpdateInput;
    where: ActiveAdminUserWhereUniqueInput;
  }) => ActiveAdminUserPromise;
  upsertActiveAdminUser: (args: {
    where: ActiveAdminUserWhereUniqueInput;
    create: ActiveAdminUserCreateInput;
    update: ActiveAdminUserUpdateInput;
  }) => ActiveAdminUserPromise;
  deleteActiveAdminUser: (
    where: ActiveAdminUserWhereUniqueInput
  ) => ActiveAdminUserPromise;
  deleteManyActiveAdminUsers: (
    where?: ActiveAdminUserWhereInput
  ) => BatchPayloadPromise;
  createAdminActionLog: (
    data: AdminActionLogCreateInput
  ) => AdminActionLogPromise;
  updateAdminActionLog: (args: {
    data: AdminActionLogUpdateInput;
    where: AdminActionLogWhereUniqueInput;
  }) => AdminActionLogPromise;
  updateManyAdminActionLogs: (args: {
    data: AdminActionLogUpdateManyMutationInput;
    where?: AdminActionLogWhereInput;
  }) => BatchPayloadPromise;
  upsertAdminActionLog: (args: {
    where: AdminActionLogWhereUniqueInput;
    create: AdminActionLogCreateInput;
    update: AdminActionLogUpdateInput;
  }) => AdminActionLogPromise;
  deleteAdminActionLog: (
    where: AdminActionLogWhereUniqueInput
  ) => AdminActionLogPromise;
  deleteManyAdminActionLogs: (
    where?: AdminActionLogWhereInput
  ) => BatchPayloadPromise;
  createBagItem: (data: BagItemCreateInput) => BagItemPromise;
  updateBagItem: (args: {
    data: BagItemUpdateInput;
    where: BagItemWhereUniqueInput;
  }) => BagItemPromise;
  updateManyBagItems: (args: {
    data: BagItemUpdateManyMutationInput;
    where?: BagItemWhereInput;
  }) => BatchPayloadPromise;
  upsertBagItem: (args: {
    where: BagItemWhereUniqueInput;
    create: BagItemCreateInput;
    update: BagItemUpdateInput;
  }) => BagItemPromise;
  deleteBagItem: (where: BagItemWhereUniqueInput) => BagItemPromise;
  deleteManyBagItems: (where?: BagItemWhereInput) => BatchPayloadPromise;
  createBillingInfo: (data: BillingInfoCreateInput) => BillingInfoPromise;
  updateBillingInfo: (args: {
    data: BillingInfoUpdateInput;
    where: BillingInfoWhereUniqueInput;
  }) => BillingInfoPromise;
  updateManyBillingInfoes: (args: {
    data: BillingInfoUpdateManyMutationInput;
    where?: BillingInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertBillingInfo: (args: {
    where: BillingInfoWhereUniqueInput;
    create: BillingInfoCreateInput;
    update: BillingInfoUpdateInput;
  }) => BillingInfoPromise;
  deleteBillingInfo: (where: BillingInfoWhereUniqueInput) => BillingInfoPromise;
  deleteManyBillingInfoes: (
    where?: BillingInfoWhereInput
  ) => BatchPayloadPromise;
  createBottomSize: (data: BottomSizeCreateInput) => BottomSizePromise;
  updateBottomSize: (args: {
    data: BottomSizeUpdateInput;
    where: BottomSizeWhereUniqueInput;
  }) => BottomSizePromise;
  updateManyBottomSizes: (args: {
    data: BottomSizeUpdateManyMutationInput;
    where?: BottomSizeWhereInput;
  }) => BatchPayloadPromise;
  upsertBottomSize: (args: {
    where: BottomSizeWhereUniqueInput;
    create: BottomSizeCreateInput;
    update: BottomSizeUpdateInput;
  }) => BottomSizePromise;
  deleteBottomSize: (where: BottomSizeWhereUniqueInput) => BottomSizePromise;
  deleteManyBottomSizes: (where?: BottomSizeWhereInput) => BatchPayloadPromise;
  createBrand: (data: BrandCreateInput) => BrandPromise;
  updateBrand: (args: {
    data: BrandUpdateInput;
    where: BrandWhereUniqueInput;
  }) => BrandPromise;
  updateManyBrands: (args: {
    data: BrandUpdateManyMutationInput;
    where?: BrandWhereInput;
  }) => BatchPayloadPromise;
  upsertBrand: (args: {
    where: BrandWhereUniqueInput;
    create: BrandCreateInput;
    update: BrandUpdateInput;
  }) => BrandPromise;
  deleteBrand: (where: BrandWhereUniqueInput) => BrandPromise;
  deleteManyBrands: (where?: BrandWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createCollection: (data: CollectionCreateInput) => CollectionPromise;
  updateCollection: (args: {
    data: CollectionUpdateInput;
    where: CollectionWhereUniqueInput;
  }) => CollectionPromise;
  updateManyCollections: (args: {
    data: CollectionUpdateManyMutationInput;
    where?: CollectionWhereInput;
  }) => BatchPayloadPromise;
  upsertCollection: (args: {
    where: CollectionWhereUniqueInput;
    create: CollectionCreateInput;
    update: CollectionUpdateInput;
  }) => CollectionPromise;
  deleteCollection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  deleteManyCollections: (where?: CollectionWhereInput) => BatchPayloadPromise;
  createColor: (data: ColorCreateInput) => ColorPromise;
  updateColor: (args: {
    data: ColorUpdateInput;
    where: ColorWhereUniqueInput;
  }) => ColorPromise;
  updateManyColors: (args: {
    data: ColorUpdateManyMutationInput;
    where?: ColorWhereInput;
  }) => BatchPayloadPromise;
  upsertColor: (args: {
    where: ColorWhereUniqueInput;
    create: ColorCreateInput;
    update: ColorUpdateInput;
  }) => ColorPromise;
  deleteColor: (where: ColorWhereUniqueInput) => ColorPromise;
  deleteManyColors: (where?: ColorWhereInput) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createCustomerAdmissionsData: (
    data: CustomerAdmissionsDataCreateInput
  ) => CustomerAdmissionsDataPromise;
  updateCustomerAdmissionsData: (args: {
    data: CustomerAdmissionsDataUpdateInput;
    where: CustomerAdmissionsDataWhereUniqueInput;
  }) => CustomerAdmissionsDataPromise;
  updateManyCustomerAdmissionsDatas: (args: {
    data: CustomerAdmissionsDataUpdateManyMutationInput;
    where?: CustomerAdmissionsDataWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerAdmissionsData: (args: {
    where: CustomerAdmissionsDataWhereUniqueInput;
    create: CustomerAdmissionsDataCreateInput;
    update: CustomerAdmissionsDataUpdateInput;
  }) => CustomerAdmissionsDataPromise;
  deleteCustomerAdmissionsData: (
    where: CustomerAdmissionsDataWhereUniqueInput
  ) => CustomerAdmissionsDataPromise;
  deleteManyCustomerAdmissionsDatas: (
    where?: CustomerAdmissionsDataWhereInput
  ) => BatchPayloadPromise;
  createCustomerDetail: (
    data: CustomerDetailCreateInput
  ) => CustomerDetailPromise;
  updateCustomerDetail: (args: {
    data: CustomerDetailUpdateInput;
    where: CustomerDetailWhereUniqueInput;
  }) => CustomerDetailPromise;
  updateManyCustomerDetails: (args: {
    data: CustomerDetailUpdateManyMutationInput;
    where?: CustomerDetailWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerDetail: (args: {
    where: CustomerDetailWhereUniqueInput;
    create: CustomerDetailCreateInput;
    update: CustomerDetailUpdateInput;
  }) => CustomerDetailPromise;
  deleteCustomerDetail: (
    where: CustomerDetailWhereUniqueInput
  ) => CustomerDetailPromise;
  deleteManyCustomerDetails: (
    where?: CustomerDetailWhereInput
  ) => BatchPayloadPromise;
  createCustomerMembership: (
    data: CustomerMembershipCreateInput
  ) => CustomerMembershipPromise;
  updateCustomerMembership: (args: {
    data: CustomerMembershipUpdateInput;
    where: CustomerMembershipWhereUniqueInput;
  }) => CustomerMembershipPromise;
  updateManyCustomerMemberships: (args: {
    data: CustomerMembershipUpdateManyMutationInput;
    where?: CustomerMembershipWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerMembership: (args: {
    where: CustomerMembershipWhereUniqueInput;
    create: CustomerMembershipCreateInput;
    update: CustomerMembershipUpdateInput;
  }) => CustomerMembershipPromise;
  deleteCustomerMembership: (
    where: CustomerMembershipWhereUniqueInput
  ) => CustomerMembershipPromise;
  deleteManyCustomerMemberships: (
    where?: CustomerMembershipWhereInput
  ) => BatchPayloadPromise;
  createEmailReceipt: (data: EmailReceiptCreateInput) => EmailReceiptPromise;
  updateEmailReceipt: (args: {
    data: EmailReceiptUpdateInput;
    where: EmailReceiptWhereUniqueInput;
  }) => EmailReceiptPromise;
  updateManyEmailReceipts: (args: {
    data: EmailReceiptUpdateManyMutationInput;
    where?: EmailReceiptWhereInput;
  }) => BatchPayloadPromise;
  upsertEmailReceipt: (args: {
    where: EmailReceiptWhereUniqueInput;
    create: EmailReceiptCreateInput;
    update: EmailReceiptUpdateInput;
  }) => EmailReceiptPromise;
  deleteEmailReceipt: (
    where: EmailReceiptWhereUniqueInput
  ) => EmailReceiptPromise;
  deleteManyEmailReceipts: (
    where?: EmailReceiptWhereInput
  ) => BatchPayloadPromise;
  createExternalShopifyIntegration: (
    data: ExternalShopifyIntegrationCreateInput
  ) => ExternalShopifyIntegrationPromise;
  updateExternalShopifyIntegration: (args: {
    data: ExternalShopifyIntegrationUpdateInput;
    where: ExternalShopifyIntegrationWhereUniqueInput;
  }) => ExternalShopifyIntegrationPromise;
  updateManyExternalShopifyIntegrations: (args: {
    data: ExternalShopifyIntegrationUpdateManyMutationInput;
    where?: ExternalShopifyIntegrationWhereInput;
  }) => BatchPayloadPromise;
  upsertExternalShopifyIntegration: (args: {
    where: ExternalShopifyIntegrationWhereUniqueInput;
    create: ExternalShopifyIntegrationCreateInput;
    update: ExternalShopifyIntegrationUpdateInput;
  }) => ExternalShopifyIntegrationPromise;
  deleteExternalShopifyIntegration: (
    where: ExternalShopifyIntegrationWhereUniqueInput
  ) => ExternalShopifyIntegrationPromise;
  deleteManyExternalShopifyIntegrations: (
    where?: ExternalShopifyIntegrationWhereInput
  ) => BatchPayloadPromise;
  createFitPic: (data: FitPicCreateInput) => FitPicPromise;
  updateFitPic: (args: {
    data: FitPicUpdateInput;
    where: FitPicWhereUniqueInput;
  }) => FitPicPromise;
  updateManyFitPics: (args: {
    data: FitPicUpdateManyMutationInput;
    where?: FitPicWhereInput;
  }) => BatchPayloadPromise;
  upsertFitPic: (args: {
    where: FitPicWhereUniqueInput;
    create: FitPicCreateInput;
    update: FitPicUpdateInput;
  }) => FitPicPromise;
  deleteFitPic: (where: FitPicWhereUniqueInput) => FitPicPromise;
  deleteManyFitPics: (where?: FitPicWhereInput) => BatchPayloadPromise;
  createFitPicReport: (data: FitPicReportCreateInput) => FitPicReportPromise;
  updateFitPicReport: (args: {
    data: FitPicReportUpdateInput;
    where: FitPicReportWhereUniqueInput;
  }) => FitPicReportPromise;
  updateManyFitPicReports: (args: {
    data: FitPicReportUpdateManyMutationInput;
    where?: FitPicReportWhereInput;
  }) => BatchPayloadPromise;
  upsertFitPicReport: (args: {
    where: FitPicReportWhereUniqueInput;
    create: FitPicReportCreateInput;
    update: FitPicReportUpdateInput;
  }) => FitPicReportPromise;
  deleteFitPicReport: (
    where: FitPicReportWhereUniqueInput
  ) => FitPicReportPromise;
  deleteManyFitPicReports: (
    where?: FitPicReportWhereInput
  ) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createInterestedUser: (
    data: InterestedUserCreateInput
  ) => InterestedUserPromise;
  updateInterestedUser: (args: {
    data: InterestedUserUpdateInput;
    where: InterestedUserWhereUniqueInput;
  }) => InterestedUserPromise;
  updateManyInterestedUsers: (args: {
    data: InterestedUserUpdateManyMutationInput;
    where?: InterestedUserWhereInput;
  }) => BatchPayloadPromise;
  upsertInterestedUser: (args: {
    where: InterestedUserWhereUniqueInput;
    create: InterestedUserCreateInput;
    update: InterestedUserUpdateInput;
  }) => InterestedUserPromise;
  deleteInterestedUser: (
    where: InterestedUserWhereUniqueInput
  ) => InterestedUserPromise;
  deleteManyInterestedUsers: (
    where?: InterestedUserWhereInput
  ) => BatchPayloadPromise;
  createLabel: (data: LabelCreateInput) => LabelPromise;
  updateLabel: (args: {
    data: LabelUpdateInput;
    where: LabelWhereUniqueInput;
  }) => LabelPromise;
  updateManyLabels: (args: {
    data: LabelUpdateManyMutationInput;
    where?: LabelWhereInput;
  }) => BatchPayloadPromise;
  upsertLabel: (args: {
    where: LabelWhereUniqueInput;
    create: LabelCreateInput;
    update: LabelUpdateInput;
  }) => LabelPromise;
  deleteLabel: (where: LabelWhereUniqueInput) => LabelPromise;
  deleteManyLabels: (where?: LabelWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createPackage: (data: PackageCreateInput) => PackagePromise;
  updatePackage: (args: {
    data: PackageUpdateInput;
    where: PackageWhereUniqueInput;
  }) => PackagePromise;
  updateManyPackages: (args: {
    data: PackageUpdateManyMutationInput;
    where?: PackageWhereInput;
  }) => BatchPayloadPromise;
  upsertPackage: (args: {
    where: PackageWhereUniqueInput;
    create: PackageCreateInput;
    update: PackageUpdateInput;
  }) => PackagePromise;
  deletePackage: (where: PackageWhereUniqueInput) => PackagePromise;
  deleteManyPackages: (where?: PackageWhereInput) => BatchPayloadPromise;
  createPackageTransitEvent: (
    data: PackageTransitEventCreateInput
  ) => PackageTransitEventPromise;
  updatePackageTransitEvent: (args: {
    data: PackageTransitEventUpdateInput;
    where: PackageTransitEventWhereUniqueInput;
  }) => PackageTransitEventPromise;
  updateManyPackageTransitEvents: (args: {
    data: PackageTransitEventUpdateManyMutationInput;
    where?: PackageTransitEventWhereInput;
  }) => BatchPayloadPromise;
  upsertPackageTransitEvent: (args: {
    where: PackageTransitEventWhereUniqueInput;
    create: PackageTransitEventCreateInput;
    update: PackageTransitEventUpdateInput;
  }) => PackageTransitEventPromise;
  deletePackageTransitEvent: (
    where: PackageTransitEventWhereUniqueInput
  ) => PackageTransitEventPromise;
  deleteManyPackageTransitEvents: (
    where?: PackageTransitEventWhereInput
  ) => BatchPayloadPromise;
  createPauseRequest: (data: PauseRequestCreateInput) => PauseRequestPromise;
  updatePauseRequest: (args: {
    data: PauseRequestUpdateInput;
    where: PauseRequestWhereUniqueInput;
  }) => PauseRequestPromise;
  updateManyPauseRequests: (args: {
    data: PauseRequestUpdateManyMutationInput;
    where?: PauseRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertPauseRequest: (args: {
    where: PauseRequestWhereUniqueInput;
    create: PauseRequestCreateInput;
    update: PauseRequestUpdateInput;
  }) => PauseRequestPromise;
  deletePauseRequest: (
    where: PauseRequestWhereUniqueInput
  ) => PauseRequestPromise;
  deleteManyPauseRequests: (
    where?: PauseRequestWhereInput
  ) => BatchPayloadPromise;
  createPaymentPlan: (data: PaymentPlanCreateInput) => PaymentPlanPromise;
  updatePaymentPlan: (args: {
    data: PaymentPlanUpdateInput;
    where: PaymentPlanWhereUniqueInput;
  }) => PaymentPlanPromise;
  updateManyPaymentPlans: (args: {
    data: PaymentPlanUpdateManyMutationInput;
    where?: PaymentPlanWhereInput;
  }) => BatchPayloadPromise;
  upsertPaymentPlan: (args: {
    where: PaymentPlanWhereUniqueInput;
    create: PaymentPlanCreateInput;
    update: PaymentPlanUpdateInput;
  }) => PaymentPlanPromise;
  deletePaymentPlan: (where: PaymentPlanWhereUniqueInput) => PaymentPlanPromise;
  deleteManyPaymentPlans: (
    where?: PaymentPlanWhereInput
  ) => BatchPayloadPromise;
  createPhysicalProduct: (
    data: PhysicalProductCreateInput
  ) => PhysicalProductPromise;
  updatePhysicalProduct: (args: {
    data: PhysicalProductUpdateInput;
    where: PhysicalProductWhereUniqueInput;
  }) => PhysicalProductPromise;
  updateManyPhysicalProducts: (args: {
    data: PhysicalProductUpdateManyMutationInput;
    where?: PhysicalProductWhereInput;
  }) => BatchPayloadPromise;
  upsertPhysicalProduct: (args: {
    where: PhysicalProductWhereUniqueInput;
    create: PhysicalProductCreateInput;
    update: PhysicalProductUpdateInput;
  }) => PhysicalProductPromise;
  deletePhysicalProduct: (
    where: PhysicalProductWhereUniqueInput
  ) => PhysicalProductPromise;
  deleteManyPhysicalProducts: (
    where?: PhysicalProductWhereInput
  ) => BatchPayloadPromise;
  createPhysicalProductPrice: (
    data: PhysicalProductPriceCreateInput
  ) => PhysicalProductPricePromise;
  updatePhysicalProductPrice: (args: {
    data: PhysicalProductPriceUpdateInput;
    where: PhysicalProductPriceWhereUniqueInput;
  }) => PhysicalProductPricePromise;
  updateManyPhysicalProductPrices: (args: {
    data: PhysicalProductPriceUpdateManyMutationInput;
    where?: PhysicalProductPriceWhereInput;
  }) => BatchPayloadPromise;
  upsertPhysicalProductPrice: (args: {
    where: PhysicalProductPriceWhereUniqueInput;
    create: PhysicalProductPriceCreateInput;
    update: PhysicalProductPriceUpdateInput;
  }) => PhysicalProductPricePromise;
  deletePhysicalProductPrice: (
    where: PhysicalProductPriceWhereUniqueInput
  ) => PhysicalProductPricePromise;
  deleteManyPhysicalProductPrices: (
    where?: PhysicalProductPriceWhereInput
  ) => BatchPayloadPromise;
  createPhysicalProductQualityReport: (
    data: PhysicalProductQualityReportCreateInput
  ) => PhysicalProductQualityReportPromise;
  updatePhysicalProductQualityReport: (args: {
    data: PhysicalProductQualityReportUpdateInput;
    where: PhysicalProductQualityReportWhereUniqueInput;
  }) => PhysicalProductQualityReportPromise;
  updateManyPhysicalProductQualityReports: (args: {
    data: PhysicalProductQualityReportUpdateManyMutationInput;
    where?: PhysicalProductQualityReportWhereInput;
  }) => BatchPayloadPromise;
  upsertPhysicalProductQualityReport: (args: {
    where: PhysicalProductQualityReportWhereUniqueInput;
    create: PhysicalProductQualityReportCreateInput;
    update: PhysicalProductQualityReportUpdateInput;
  }) => PhysicalProductQualityReportPromise;
  deletePhysicalProductQualityReport: (
    where: PhysicalProductQualityReportWhereUniqueInput
  ) => PhysicalProductQualityReportPromise;
  deleteManyPhysicalProductQualityReports: (
    where?: PhysicalProductQualityReportWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductFunction: (
    data: ProductFunctionCreateInput
  ) => ProductFunctionPromise;
  updateProductFunction: (args: {
    data: ProductFunctionUpdateInput;
    where: ProductFunctionWhereUniqueInput;
  }) => ProductFunctionPromise;
  updateManyProductFunctions: (args: {
    data: ProductFunctionUpdateManyMutationInput;
    where?: ProductFunctionWhereInput;
  }) => BatchPayloadPromise;
  upsertProductFunction: (args: {
    where: ProductFunctionWhereUniqueInput;
    create: ProductFunctionCreateInput;
    update: ProductFunctionUpdateInput;
  }) => ProductFunctionPromise;
  deleteProductFunction: (
    where: ProductFunctionWhereUniqueInput
  ) => ProductFunctionPromise;
  deleteManyProductFunctions: (
    where?: ProductFunctionWhereInput
  ) => BatchPayloadPromise;
  createProductMaterialCategory: (
    data: ProductMaterialCategoryCreateInput
  ) => ProductMaterialCategoryPromise;
  updateProductMaterialCategory: (args: {
    data: ProductMaterialCategoryUpdateInput;
    where: ProductMaterialCategoryWhereUniqueInput;
  }) => ProductMaterialCategoryPromise;
  updateManyProductMaterialCategories: (args: {
    data: ProductMaterialCategoryUpdateManyMutationInput;
    where?: ProductMaterialCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertProductMaterialCategory: (args: {
    where: ProductMaterialCategoryWhereUniqueInput;
    create: ProductMaterialCategoryCreateInput;
    update: ProductMaterialCategoryUpdateInput;
  }) => ProductMaterialCategoryPromise;
  deleteProductMaterialCategory: (
    where: ProductMaterialCategoryWhereUniqueInput
  ) => ProductMaterialCategoryPromise;
  deleteManyProductMaterialCategories: (
    where?: ProductMaterialCategoryWhereInput
  ) => BatchPayloadPromise;
  createProductModel: (data: ProductModelCreateInput) => ProductModelPromise;
  updateProductModel: (args: {
    data: ProductModelUpdateInput;
    where: ProductModelWhereUniqueInput;
  }) => ProductModelPromise;
  updateManyProductModels: (args: {
    data: ProductModelUpdateManyMutationInput;
    where?: ProductModelWhereInput;
  }) => BatchPayloadPromise;
  upsertProductModel: (args: {
    where: ProductModelWhereUniqueInput;
    create: ProductModelCreateInput;
    update: ProductModelUpdateInput;
  }) => ProductModelPromise;
  deleteProductModel: (
    where: ProductModelWhereUniqueInput
  ) => ProductModelPromise;
  deleteManyProductModels: (
    where?: ProductModelWhereInput
  ) => BatchPayloadPromise;
  createProductNotification: (
    data: ProductNotificationCreateInput
  ) => ProductNotificationPromise;
  updateProductNotification: (args: {
    data: ProductNotificationUpdateInput;
    where: ProductNotificationWhereUniqueInput;
  }) => ProductNotificationPromise;
  updateManyProductNotifications: (args: {
    data: ProductNotificationUpdateManyMutationInput;
    where?: ProductNotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertProductNotification: (args: {
    where: ProductNotificationWhereUniqueInput;
    create: ProductNotificationCreateInput;
    update: ProductNotificationUpdateInput;
  }) => ProductNotificationPromise;
  deleteProductNotification: (
    where: ProductNotificationWhereUniqueInput
  ) => ProductNotificationPromise;
  deleteManyProductNotifications: (
    where?: ProductNotificationWhereInput
  ) => BatchPayloadPromise;
  createProductRequest: (
    data: ProductRequestCreateInput
  ) => ProductRequestPromise;
  updateProductRequest: (args: {
    data: ProductRequestUpdateInput;
    where: ProductRequestWhereUniqueInput;
  }) => ProductRequestPromise;
  updateManyProductRequests: (args: {
    data: ProductRequestUpdateManyMutationInput;
    where?: ProductRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertProductRequest: (args: {
    where: ProductRequestWhereUniqueInput;
    create: ProductRequestCreateInput;
    update: ProductRequestUpdateInput;
  }) => ProductRequestPromise;
  deleteProductRequest: (
    where: ProductRequestWhereUniqueInput
  ) => ProductRequestPromise;
  deleteManyProductRequests: (
    where?: ProductRequestWhereInput
  ) => BatchPayloadPromise;
  createProductSeason: (data: ProductSeasonCreateInput) => ProductSeasonPromise;
  updateProductSeason: (args: {
    data: ProductSeasonUpdateInput;
    where: ProductSeasonWhereUniqueInput;
  }) => ProductSeasonPromise;
  updateManyProductSeasons: (args: {
    data: ProductSeasonUpdateManyMutationInput;
    where?: ProductSeasonWhereInput;
  }) => BatchPayloadPromise;
  upsertProductSeason: (args: {
    where: ProductSeasonWhereUniqueInput;
    create: ProductSeasonCreateInput;
    update: ProductSeasonUpdateInput;
  }) => ProductSeasonPromise;
  deleteProductSeason: (
    where: ProductSeasonWhereUniqueInput
  ) => ProductSeasonPromise;
  deleteManyProductSeasons: (
    where?: ProductSeasonWhereInput
  ) => BatchPayloadPromise;
  createProductTier: (data: ProductTierCreateInput) => ProductTierPromise;
  updateProductTier: (args: {
    data: ProductTierUpdateInput;
    where: ProductTierWhereUniqueInput;
  }) => ProductTierPromise;
  updateManyProductTiers: (args: {
    data: ProductTierUpdateManyMutationInput;
    where?: ProductTierWhereInput;
  }) => BatchPayloadPromise;
  upsertProductTier: (args: {
    where: ProductTierWhereUniqueInput;
    create: ProductTierCreateInput;
    update: ProductTierUpdateInput;
  }) => ProductTierPromise;
  deleteProductTier: (where: ProductTierWhereUniqueInput) => ProductTierPromise;
  deleteManyProductTiers: (
    where?: ProductTierWhereInput
  ) => BatchPayloadPromise;
  createProductVariant: (
    data: ProductVariantCreateInput
  ) => ProductVariantPromise;
  updateProductVariant: (args: {
    data: ProductVariantUpdateInput;
    where: ProductVariantWhereUniqueInput;
  }) => ProductVariantPromise;
  updateManyProductVariants: (args: {
    data: ProductVariantUpdateManyMutationInput;
    where?: ProductVariantWhereInput;
  }) => BatchPayloadPromise;
  upsertProductVariant: (args: {
    where: ProductVariantWhereUniqueInput;
    create: ProductVariantCreateInput;
    update: ProductVariantUpdateInput;
  }) => ProductVariantPromise;
  deleteProductVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantPromise;
  deleteManyProductVariants: (
    where?: ProductVariantWhereInput
  ) => BatchPayloadPromise;
  createProductVariantFeedback: (
    data: ProductVariantFeedbackCreateInput
  ) => ProductVariantFeedbackPromise;
  updateProductVariantFeedback: (args: {
    data: ProductVariantFeedbackUpdateInput;
    where: ProductVariantFeedbackWhereUniqueInput;
  }) => ProductVariantFeedbackPromise;
  updateManyProductVariantFeedbacks: (args: {
    data: ProductVariantFeedbackUpdateManyMutationInput;
    where?: ProductVariantFeedbackWhereInput;
  }) => BatchPayloadPromise;
  upsertProductVariantFeedback: (args: {
    where: ProductVariantFeedbackWhereUniqueInput;
    create: ProductVariantFeedbackCreateInput;
    update: ProductVariantFeedbackUpdateInput;
  }) => ProductVariantFeedbackPromise;
  deleteProductVariantFeedback: (
    where: ProductVariantFeedbackWhereUniqueInput
  ) => ProductVariantFeedbackPromise;
  deleteManyProductVariantFeedbacks: (
    where?: ProductVariantFeedbackWhereInput
  ) => BatchPayloadPromise;
  createProductVariantFeedbackQuestion: (
    data: ProductVariantFeedbackQuestionCreateInput
  ) => ProductVariantFeedbackQuestionPromise;
  updateProductVariantFeedbackQuestion: (args: {
    data: ProductVariantFeedbackQuestionUpdateInput;
    where: ProductVariantFeedbackQuestionWhereUniqueInput;
  }) => ProductVariantFeedbackQuestionPromise;
  updateManyProductVariantFeedbackQuestions: (args: {
    data: ProductVariantFeedbackQuestionUpdateManyMutationInput;
    where?: ProductVariantFeedbackQuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertProductVariantFeedbackQuestion: (args: {
    where: ProductVariantFeedbackQuestionWhereUniqueInput;
    create: ProductVariantFeedbackQuestionCreateInput;
    update: ProductVariantFeedbackQuestionUpdateInput;
  }) => ProductVariantFeedbackQuestionPromise;
  deleteProductVariantFeedbackQuestion: (
    where: ProductVariantFeedbackQuestionWhereUniqueInput
  ) => ProductVariantFeedbackQuestionPromise;
  deleteManyProductVariantFeedbackQuestions: (
    where?: ProductVariantFeedbackQuestionWhereInput
  ) => BatchPayloadPromise;
  createProductVariantPrice: (
    data: ProductVariantPriceCreateInput
  ) => ProductVariantPricePromise;
  updateProductVariantPrice: (args: {
    data: ProductVariantPriceUpdateInput;
    where: ProductVariantPriceWhereUniqueInput;
  }) => ProductVariantPricePromise;
  updateManyProductVariantPrices: (args: {
    data: ProductVariantPriceUpdateManyMutationInput;
    where?: ProductVariantPriceWhereInput;
  }) => BatchPayloadPromise;
  upsertProductVariantPrice: (args: {
    where: ProductVariantPriceWhereUniqueInput;
    create: ProductVariantPriceCreateInput;
    update: ProductVariantPriceUpdateInput;
  }) => ProductVariantPricePromise;
  deleteProductVariantPrice: (
    where: ProductVariantPriceWhereUniqueInput
  ) => ProductVariantPricePromise;
  deleteManyProductVariantPrices: (
    where?: ProductVariantPriceWhereInput
  ) => BatchPayloadPromise;
  createProductVariantWant: (
    data: ProductVariantWantCreateInput
  ) => ProductVariantWantPromise;
  updateProductVariantWant: (args: {
    data: ProductVariantWantUpdateInput;
    where: ProductVariantWantWhereUniqueInput;
  }) => ProductVariantWantPromise;
  updateManyProductVariantWants: (args: {
    data: ProductVariantWantUpdateManyMutationInput;
    where?: ProductVariantWantWhereInput;
  }) => BatchPayloadPromise;
  upsertProductVariantWant: (args: {
    where: ProductVariantWantWhereUniqueInput;
    create: ProductVariantWantCreateInput;
    update: ProductVariantWantUpdateInput;
  }) => ProductVariantWantPromise;
  deleteProductVariantWant: (
    where: ProductVariantWantWhereUniqueInput
  ) => ProductVariantWantPromise;
  deleteManyProductVariantWants: (
    where?: ProductVariantWantWhereInput
  ) => BatchPayloadPromise;
  createPushNotificationReceipt: (
    data: PushNotificationReceiptCreateInput
  ) => PushNotificationReceiptPromise;
  updatePushNotificationReceipt: (args: {
    data: PushNotificationReceiptUpdateInput;
    where: PushNotificationReceiptWhereUniqueInput;
  }) => PushNotificationReceiptPromise;
  updateManyPushNotificationReceipts: (args: {
    data: PushNotificationReceiptUpdateManyMutationInput;
    where?: PushNotificationReceiptWhereInput;
  }) => BatchPayloadPromise;
  upsertPushNotificationReceipt: (args: {
    where: PushNotificationReceiptWhereUniqueInput;
    create: PushNotificationReceiptCreateInput;
    update: PushNotificationReceiptUpdateInput;
  }) => PushNotificationReceiptPromise;
  deletePushNotificationReceipt: (
    where: PushNotificationReceiptWhereUniqueInput
  ) => PushNotificationReceiptPromise;
  deleteManyPushNotificationReceipts: (
    where?: PushNotificationReceiptWhereInput
  ) => BatchPayloadPromise;
  createRecentlyViewedProduct: (
    data: RecentlyViewedProductCreateInput
  ) => RecentlyViewedProductPromise;
  updateRecentlyViewedProduct: (args: {
    data: RecentlyViewedProductUpdateInput;
    where: RecentlyViewedProductWhereUniqueInput;
  }) => RecentlyViewedProductPromise;
  updateManyRecentlyViewedProducts: (args: {
    data: RecentlyViewedProductUpdateManyMutationInput;
    where?: RecentlyViewedProductWhereInput;
  }) => BatchPayloadPromise;
  upsertRecentlyViewedProduct: (args: {
    where: RecentlyViewedProductWhereUniqueInput;
    create: RecentlyViewedProductCreateInput;
    update: RecentlyViewedProductUpdateInput;
  }) => RecentlyViewedProductPromise;
  deleteRecentlyViewedProduct: (
    where: RecentlyViewedProductWhereUniqueInput
  ) => RecentlyViewedProductPromise;
  deleteManyRecentlyViewedProducts: (
    where?: RecentlyViewedProductWhereInput
  ) => BatchPayloadPromise;
  createReservation: (data: ReservationCreateInput) => ReservationPromise;
  updateReservation: (args: {
    data: ReservationUpdateInput;
    where: ReservationWhereUniqueInput;
  }) => ReservationPromise;
  updateManyReservations: (args: {
    data: ReservationUpdateManyMutationInput;
    where?: ReservationWhereInput;
  }) => BatchPayloadPromise;
  upsertReservation: (args: {
    where: ReservationWhereUniqueInput;
    create: ReservationCreateInput;
    update: ReservationUpdateInput;
  }) => ReservationPromise;
  deleteReservation: (where: ReservationWhereUniqueInput) => ReservationPromise;
  deleteManyReservations: (
    where?: ReservationWhereInput
  ) => BatchPayloadPromise;
  createReservationFeedback: (
    data: ReservationFeedbackCreateInput
  ) => ReservationFeedbackPromise;
  updateReservationFeedback: (args: {
    data: ReservationFeedbackUpdateInput;
    where: ReservationFeedbackWhereUniqueInput;
  }) => ReservationFeedbackPromise;
  updateManyReservationFeedbacks: (args: {
    data: ReservationFeedbackUpdateManyMutationInput;
    where?: ReservationFeedbackWhereInput;
  }) => BatchPayloadPromise;
  upsertReservationFeedback: (args: {
    where: ReservationFeedbackWhereUniqueInput;
    create: ReservationFeedbackCreateInput;
    update: ReservationFeedbackUpdateInput;
  }) => ReservationFeedbackPromise;
  deleteReservationFeedback: (
    where: ReservationFeedbackWhereUniqueInput
  ) => ReservationFeedbackPromise;
  deleteManyReservationFeedbacks: (
    where?: ReservationFeedbackWhereInput
  ) => BatchPayloadPromise;
  createReservationReceipt: (
    data: ReservationReceiptCreateInput
  ) => ReservationReceiptPromise;
  updateReservationReceipt: (args: {
    data: ReservationReceiptUpdateInput;
    where: ReservationReceiptWhereUniqueInput;
  }) => ReservationReceiptPromise;
  upsertReservationReceipt: (args: {
    where: ReservationReceiptWhereUniqueInput;
    create: ReservationReceiptCreateInput;
    update: ReservationReceiptUpdateInput;
  }) => ReservationReceiptPromise;
  deleteReservationReceipt: (
    where: ReservationReceiptWhereUniqueInput
  ) => ReservationReceiptPromise;
  deleteManyReservationReceipts: (
    where?: ReservationReceiptWhereInput
  ) => BatchPayloadPromise;
  createReservationReceiptItem: (
    data: ReservationReceiptItemCreateInput
  ) => ReservationReceiptItemPromise;
  updateReservationReceiptItem: (args: {
    data: ReservationReceiptItemUpdateInput;
    where: ReservationReceiptItemWhereUniqueInput;
  }) => ReservationReceiptItemPromise;
  updateManyReservationReceiptItems: (args: {
    data: ReservationReceiptItemUpdateManyMutationInput;
    where?: ReservationReceiptItemWhereInput;
  }) => BatchPayloadPromise;
  upsertReservationReceiptItem: (args: {
    where: ReservationReceiptItemWhereUniqueInput;
    create: ReservationReceiptItemCreateInput;
    update: ReservationReceiptItemUpdateInput;
  }) => ReservationReceiptItemPromise;
  deleteReservationReceiptItem: (
    where: ReservationReceiptItemWhereUniqueInput
  ) => ReservationReceiptItemPromise;
  deleteManyReservationReceiptItems: (
    where?: ReservationReceiptItemWhereInput
  ) => BatchPayloadPromise;
  createSeason: (data: SeasonCreateInput) => SeasonPromise;
  updateSeason: (args: {
    data: SeasonUpdateInput;
    where: SeasonWhereUniqueInput;
  }) => SeasonPromise;
  updateManySeasons: (args: {
    data: SeasonUpdateManyMutationInput;
    where?: SeasonWhereInput;
  }) => BatchPayloadPromise;
  upsertSeason: (args: {
    where: SeasonWhereUniqueInput;
    create: SeasonCreateInput;
    update: SeasonUpdateInput;
  }) => SeasonPromise;
  deleteSeason: (where: SeasonWhereUniqueInput) => SeasonPromise;
  deleteManySeasons: (where?: SeasonWhereInput) => BatchPayloadPromise;
  createShippingMethod: (
    data: ShippingMethodCreateInput
  ) => ShippingMethodPromise;
  updateShippingMethod: (args: {
    data: ShippingMethodUpdateInput;
    where: ShippingMethodWhereUniqueInput;
  }) => ShippingMethodPromise;
  updateManyShippingMethods: (args: {
    data: ShippingMethodUpdateManyMutationInput;
    where?: ShippingMethodWhereInput;
  }) => BatchPayloadPromise;
  upsertShippingMethod: (args: {
    where: ShippingMethodWhereUniqueInput;
    create: ShippingMethodCreateInput;
    update: ShippingMethodUpdateInput;
  }) => ShippingMethodPromise;
  deleteShippingMethod: (
    where: ShippingMethodWhereUniqueInput
  ) => ShippingMethodPromise;
  deleteManyShippingMethods: (
    where?: ShippingMethodWhereInput
  ) => BatchPayloadPromise;
  createShippingOption: (
    data: ShippingOptionCreateInput
  ) => ShippingOptionPromise;
  updateShippingOption: (args: {
    data: ShippingOptionUpdateInput;
    where: ShippingOptionWhereUniqueInput;
  }) => ShippingOptionPromise;
  updateManyShippingOptions: (args: {
    data: ShippingOptionUpdateManyMutationInput;
    where?: ShippingOptionWhereInput;
  }) => BatchPayloadPromise;
  upsertShippingOption: (args: {
    where: ShippingOptionWhereUniqueInput;
    create: ShippingOptionCreateInput;
    update: ShippingOptionUpdateInput;
  }) => ShippingOptionPromise;
  deleteShippingOption: (
    where: ShippingOptionWhereUniqueInput
  ) => ShippingOptionPromise;
  deleteManyShippingOptions: (
    where?: ShippingOptionWhereInput
  ) => BatchPayloadPromise;
  createShopifyProductVariant: (
    data: ShopifyProductVariantCreateInput
  ) => ShopifyProductVariantPromise;
  updateShopifyProductVariant: (args: {
    data: ShopifyProductVariantUpdateInput;
    where: ShopifyProductVariantWhereUniqueInput;
  }) => ShopifyProductVariantPromise;
  updateManyShopifyProductVariants: (args: {
    data: ShopifyProductVariantUpdateManyMutationInput;
    where?: ShopifyProductVariantWhereInput;
  }) => BatchPayloadPromise;
  upsertShopifyProductVariant: (args: {
    where: ShopifyProductVariantWhereUniqueInput;
    create: ShopifyProductVariantCreateInput;
    update: ShopifyProductVariantUpdateInput;
  }) => ShopifyProductVariantPromise;
  deleteShopifyProductVariant: (
    where: ShopifyProductVariantWhereUniqueInput
  ) => ShopifyProductVariantPromise;
  deleteManyShopifyProductVariants: (
    where?: ShopifyProductVariantWhereInput
  ) => BatchPayloadPromise;
  createSize: (data: SizeCreateInput) => SizePromise;
  updateSize: (args: {
    data: SizeUpdateInput;
    where: SizeWhereUniqueInput;
  }) => SizePromise;
  updateManySizes: (args: {
    data: SizeUpdateManyMutationInput;
    where?: SizeWhereInput;
  }) => BatchPayloadPromise;
  upsertSize: (args: {
    where: SizeWhereUniqueInput;
    create: SizeCreateInput;
    update: SizeUpdateInput;
  }) => SizePromise;
  deleteSize: (where: SizeWhereUniqueInput) => SizePromise;
  deleteManySizes: (where?: SizeWhereInput) => BatchPayloadPromise;
  createSmsReceipt: (data: SmsReceiptCreateInput) => SmsReceiptPromise;
  updateSmsReceipt: (args: {
    data: SmsReceiptUpdateInput;
    where: SmsReceiptWhereUniqueInput;
  }) => SmsReceiptPromise;
  updateManySmsReceipts: (args: {
    data: SmsReceiptUpdateManyMutationInput;
    where?: SmsReceiptWhereInput;
  }) => BatchPayloadPromise;
  upsertSmsReceipt: (args: {
    where: SmsReceiptWhereUniqueInput;
    create: SmsReceiptCreateInput;
    update: SmsReceiptUpdateInput;
  }) => SmsReceiptPromise;
  deleteSmsReceipt: (where: SmsReceiptWhereUniqueInput) => SmsReceiptPromise;
  deleteManySmsReceipts: (where?: SmsReceiptWhereInput) => BatchPayloadPromise;
  createStylePreferences: (
    data: StylePreferencesCreateInput
  ) => StylePreferencesPromise;
  updateStylePreferences: (args: {
    data: StylePreferencesUpdateInput;
    where: StylePreferencesWhereUniqueInput;
  }) => StylePreferencesPromise;
  updateManyStylePreferenceses: (args: {
    data: StylePreferencesUpdateManyMutationInput;
    where?: StylePreferencesWhereInput;
  }) => BatchPayloadPromise;
  upsertStylePreferences: (args: {
    where: StylePreferencesWhereUniqueInput;
    create: StylePreferencesCreateInput;
    update: StylePreferencesUpdateInput;
  }) => StylePreferencesPromise;
  deleteStylePreferences: (
    where: StylePreferencesWhereUniqueInput
  ) => StylePreferencesPromise;
  deleteManyStylePreferenceses: (
    where?: StylePreferencesWhereInput
  ) => BatchPayloadPromise;
  createSyncTiming: (data: SyncTimingCreateInput) => SyncTimingPromise;
  updateSyncTiming: (args: {
    data: SyncTimingUpdateInput;
    where: SyncTimingWhereUniqueInput;
  }) => SyncTimingPromise;
  updateManySyncTimings: (args: {
    data: SyncTimingUpdateManyMutationInput;
    where?: SyncTimingWhereInput;
  }) => BatchPayloadPromise;
  upsertSyncTiming: (args: {
    where: SyncTimingWhereUniqueInput;
    create: SyncTimingCreateInput;
    update: SyncTimingUpdateInput;
  }) => SyncTimingPromise;
  deleteSyncTiming: (where: SyncTimingWhereUniqueInput) => SyncTimingPromise;
  deleteManySyncTimings: (where?: SyncTimingWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTopSize: (data: TopSizeCreateInput) => TopSizePromise;
  updateTopSize: (args: {
    data: TopSizeUpdateInput;
    where: TopSizeWhereUniqueInput;
  }) => TopSizePromise;
  updateManyTopSizes: (args: {
    data: TopSizeUpdateManyMutationInput;
    where?: TopSizeWhereInput;
  }) => BatchPayloadPromise;
  upsertTopSize: (args: {
    where: TopSizeWhereUniqueInput;
    create: TopSizeCreateInput;
    update: TopSizeUpdateInput;
  }) => TopSizePromise;
  deleteTopSize: (where: TopSizeWhereUniqueInput) => TopSizePromise;
  deleteManyTopSizes: (where?: TopSizeWhereInput) => BatchPayloadPromise;
  createUTMData: (data: UTMDataCreateInput) => UTMDataPromise;
  updateUTMData: (args: {
    data: UTMDataUpdateInput;
    where: UTMDataWhereUniqueInput;
  }) => UTMDataPromise;
  updateManyUTMDatas: (args: {
    data: UTMDataUpdateManyMutationInput;
    where?: UTMDataWhereInput;
  }) => BatchPayloadPromise;
  upsertUTMData: (args: {
    where: UTMDataWhereUniqueInput;
    create: UTMDataCreateInput;
    update: UTMDataUpdateInput;
  }) => UTMDataPromise;
  deleteUTMData: (where: UTMDataWhereUniqueInput) => UTMDataPromise;
  deleteManyUTMDatas: (where?: UTMDataWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserPushNotification: (
    data: UserPushNotificationCreateInput
  ) => UserPushNotificationPromise;
  updateUserPushNotification: (args: {
    data: UserPushNotificationUpdateInput;
    where: UserPushNotificationWhereUniqueInput;
  }) => UserPushNotificationPromise;
  updateManyUserPushNotifications: (args: {
    data: UserPushNotificationUpdateManyMutationInput;
    where?: UserPushNotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertUserPushNotification: (args: {
    where: UserPushNotificationWhereUniqueInput;
    create: UserPushNotificationCreateInput;
    update: UserPushNotificationUpdateInput;
  }) => UserPushNotificationPromise;
  deleteUserPushNotification: (
    where: UserPushNotificationWhereUniqueInput
  ) => UserPushNotificationPromise;
  deleteManyUserPushNotifications: (
    where?: UserPushNotificationWhereInput
  ) => BatchPayloadPromise;
  createUserPushNotificationInterest: (
    data: UserPushNotificationInterestCreateInput
  ) => UserPushNotificationInterestPromise;
  updateUserPushNotificationInterest: (args: {
    data: UserPushNotificationInterestUpdateInput;
    where: UserPushNotificationInterestWhereUniqueInput;
  }) => UserPushNotificationInterestPromise;
  updateManyUserPushNotificationInterests: (args: {
    data: UserPushNotificationInterestUpdateManyMutationInput;
    where?: UserPushNotificationInterestWhereInput;
  }) => BatchPayloadPromise;
  upsertUserPushNotificationInterest: (args: {
    where: UserPushNotificationInterestWhereUniqueInput;
    create: UserPushNotificationInterestCreateInput;
    update: UserPushNotificationInterestUpdateInput;
  }) => UserPushNotificationInterestPromise;
  deleteUserPushNotificationInterest: (
    where: UserPushNotificationInterestWhereUniqueInput
  ) => UserPushNotificationInterestPromise;
  deleteManyUserPushNotificationInterests: (
    where?: UserPushNotificationInterestWhereInput
  ) => BatchPayloadPromise;
  createWarehouseLocation: (
    data: WarehouseLocationCreateInput
  ) => WarehouseLocationPromise;
  updateWarehouseLocation: (args: {
    data: WarehouseLocationUpdateInput;
    where: WarehouseLocationWhereUniqueInput;
  }) => WarehouseLocationPromise;
  updateManyWarehouseLocations: (args: {
    data: WarehouseLocationUpdateManyMutationInput;
    where?: WarehouseLocationWhereInput;
  }) => BatchPayloadPromise;
  upsertWarehouseLocation: (args: {
    where: WarehouseLocationWhereUniqueInput;
    create: WarehouseLocationCreateInput;
    update: WarehouseLocationUpdateInput;
  }) => WarehouseLocationPromise;
  deleteWarehouseLocation: (
    where: WarehouseLocationWhereUniqueInput
  ) => WarehouseLocationPromise;
  deleteManyWarehouseLocations: (
    where?: WarehouseLocationWhereInput
  ) => BatchPayloadPromise;
  createWarehouseLocationConstraint: (
    data: WarehouseLocationConstraintCreateInput
  ) => WarehouseLocationConstraintPromise;
  updateWarehouseLocationConstraint: (args: {
    data: WarehouseLocationConstraintUpdateInput;
    where: WarehouseLocationConstraintWhereUniqueInput;
  }) => WarehouseLocationConstraintPromise;
  updateManyWarehouseLocationConstraints: (args: {
    data: WarehouseLocationConstraintUpdateManyMutationInput;
    where?: WarehouseLocationConstraintWhereInput;
  }) => BatchPayloadPromise;
  upsertWarehouseLocationConstraint: (args: {
    where: WarehouseLocationConstraintWhereUniqueInput;
    create: WarehouseLocationConstraintCreateInput;
    update: WarehouseLocationConstraintUpdateInput;
  }) => WarehouseLocationConstraintPromise;
  deleteWarehouseLocationConstraint: (
    where: WarehouseLocationConstraintWhereUniqueInput
  ) => WarehouseLocationConstraintPromise;
  deleteManyWarehouseLocationConstraints: (
    where?: WarehouseLocationConstraintWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activeAdminUser: (
    where?: ActiveAdminUserSubscriptionWhereInput
  ) => ActiveAdminUserSubscriptionPayloadSubscription;
  adminActionLog: (
    where?: AdminActionLogSubscriptionWhereInput
  ) => AdminActionLogSubscriptionPayloadSubscription;
  bagItem: (
    where?: BagItemSubscriptionWhereInput
  ) => BagItemSubscriptionPayloadSubscription;
  billingInfo: (
    where?: BillingInfoSubscriptionWhereInput
  ) => BillingInfoSubscriptionPayloadSubscription;
  bottomSize: (
    where?: BottomSizeSubscriptionWhereInput
  ) => BottomSizeSubscriptionPayloadSubscription;
  brand: (
    where?: BrandSubscriptionWhereInput
  ) => BrandSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  collection: (
    where?: CollectionSubscriptionWhereInput
  ) => CollectionSubscriptionPayloadSubscription;
  color: (
    where?: ColorSubscriptionWhereInput
  ) => ColorSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  customerAdmissionsData: (
    where?: CustomerAdmissionsDataSubscriptionWhereInput
  ) => CustomerAdmissionsDataSubscriptionPayloadSubscription;
  customerDetail: (
    where?: CustomerDetailSubscriptionWhereInput
  ) => CustomerDetailSubscriptionPayloadSubscription;
  customerMembership: (
    where?: CustomerMembershipSubscriptionWhereInput
  ) => CustomerMembershipSubscriptionPayloadSubscription;
  emailReceipt: (
    where?: EmailReceiptSubscriptionWhereInput
  ) => EmailReceiptSubscriptionPayloadSubscription;
  externalShopifyIntegration: (
    where?: ExternalShopifyIntegrationSubscriptionWhereInput
  ) => ExternalShopifyIntegrationSubscriptionPayloadSubscription;
  fitPic: (
    where?: FitPicSubscriptionWhereInput
  ) => FitPicSubscriptionPayloadSubscription;
  fitPicReport: (
    where?: FitPicReportSubscriptionWhereInput
  ) => FitPicReportSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  interestedUser: (
    where?: InterestedUserSubscriptionWhereInput
  ) => InterestedUserSubscriptionPayloadSubscription;
  label: (
    where?: LabelSubscriptionWhereInput
  ) => LabelSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  package: (
    where?: PackageSubscriptionWhereInput
  ) => PackageSubscriptionPayloadSubscription;
  packageTransitEvent: (
    where?: PackageTransitEventSubscriptionWhereInput
  ) => PackageTransitEventSubscriptionPayloadSubscription;
  pauseRequest: (
    where?: PauseRequestSubscriptionWhereInput
  ) => PauseRequestSubscriptionPayloadSubscription;
  paymentPlan: (
    where?: PaymentPlanSubscriptionWhereInput
  ) => PaymentPlanSubscriptionPayloadSubscription;
  physicalProduct: (
    where?: PhysicalProductSubscriptionWhereInput
  ) => PhysicalProductSubscriptionPayloadSubscription;
  physicalProductPrice: (
    where?: PhysicalProductPriceSubscriptionWhereInput
  ) => PhysicalProductPriceSubscriptionPayloadSubscription;
  physicalProductQualityReport: (
    where?: PhysicalProductQualityReportSubscriptionWhereInput
  ) => PhysicalProductQualityReportSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productFunction: (
    where?: ProductFunctionSubscriptionWhereInput
  ) => ProductFunctionSubscriptionPayloadSubscription;
  productMaterialCategory: (
    where?: ProductMaterialCategorySubscriptionWhereInput
  ) => ProductMaterialCategorySubscriptionPayloadSubscription;
  productModel: (
    where?: ProductModelSubscriptionWhereInput
  ) => ProductModelSubscriptionPayloadSubscription;
  productNotification: (
    where?: ProductNotificationSubscriptionWhereInput
  ) => ProductNotificationSubscriptionPayloadSubscription;
  productRequest: (
    where?: ProductRequestSubscriptionWhereInput
  ) => ProductRequestSubscriptionPayloadSubscription;
  productSeason: (
    where?: ProductSeasonSubscriptionWhereInput
  ) => ProductSeasonSubscriptionPayloadSubscription;
  productTier: (
    where?: ProductTierSubscriptionWhereInput
  ) => ProductTierSubscriptionPayloadSubscription;
  productVariant: (
    where?: ProductVariantSubscriptionWhereInput
  ) => ProductVariantSubscriptionPayloadSubscription;
  productVariantFeedback: (
    where?: ProductVariantFeedbackSubscriptionWhereInput
  ) => ProductVariantFeedbackSubscriptionPayloadSubscription;
  productVariantFeedbackQuestion: (
    where?: ProductVariantFeedbackQuestionSubscriptionWhereInput
  ) => ProductVariantFeedbackQuestionSubscriptionPayloadSubscription;
  productVariantPrice: (
    where?: ProductVariantPriceSubscriptionWhereInput
  ) => ProductVariantPriceSubscriptionPayloadSubscription;
  productVariantWant: (
    where?: ProductVariantWantSubscriptionWhereInput
  ) => ProductVariantWantSubscriptionPayloadSubscription;
  pushNotificationReceipt: (
    where?: PushNotificationReceiptSubscriptionWhereInput
  ) => PushNotificationReceiptSubscriptionPayloadSubscription;
  recentlyViewedProduct: (
    where?: RecentlyViewedProductSubscriptionWhereInput
  ) => RecentlyViewedProductSubscriptionPayloadSubscription;
  reservation: (
    where?: ReservationSubscriptionWhereInput
  ) => ReservationSubscriptionPayloadSubscription;
  reservationFeedback: (
    where?: ReservationFeedbackSubscriptionWhereInput
  ) => ReservationFeedbackSubscriptionPayloadSubscription;
  reservationReceipt: (
    where?: ReservationReceiptSubscriptionWhereInput
  ) => ReservationReceiptSubscriptionPayloadSubscription;
  reservationReceiptItem: (
    where?: ReservationReceiptItemSubscriptionWhereInput
  ) => ReservationReceiptItemSubscriptionPayloadSubscription;
  season: (
    where?: SeasonSubscriptionWhereInput
  ) => SeasonSubscriptionPayloadSubscription;
  shippingMethod: (
    where?: ShippingMethodSubscriptionWhereInput
  ) => ShippingMethodSubscriptionPayloadSubscription;
  shippingOption: (
    where?: ShippingOptionSubscriptionWhereInput
  ) => ShippingOptionSubscriptionPayloadSubscription;
  shopifyProductVariant: (
    where?: ShopifyProductVariantSubscriptionWhereInput
  ) => ShopifyProductVariantSubscriptionPayloadSubscription;
  size: (
    where?: SizeSubscriptionWhereInput
  ) => SizeSubscriptionPayloadSubscription;
  smsReceipt: (
    where?: SmsReceiptSubscriptionWhereInput
  ) => SmsReceiptSubscriptionPayloadSubscription;
  stylePreferences: (
    where?: StylePreferencesSubscriptionWhereInput
  ) => StylePreferencesSubscriptionPayloadSubscription;
  syncTiming: (
    where?: SyncTimingSubscriptionWhereInput
  ) => SyncTimingSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  topSize: (
    where?: TopSizeSubscriptionWhereInput
  ) => TopSizeSubscriptionPayloadSubscription;
  uTMData: (
    where?: UTMDataSubscriptionWhereInput
  ) => UTMDataSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userPushNotification: (
    where?: UserPushNotificationSubscriptionWhereInput
  ) => UserPushNotificationSubscriptionPayloadSubscription;
  userPushNotificationInterest: (
    where?: UserPushNotificationInterestSubscriptionWhereInput
  ) => UserPushNotificationInterestSubscriptionPayloadSubscription;
  warehouseLocation: (
    where?: WarehouseLocationSubscriptionWhereInput
  ) => WarehouseLocationSubscriptionPayloadSubscription;
  warehouseLocationConstraint: (
    where?: WarehouseLocationConstraintSubscriptionWhereInput
  ) => WarehouseLocationConstraintSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserRole = "Admin" | "Customer" | "Partner" | "Marketer";

export type PushNotificationStatus = "Blocked" | "Granted" | "Denied";

export type EmailId =
  | "CompleteAccount"
  | "DaySevenAuthorizationFollowup"
  | "DaySixAuthorizationFollowup"
  | "DayFiveAuthorizationFollowup"
  | "DayFourAuthorizationFollowup"
  | "DayThreeAuthorizationFollowup"
  | "DayTwoAuthorizationFollowup"
  | "FreeToReserve"
  | "Paused"
  | "PriorityAccess"
  | "ReferralConfirmation"
  | "ReservationConfirmation"
  | "ReservationReturnConfirmation"
  | "ResumeConfirmation"
  | "ResumeReminder"
  | "ReturnReminder"
  | "Rewaitlisted"
  | "SubmittedEmail"
  | "TwentyFourHourAuthorizationFollowup"
  | "Waitlisted"
  | "WelcomeToSeasons";

export type UserPushNotificationInterestType =
  | "Bag"
  | "Blog"
  | "Brand"
  | "General"
  | "NewProduct";

export type UserVerificationStatus = "Approved" | "Denied" | "Pending";

export type UserVerificationMethod = "SMS" | "Email" | "None";

export type SmsStatus =
  | "Queued"
  | "Sending"
  | "Sent"
  | "Failed"
  | "Delivered"
  | "Undelivered"
  | "Receiving"
  | "Received"
  | "Accepted"
  | "Scheduled"
  | "Read"
  | "PartiallyDelivered";

export type LocationType = "Office" | "Warehouse" | "Cleaner" | "Customer";

export type ProductType = "Top" | "Bottom" | "Accessory" | "Shoe";

export type LetterSize = "XXS" | "XS" | "S" | "M" | "L" | "XL" | "XXL" | "XXXL";

export type BottomSizeType = "WxL" | "US" | "EU" | "JP" | "Letter";

export type ProductArchitecture = "Fashion" | "Showstopper" | "Staple";

export type BrandTier =
  | "Tier0"
  | "Tier1"
  | "Tier2"
  | "Niche"
  | "Upcoming"
  | "Retro"
  | "Boutique"
  | "Local"
  | "Discovery";

export type PhotographyStatus =
  | "Done"
  | "InProgress"
  | "ReadyForEditing"
  | "ReadyToShoot"
  | "Steam";

export type ProductFit = "RunsBig" | "TrueToSize" | "RunsSmall";

export type SeasonCode = "FW" | "SS" | "PS" | "PF" | "HO" | "AW";

export type ProductStatus =
  | "Available"
  | "NotAvailable"
  | "Stored"
  | "Offloaded";

export type ProductTierName = "Standard" | "Luxury";

export type InventoryStatus =
  | "NonReservable"
  | "Reservable"
  | "Reserved"
  | "Stored"
  | "Offloaded";

export type PhysicalProductStatus =
  | "New"
  | "Used"
  | "Dirty"
  | "Damaged"
  | "PermanentlyDamaged"
  | "Clean"
  | "Lost";

export type PhysicalProductOffloadMethod =
  | "SoldToUser"
  | "SoldToThirdParty"
  | "ReturnedToVendor"
  | "Recycled"
  | "Unknown";

export type WarehouseLocationType = "Conveyor" | "Rail" | "Bin";

export type PhysicalProductDamageType =
  | "BarcodeMissing"
  | "ButtonMissing"
  | "Stain"
  | "Smell"
  | "Tear"
  | "Other";

export type ShippingCode = "UPSGround" | "UPSSelect";

export type FitPicReportStatus = "Pending" | "Reviewed";

export type FitPicStatus = "Submitted" | "Published" | "Unpublished";

export type PushNotificationReceiptOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "route_ASC"
  | "route_DESC"
  | "screen_ASC"
  | "screen_DESC"
  | "uri_ASC"
  | "uri_DESC"
  | "interest_ASC"
  | "interest_DESC"
  | "body_ASC"
  | "body_DESC"
  | "title_ASC"
  | "title_DESC"
  | "recordID_ASC"
  | "recordID_DESC"
  | "recordSlug_ASC"
  | "recordSlug_DESC"
  | "notificationKey_ASC"
  | "notificationKey_DESC"
  | "sentAt_ASC"
  | "sentAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "auth0Id_ASC"
  | "auth0Id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "role_ASC"
  | "role_DESC"
  | "pushNotificationStatus_ASC"
  | "pushNotificationStatus_DESC"
  | "sendSystemEmails_ASC"
  | "sendSystemEmails_DESC"
  | "verificationStatus_ASC"
  | "verificationStatus_DESC"
  | "verificationMethod_ASC"
  | "verificationMethod_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmailReceiptOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "emailId_ASC"
  | "emailId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserPushNotificationInterestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "value_ASC"
  | "value_DESC"
  | "status_ASC"
  | "status_DESC";

export type SmsReceiptOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "externalId_ASC"
  | "externalId_DESC"
  | "body_ASC"
  | "body_DESC"
  | "status_ASC"
  | "status_DESC"
  | "smsId_ASC"
  | "smsId_DESC"
  | "sentAt_ASC"
  | "sentAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FitPicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "includeInstagramHandle_ASC"
  | "includeInstagramHandle_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PhysicalProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "seasonsUID_ASC"
  | "seasonsUID_DESC"
  | "inventoryStatus_ASC"
  | "inventoryStatus_DESC"
  | "productStatus_ASC"
  | "productStatus_DESC"
  | "offloadMethod_ASC"
  | "offloadMethod_DESC"
  | "offloadNotes_ASC"
  | "offloadNotes_DESC"
  | "sequenceNumber_ASC"
  | "sequenceNumber_DESC"
  | "barcoded_ASC"
  | "barcoded_DESC"
  | "dateOrdered_ASC"
  | "dateOrdered_DESC"
  | "dateReceived_ASC"
  | "dateReceived_DESC"
  | "unitCost_ASC"
  | "unitCost_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductVariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "displayShort_ASC"
  | "displayShort_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "height_ASC"
  | "height_DESC"
  | "productID_ASC"
  | "productID_DESC"
  | "retailPrice_ASC"
  | "retailPrice_DESC"
  | "total_ASC"
  | "total_DESC"
  | "reservable_ASC"
  | "reservable_DESC"
  | "reserved_ASC"
  | "reserved_DESC"
  | "nonReservable_ASC"
  | "nonReservable_DESC"
  | "offloaded_ASC"
  | "offloaded_DESC"
  | "stored_ASC"
  | "stored_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SizeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "productType_ASC"
  | "productType_DESC"
  | "display_ASC"
  | "display_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "architecture_ASC"
  | "architecture_DESC"
  | "description_ASC"
  | "description_DESC"
  | "externalURL_ASC"
  | "externalURL_DESC"
  | "buyNewEnabled_ASC"
  | "buyNewEnabled_DESC"
  | "modelHeight_ASC"
  | "modelHeight_DESC"
  | "name_ASC"
  | "name_DESC"
  | "photographyStatus_ASC"
  | "photographyStatus_DESC"
  | "productFit_ASC"
  | "productFit_DESC"
  | "publishedAt_ASC"
  | "publishedAt_DESC"
  | "retailPrice_ASC"
  | "retailPrice_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "url_ASC"
  | "url_DESC"
  | "height_ASC"
  | "height_DESC"
  | "width_ASC"
  | "width_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "image_ASC"
  | "image_DESC"
  | "description_ASC"
  | "description_DESC"
  | "visible_ASC"
  | "visible_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductFunctionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type SeasonString = "Spring" | "Summer" | "Winter" | "Fall";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WarehouseLocationConstraintOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "limit_ASC"
  | "limit_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WarehouseLocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "barcode_ASC"
  | "barcode_DESC"
  | "locationCode_ASC"
  | "locationCode_DESC"
  | "itemCode_ASC"
  | "itemCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PhysicalProductQualityReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "damageType_ASC"
  | "damageType_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShippingOptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "externalCost_ASC"
  | "externalCost_DESC"
  | "averageDuration_ASC"
  | "averageDuration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FitPicReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "reportedAt_ASC"
  | "reportedAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActiveAdminUserOrderByInput = "id_ASC" | "id_DESC";

export type AdminAction = "Insert" | "Delete" | "Update" | "Truncate";

export type AdminActionLogOrderByInput =
  | "actionId_ASC"
  | "actionId_DESC"
  | "entityId_ASC"
  | "entityId_DESC"
  | "tableName_ASC"
  | "tableName_DESC"
  | "triggeredAt_ASC"
  | "triggeredAt_DESC"
  | "action_ASC"
  | "action_DESC"
  | "rowData_ASC"
  | "rowData_DESC"
  | "changedFields_ASC"
  | "changedFields_DESC"
  | "statementOnly_ASC"
  | "statementOnly_DESC";

export type CustomerStatus =
  | "Invited"
  | "Created"
  | "Waitlisted"
  | "Authorized"
  | "Active"
  | "Suspended"
  | "Paused"
  | "Deactivated";

export type Plan = "AllAccess" | "Essential";

export type PaymentPlanTier = "Essential" | "AllAccess";

export type BagItemStatus = "Added" | "Reserved" | "Received";

export type PackageTransitEventStatus =
  | "Delivered"
  | "Failure"
  | "PreTransit"
  | "Returned"
  | "Transit"
  | "Unknown";

export type PackageTransitEventSubStatus =
  | "AddressIssue"
  | "ContactCarrier"
  | "Delayed"
  | "Delivered"
  | "DeliveryAttempted"
  | "DeliveryRescheduled"
  | "DeliveryScheduled"
  | "InformationReceived"
  | "LocationInaccessible"
  | "NoticeLeft"
  | "Other"
  | "OutForDelivery"
  | "PackageAccepted"
  | "PackageArrived"
  | "PackageDamaged"
  | "PackageDeparted"
  | "PackageDisposed"
  | "PackageForwarded"
  | "PackageHeld"
  | "PackageLost"
  | "PackageProcessed"
  | "PackageProcessing"
  | "PackageUnclaimed"
  | "PackageUndeliverable"
  | "PickupAvailable"
  | "RescheduleDelivery"
  | "ReturnToSender";

export type ReservationPhase = "BusinessToCustomer" | "CustomerToBusiness";

export type ReservationStatus =
  | "Queued"
  | "Packed"
  | "Shipped"
  | "Delivered"
  | "Completed"
  | "Cancelled"
  | "Blocked"
  | "Unknown"
  | "Received";

export type InAdmissableReason =
  | "Untriageable"
  | "UnsupportedPlatform"
  | "AutomaticAdmissionsFlagOff"
  | "UnserviceableZipcode"
  | "InsufficientInventory"
  | "OpsThresholdExceeded";

export type PauseRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "pausePending_ASC"
  | "pausePending_DESC"
  | "pauseDate_ASC"
  | "pauseDate_DESC"
  | "resumeDate_ASC"
  | "resumeDate_DESC"
  | "notified_ASC"
  | "notified_DESC";

export type BagItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "position_ASC"
  | "position_DESC"
  | "saved_ASC"
  | "saved_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReservationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reservationNumber_ASC"
  | "reservationNumber_DESC"
  | "phase_ASC"
  | "phase_DESC"
  | "shipped_ASC"
  | "shipped_DESC"
  | "status_ASC"
  | "status_DESC"
  | "shippedAt_ASC"
  | "shippedAt_DESC"
  | "receivedAt_ASC"
  | "receivedAt_DESC"
  | "reminderSentAt_ASC"
  | "reminderSentAt_DESC"
  | "statusUpdatedAt_ASC"
  | "statusUpdatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PackageTransitEventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "subStatus_ASC"
  | "subStatus_DESC"
  | "data_ASC"
  | "data_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReservationReceiptItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "productStatus_ASC"
  | "productStatus_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "plan_ASC"
  | "plan_DESC"
  | "referralLink_ASC"
  | "referralLink_DESC"
  | "referrerId_ASC"
  | "referrerId_DESC"
  | "authorizedAt_ASC"
  | "authorizedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BillingInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "name_ASC"
  | "name_DESC"
  | "last_digits_ASC"
  | "last_digits_DESC"
  | "expiration_month_ASC"
  | "expiration_month_DESC"
  | "expiration_year_ASC"
  | "expiration_year_DESC"
  | "street1_ASC"
  | "street1_DESC"
  | "street2_ASC"
  | "street2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "country_ASC"
  | "country_DESC"
  | "postal_code_ASC"
  | "postal_code_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BottomSizeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "value_ASC"
  | "value_DESC"
  | "waist_ASC"
  | "waist_DESC"
  | "rise_ASC"
  | "rise_DESC"
  | "hem_ASC"
  | "hem_DESC"
  | "inseam_ASC"
  | "inseam_DESC";

export type BrandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "brandCode_ASC"
  | "brandCode_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isPrimaryBrand_ASC"
  | "isPrimaryBrand_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "name_ASC"
  | "name_DESC"
  | "designer_ASC"
  | "designer_DESC"
  | "basedIn_ASC"
  | "basedIn_DESC"
  | "since_ASC"
  | "since_DESC"
  | "tier_ASC"
  | "tier_DESC"
  | "published_ASC"
  | "published_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "websiteUrl_ASC"
  | "websiteUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionPlacement = "Homepage";

export type CollectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "title_ASC"
  | "title_DESC"
  | "subTitle_ASC"
  | "subTitle_DESC"
  | "published_ASC"
  | "published_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ColorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "colorCode_ASC"
  | "colorCode_DESC"
  | "hexCode_ASC"
  | "hexCode_DESC";

export type CustomerAdmissionsDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "inServiceableZipcode_ASC"
  | "inServiceableZipcode_DESC"
  | "admissable_ASC"
  | "admissable_DESC"
  | "inAdmissableReason_ASC"
  | "inAdmissableReason_DESC"
  | "allAccessEnabled_ASC"
  | "allAccessEnabled_DESC"
  | "authorizationsCount_ASC"
  | "authorizationsCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "authorizationWindowClosesAt_ASC"
  | "authorizationWindowClosesAt_DESC";

export type CustomerDetailOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "height_ASC"
  | "height_DESC"
  | "bodyType_ASC"
  | "bodyType_DESC"
  | "averageTopSize_ASC"
  | "averageTopSize_DESC"
  | "averageWaistSize_ASC"
  | "averageWaistSize_DESC"
  | "averagePantLength_ASC"
  | "averagePantLength_DESC"
  | "preferredPronouns_ASC"
  | "preferredPronouns_DESC"
  | "profession_ASC"
  | "profession_DESC"
  | "partyFrequency_ASC"
  | "partyFrequency_DESC"
  | "travelFrequency_ASC"
  | "travelFrequency_DESC"
  | "shoppingFrequency_ASC"
  | "shoppingFrequency_DESC"
  | "averageSpend_ASC"
  | "averageSpend_DESC"
  | "style_ASC"
  | "style_DESC"
  | "commuteStyle_ASC"
  | "commuteStyle_DESC"
  | "phoneOS_ASC"
  | "phoneOS_DESC"
  | "insureShipment_ASC"
  | "insureShipment_DESC"
  | "instagramHandle_ASC"
  | "instagramHandle_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerMembershipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subscriptionId_ASC"
  | "subscriptionId_DESC"
  | "giftId_ASC"
  | "giftId_DESC";

export type ExternalShopifyIntegrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "shopName_ASC"
  | "shopName_DESC"
  | "enabled_ASC"
  | "enabled_DESC"
  | "accessToken_ASC"
  | "accessToken_DESC"
  | "nonce_ASC"
  | "nonce_DESC";

export type InterestedUserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "zipcode_ASC"
  | "zipcode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "image_ASC"
  | "image_DESC"
  | "trackingNumber_ASC"
  | "trackingNumber_DESC"
  | "trackingURL_ASC"
  | "trackingURL_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "company_ASC"
  | "company_DESC"
  | "description_ASC"
  | "description_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "country_ASC"
  | "country_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zipCode_ASC"
  | "zipCode_DESC"
  | "locationType_ASC"
  | "locationType_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PackageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "transactionID_ASC"
  | "transactionID_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "cost_ASC"
  | "cost_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentPlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "planID_ASC"
  | "planID_DESC"
  | "status_ASC"
  | "status_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "itemCount_ASC"
  | "itemCount_DESC"
  | "tagline_ASC"
  | "tagline_DESC"
  | "tier_ASC"
  | "tier_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PhysicalProductPriceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "buyUsedEnabled_ASC"
  | "buyUsedEnabled_DESC"
  | "buyUsedPrice_ASC"
  | "buyUsedPrice_DESC";

export type ProductMaterialCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "lifeExpectancy_ASC"
  | "lifeExpectancy_DESC";

export type ProductModelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "height_ASC"
  | "height_DESC";

export type ProductNotificationType = "Restock" | "AvailableForPurchase";

export type ProductNotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "shouldNotify_ASC"
  | "shouldNotify_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "priceCurrency_ASC"
  | "priceCurrency_DESC"
  | "productID_ASC"
  | "productID_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "url_ASC"
  | "url_DESC";

export type ProductSeasonOrderByInput = "id_ASC" | "id_DESC";

export type ProductTierOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "tier_ASC"
  | "tier_DESC"
  | "price_ASC"
  | "price_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuestionType = "MultipleChoice" | "FreeResponse";

export type Rating = "Disliked" | "Ok" | "Loved";

export type ProductVariantFeedbackQuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "question_ASC"
  | "question_DESC"
  | "type_ASC"
  | "type_DESC";

export type ProductVariantFeedbackOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isCompleted_ASC"
  | "isCompleted_DESC";

export type ProductVariantPriceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "retailPrice_ASC"
  | "retailPrice_DESC";

export type ProductVariantWantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isFulfilled_ASC"
  | "isFulfilled_DESC";

export type RecentlyViewedProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "viewCount_ASC"
  | "viewCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReservationFeedbackOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "comment_ASC"
  | "comment_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "respondedAt_ASC"
  | "respondedAt_DESC";

export type ReservationReceiptOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SeasonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "year_ASC"
  | "year_DESC"
  | "seasonCode_ASC"
  | "seasonCode_DESC";

export type ShippingMethodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "displayText_ASC"
  | "displayText_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShopifyProductVariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "externalId_ASC"
  | "externalId_DESC"
  | "cachedPrice_ASC"
  | "cachedPrice_DESC"
  | "cachedAvailableForSale_ASC"
  | "cachedAvailableForSale_DESC"
  | "cacheExpiresAt_ASC"
  | "cacheExpiresAt_DESC";

export type StylePreferencesOrderByInput = "id_ASC" | "id_DESC";

export type SyncTimingType = "Drip" | "Next";

export type SyncTimingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "syncedAt_ASC"
  | "syncedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopSizeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "letter_ASC"
  | "letter_DESC"
  | "sleeve_ASC"
  | "sleeve_DESC"
  | "shoulder_ASC"
  | "shoulder_DESC"
  | "chest_ASC"
  | "chest_DESC"
  | "neck_ASC"
  | "neck_DESC"
  | "length_ASC"
  | "length_DESC";

export type UTMDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "source_ASC"
  | "source_DESC"
  | "medium_ASC"
  | "medium_DESC"
  | "campaign_ASC"
  | "campaign_DESC"
  | "term_ASC"
  | "term_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserPushNotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActiveAdminUserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PushNotificationReceiptWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  route?: Maybe<String>;
  route_not?: Maybe<String>;
  route_in?: Maybe<String[] | String>;
  route_not_in?: Maybe<String[] | String>;
  route_lt?: Maybe<String>;
  route_lte?: Maybe<String>;
  route_gt?: Maybe<String>;
  route_gte?: Maybe<String>;
  route_contains?: Maybe<String>;
  route_not_contains?: Maybe<String>;
  route_starts_with?: Maybe<String>;
  route_not_starts_with?: Maybe<String>;
  route_ends_with?: Maybe<String>;
  route_not_ends_with?: Maybe<String>;
  screen?: Maybe<String>;
  screen_not?: Maybe<String>;
  screen_in?: Maybe<String[] | String>;
  screen_not_in?: Maybe<String[] | String>;
  screen_lt?: Maybe<String>;
  screen_lte?: Maybe<String>;
  screen_gt?: Maybe<String>;
  screen_gte?: Maybe<String>;
  screen_contains?: Maybe<String>;
  screen_not_contains?: Maybe<String>;
  screen_starts_with?: Maybe<String>;
  screen_not_starts_with?: Maybe<String>;
  screen_ends_with?: Maybe<String>;
  screen_not_ends_with?: Maybe<String>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  interest?: Maybe<String>;
  interest_not?: Maybe<String>;
  interest_in?: Maybe<String[] | String>;
  interest_not_in?: Maybe<String[] | String>;
  interest_lt?: Maybe<String>;
  interest_lte?: Maybe<String>;
  interest_gt?: Maybe<String>;
  interest_gte?: Maybe<String>;
  interest_contains?: Maybe<String>;
  interest_not_contains?: Maybe<String>;
  interest_starts_with?: Maybe<String>;
  interest_not_starts_with?: Maybe<String>;
  interest_ends_with?: Maybe<String>;
  interest_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  recordID?: Maybe<String>;
  recordID_not?: Maybe<String>;
  recordID_in?: Maybe<String[] | String>;
  recordID_not_in?: Maybe<String[] | String>;
  recordID_lt?: Maybe<String>;
  recordID_lte?: Maybe<String>;
  recordID_gt?: Maybe<String>;
  recordID_gte?: Maybe<String>;
  recordID_contains?: Maybe<String>;
  recordID_not_contains?: Maybe<String>;
  recordID_starts_with?: Maybe<String>;
  recordID_not_starts_with?: Maybe<String>;
  recordID_ends_with?: Maybe<String>;
  recordID_not_ends_with?: Maybe<String>;
  recordSlug?: Maybe<String>;
  recordSlug_not?: Maybe<String>;
  recordSlug_in?: Maybe<String[] | String>;
  recordSlug_not_in?: Maybe<String[] | String>;
  recordSlug_lt?: Maybe<String>;
  recordSlug_lte?: Maybe<String>;
  recordSlug_gt?: Maybe<String>;
  recordSlug_gte?: Maybe<String>;
  recordSlug_contains?: Maybe<String>;
  recordSlug_not_contains?: Maybe<String>;
  recordSlug_starts_with?: Maybe<String>;
  recordSlug_not_starts_with?: Maybe<String>;
  recordSlug_ends_with?: Maybe<String>;
  recordSlug_not_ends_with?: Maybe<String>;
  notificationKey?: Maybe<String>;
  notificationKey_not?: Maybe<String>;
  notificationKey_in?: Maybe<String[] | String>;
  notificationKey_not_in?: Maybe<String[] | String>;
  notificationKey_lt?: Maybe<String>;
  notificationKey_lte?: Maybe<String>;
  notificationKey_gt?: Maybe<String>;
  notificationKey_gte?: Maybe<String>;
  notificationKey_contains?: Maybe<String>;
  notificationKey_not_contains?: Maybe<String>;
  notificationKey_starts_with?: Maybe<String>;
  notificationKey_not_starts_with?: Maybe<String>;
  notificationKey_ends_with?: Maybe<String>;
  notificationKey_not_ends_with?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
  sentAt_not?: Maybe<DateTimeInput>;
  sentAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_lt?: Maybe<DateTimeInput>;
  sentAt_lte?: Maybe<DateTimeInput>;
  sentAt_gt?: Maybe<DateTimeInput>;
  sentAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    PushNotificationReceiptWhereInput[] | PushNotificationReceiptWhereInput
  >;
  OR?: Maybe<
    PushNotificationReceiptWhereInput[] | PushNotificationReceiptWhereInput
  >;
  NOT?: Maybe<
    PushNotificationReceiptWhereInput[] | PushNotificationReceiptWhereInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  auth0Id?: Maybe<String>;
  auth0Id_not?: Maybe<String>;
  auth0Id_in?: Maybe<String[] | String>;
  auth0Id_not_in?: Maybe<String[] | String>;
  auth0Id_lt?: Maybe<String>;
  auth0Id_lte?: Maybe<String>;
  auth0Id_gt?: Maybe<String>;
  auth0Id_gte?: Maybe<String>;
  auth0Id_contains?: Maybe<String>;
  auth0Id_not_contains?: Maybe<String>;
  auth0Id_starts_with?: Maybe<String>;
  auth0Id_not_starts_with?: Maybe<String>;
  auth0Id_ends_with?: Maybe<String>;
  auth0Id_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotificationStatus_not?: Maybe<PushNotificationStatus>;
  pushNotificationStatus_in?: Maybe<
    PushNotificationStatus[] | PushNotificationStatus
  >;
  pushNotificationStatus_not_in?: Maybe<
    PushNotificationStatus[] | PushNotificationStatus
  >;
  pushNotifications_every?: Maybe<PushNotificationReceiptWhereInput>;
  pushNotifications_some?: Maybe<PushNotificationReceiptWhereInput>;
  pushNotifications_none?: Maybe<PushNotificationReceiptWhereInput>;
  emails_every?: Maybe<EmailReceiptWhereInput>;
  emails_some?: Maybe<EmailReceiptWhereInput>;
  emails_none?: Maybe<EmailReceiptWhereInput>;
  sendSystemEmails?: Maybe<Boolean>;
  sendSystemEmails_not?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationWhereInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationStatus_not?: Maybe<UserVerificationStatus>;
  verificationStatus_in?: Maybe<
    UserVerificationStatus[] | UserVerificationStatus
  >;
  verificationStatus_not_in?: Maybe<
    UserVerificationStatus[] | UserVerificationStatus
  >;
  verificationMethod?: Maybe<UserVerificationMethod>;
  verificationMethod_not?: Maybe<UserVerificationMethod>;
  verificationMethod_in?: Maybe<
    UserVerificationMethod[] | UserVerificationMethod
  >;
  verificationMethod_not_in?: Maybe<
    UserVerificationMethod[] | UserVerificationMethod
  >;
  smsReceipts_every?: Maybe<SmsReceiptWhereInput>;
  smsReceipts_some?: Maybe<SmsReceiptWhereInput>;
  smsReceipts_none?: Maybe<SmsReceiptWhereInput>;
  fitPics_every?: Maybe<FitPicWhereInput>;
  fitPics_some?: Maybe<FitPicWhereInput>;
  fitPics_none?: Maybe<FitPicWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface EmailReceiptWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  emailId?: Maybe<EmailId>;
  emailId_not?: Maybe<EmailId>;
  emailId_in?: Maybe<EmailId[] | EmailId>;
  emailId_not_in?: Maybe<EmailId[] | EmailId>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmailReceiptWhereInput[] | EmailReceiptWhereInput>;
  OR?: Maybe<EmailReceiptWhereInput[] | EmailReceiptWhereInput>;
  NOT?: Maybe<EmailReceiptWhereInput[] | EmailReceiptWhereInput>;
}

export interface UserPushNotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  interests_every?: Maybe<UserPushNotificationInterestWhereInput>;
  interests_some?: Maybe<UserPushNotificationInterestWhereInput>;
  interests_none?: Maybe<UserPushNotificationInterestWhereInput>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  history_every?: Maybe<PushNotificationReceiptWhereInput>;
  history_some?: Maybe<PushNotificationReceiptWhereInput>;
  history_none?: Maybe<PushNotificationReceiptWhereInput>;
  AND?: Maybe<
    UserPushNotificationWhereInput[] | UserPushNotificationWhereInput
  >;
  OR?: Maybe<UserPushNotificationWhereInput[] | UserPushNotificationWhereInput>;
  NOT?: Maybe<
    UserPushNotificationWhereInput[] | UserPushNotificationWhereInput
  >;
}

export interface UserPushNotificationInterestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<UserPushNotificationInterestType>;
  type_not?: Maybe<UserPushNotificationInterestType>;
  type_in?: Maybe<
    UserPushNotificationInterestType[] | UserPushNotificationInterestType
  >;
  type_not_in?: Maybe<
    UserPushNotificationInterestType[] | UserPushNotificationInterestType
  >;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  AND?: Maybe<
    | UserPushNotificationInterestWhereInput[]
    | UserPushNotificationInterestWhereInput
  >;
  OR?: Maybe<
    | UserPushNotificationInterestWhereInput[]
    | UserPushNotificationInterestWhereInput
  >;
  NOT?: Maybe<
    | UserPushNotificationInterestWhereInput[]
    | UserPushNotificationInterestWhereInput
  >;
}

export interface SmsReceiptWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  externalId?: Maybe<String>;
  externalId_not?: Maybe<String>;
  externalId_in?: Maybe<String[] | String>;
  externalId_not_in?: Maybe<String[] | String>;
  externalId_lt?: Maybe<String>;
  externalId_lte?: Maybe<String>;
  externalId_gt?: Maybe<String>;
  externalId_gte?: Maybe<String>;
  externalId_contains?: Maybe<String>;
  externalId_not_contains?: Maybe<String>;
  externalId_starts_with?: Maybe<String>;
  externalId_not_starts_with?: Maybe<String>;
  externalId_ends_with?: Maybe<String>;
  externalId_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  status?: Maybe<SmsStatus>;
  status_not?: Maybe<SmsStatus>;
  status_in?: Maybe<SmsStatus[] | SmsStatus>;
  status_not_in?: Maybe<SmsStatus[] | SmsStatus>;
  smsId?: Maybe<String>;
  smsId_not?: Maybe<String>;
  smsId_in?: Maybe<String[] | String>;
  smsId_not_in?: Maybe<String[] | String>;
  smsId_lt?: Maybe<String>;
  smsId_lte?: Maybe<String>;
  smsId_gt?: Maybe<String>;
  smsId_gte?: Maybe<String>;
  smsId_contains?: Maybe<String>;
  smsId_not_contains?: Maybe<String>;
  smsId_starts_with?: Maybe<String>;
  smsId_not_starts_with?: Maybe<String>;
  smsId_ends_with?: Maybe<String>;
  smsId_not_ends_with?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
  sentAt_not?: Maybe<DateTimeInput>;
  sentAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_lt?: Maybe<DateTimeInput>;
  sentAt_lte?: Maybe<DateTimeInput>;
  sentAt_gt?: Maybe<DateTimeInput>;
  sentAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SmsReceiptWhereInput[] | SmsReceiptWhereInput>;
  OR?: Maybe<SmsReceiptWhereInput[] | SmsReceiptWhereInput>;
  NOT?: Maybe<SmsReceiptWhereInput[] | SmsReceiptWhereInput>;
}

export interface FitPicWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  image?: Maybe<ImageWhereInput>;
  includeInstagramHandle?: Maybe<Boolean>;
  includeInstagramHandle_not?: Maybe<Boolean>;
  location?: Maybe<LocationWhereInput>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  reports_every?: Maybe<FitPicReportWhereInput>;
  reports_some?: Maybe<FitPicReportWhereInput>;
  reports_none?: Maybe<FitPicReportWhereInput>;
  status?: Maybe<FitPicStatus>;
  status_not?: Maybe<FitPicStatus>;
  status_in?: Maybe<FitPicStatus[] | FitPicStatus>;
  status_not_in?: Maybe<FitPicStatus[] | FitPicStatus>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FitPicWhereInput[] | FitPicWhereInput>;
  OR?: Maybe<FitPicWhereInput[] | FitPicWhereInput>;
  NOT?: Maybe<FitPicWhereInput[] | FitPicWhereInput>;
}

export interface ImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  width?: Maybe<Int>;
  width_not?: Maybe<Int>;
  width_in?: Maybe<Int[] | Int>;
  width_not_in?: Maybe<Int[] | Int>;
  width_lt?: Maybe<Int>;
  width_lte?: Maybe<Int>;
  width_gt?: Maybe<Int>;
  width_gte?: Maybe<Int>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  OR?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  NOT?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface LocationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  locationType_not?: Maybe<LocationType>;
  locationType_in?: Maybe<LocationType[] | LocationType>;
  locationType_not_in?: Maybe<LocationType[] | LocationType>;
  user?: Maybe<UserWhereInput>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  physicalProducts_every?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_some?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_none?: Maybe<PhysicalProductWhereInput>;
  shippingOptions_every?: Maybe<ShippingOptionWhereInput>;
  shippingOptions_some?: Maybe<ShippingOptionWhereInput>;
  shippingOptions_none?: Maybe<ShippingOptionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  OR?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  NOT?: Maybe<LocationWhereInput[] | LocationWhereInput>;
}

export interface PhysicalProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seasonsUID?: Maybe<String>;
  seasonsUID_not?: Maybe<String>;
  seasonsUID_in?: Maybe<String[] | String>;
  seasonsUID_not_in?: Maybe<String[] | String>;
  seasonsUID_lt?: Maybe<String>;
  seasonsUID_lte?: Maybe<String>;
  seasonsUID_gt?: Maybe<String>;
  seasonsUID_gte?: Maybe<String>;
  seasonsUID_contains?: Maybe<String>;
  seasonsUID_not_contains?: Maybe<String>;
  seasonsUID_starts_with?: Maybe<String>;
  seasonsUID_not_starts_with?: Maybe<String>;
  seasonsUID_ends_with?: Maybe<String>;
  seasonsUID_not_ends_with?: Maybe<String>;
  location?: Maybe<LocationWhereInput>;
  productVariant?: Maybe<ProductVariantWhereInput>;
  inventoryStatus?: Maybe<InventoryStatus>;
  inventoryStatus_not?: Maybe<InventoryStatus>;
  inventoryStatus_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  inventoryStatus_not_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  productStatus_not?: Maybe<PhysicalProductStatus>;
  productStatus_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  productStatus_not_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadMethod_not?: Maybe<PhysicalProductOffloadMethod>;
  offloadMethod_in?: Maybe<
    PhysicalProductOffloadMethod[] | PhysicalProductOffloadMethod
  >;
  offloadMethod_not_in?: Maybe<
    PhysicalProductOffloadMethod[] | PhysicalProductOffloadMethod
  >;
  offloadNotes?: Maybe<String>;
  offloadNotes_not?: Maybe<String>;
  offloadNotes_in?: Maybe<String[] | String>;
  offloadNotes_not_in?: Maybe<String[] | String>;
  offloadNotes_lt?: Maybe<String>;
  offloadNotes_lte?: Maybe<String>;
  offloadNotes_gt?: Maybe<String>;
  offloadNotes_gte?: Maybe<String>;
  offloadNotes_contains?: Maybe<String>;
  offloadNotes_not_contains?: Maybe<String>;
  offloadNotes_starts_with?: Maybe<String>;
  offloadNotes_not_starts_with?: Maybe<String>;
  offloadNotes_ends_with?: Maybe<String>;
  offloadNotes_not_ends_with?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  sequenceNumber_not?: Maybe<Int>;
  sequenceNumber_in?: Maybe<Int[] | Int>;
  sequenceNumber_not_in?: Maybe<Int[] | Int>;
  sequenceNumber_lt?: Maybe<Int>;
  sequenceNumber_lte?: Maybe<Int>;
  sequenceNumber_gt?: Maybe<Int>;
  sequenceNumber_gte?: Maybe<Int>;
  warehouseLocation?: Maybe<WarehouseLocationWhereInput>;
  barcoded?: Maybe<Boolean>;
  barcoded_not?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateOrdered_not?: Maybe<DateTimeInput>;
  dateOrdered_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOrdered_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOrdered_lt?: Maybe<DateTimeInput>;
  dateOrdered_lte?: Maybe<DateTimeInput>;
  dateOrdered_gt?: Maybe<DateTimeInput>;
  dateOrdered_gte?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  dateReceived_not?: Maybe<DateTimeInput>;
  dateReceived_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateReceived_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateReceived_lt?: Maybe<DateTimeInput>;
  dateReceived_lte?: Maybe<DateTimeInput>;
  dateReceived_gt?: Maybe<DateTimeInput>;
  dateReceived_gte?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  unitCost_not?: Maybe<Float>;
  unitCost_in?: Maybe<Float[] | Float>;
  unitCost_not_in?: Maybe<Float[] | Float>;
  unitCost_lt?: Maybe<Float>;
  unitCost_lte?: Maybe<Float>;
  unitCost_gt?: Maybe<Float>;
  unitCost_gte?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceWhereInput>;
  reports_every?: Maybe<PhysicalProductQualityReportWhereInput>;
  reports_some?: Maybe<PhysicalProductQualityReportWhereInput>;
  reports_none?: Maybe<PhysicalProductQualityReportWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PhysicalProductWhereInput[] | PhysicalProductWhereInput>;
  OR?: Maybe<PhysicalProductWhereInput[] | PhysicalProductWhereInput>;
  NOT?: Maybe<PhysicalProductWhereInput[] | PhysicalProductWhereInput>;
}

export interface ProductVariantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  displayShort?: Maybe<String>;
  displayShort_not?: Maybe<String>;
  displayShort_in?: Maybe<String[] | String>;
  displayShort_not_in?: Maybe<String[] | String>;
  displayShort_lt?: Maybe<String>;
  displayShort_lte?: Maybe<String>;
  displayShort_gt?: Maybe<String>;
  displayShort_gte?: Maybe<String>;
  displayShort_contains?: Maybe<String>;
  displayShort_not_contains?: Maybe<String>;
  displayShort_starts_with?: Maybe<String>;
  displayShort_not_starts_with?: Maybe<String>;
  displayShort_ends_with?: Maybe<String>;
  displayShort_not_ends_with?: Maybe<String>;
  color?: Maybe<ColorWhereInput>;
  internalSize?: Maybe<SizeWhereInput>;
  manufacturerSizes_every?: Maybe<SizeWhereInput>;
  manufacturerSizes_some?: Maybe<SizeWhereInput>;
  manufacturerSizes_none?: Maybe<SizeWhereInput>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  productID?: Maybe<String>;
  productID_not?: Maybe<String>;
  productID_in?: Maybe<String[] | String>;
  productID_not_in?: Maybe<String[] | String>;
  productID_lt?: Maybe<String>;
  productID_lte?: Maybe<String>;
  productID_gt?: Maybe<String>;
  productID_gte?: Maybe<String>;
  productID_contains?: Maybe<String>;
  productID_not_contains?: Maybe<String>;
  productID_starts_with?: Maybe<String>;
  productID_not_starts_with?: Maybe<String>;
  productID_ends_with?: Maybe<String>;
  productID_not_ends_with?: Maybe<String>;
  product?: Maybe<ProductWhereInput>;
  retailPrice?: Maybe<Float>;
  retailPrice_not?: Maybe<Float>;
  retailPrice_in?: Maybe<Float[] | Float>;
  retailPrice_not_in?: Maybe<Float[] | Float>;
  retailPrice_lt?: Maybe<Float>;
  retailPrice_lte?: Maybe<Float>;
  retailPrice_gt?: Maybe<Float>;
  retailPrice_gte?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceWhereInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantWhereInput>;
  physicalProducts_every?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_some?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_none?: Maybe<PhysicalProductWhereInput>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reservable_not?: Maybe<Int>;
  reservable_in?: Maybe<Int[] | Int>;
  reservable_not_in?: Maybe<Int[] | Int>;
  reservable_lt?: Maybe<Int>;
  reservable_lte?: Maybe<Int>;
  reservable_gt?: Maybe<Int>;
  reservable_gte?: Maybe<Int>;
  reserved?: Maybe<Int>;
  reserved_not?: Maybe<Int>;
  reserved_in?: Maybe<Int[] | Int>;
  reserved_not_in?: Maybe<Int[] | Int>;
  reserved_lt?: Maybe<Int>;
  reserved_lte?: Maybe<Int>;
  reserved_gt?: Maybe<Int>;
  reserved_gte?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  nonReservable_not?: Maybe<Int>;
  nonReservable_in?: Maybe<Int[] | Int>;
  nonReservable_not_in?: Maybe<Int[] | Int>;
  nonReservable_lt?: Maybe<Int>;
  nonReservable_lte?: Maybe<Int>;
  nonReservable_gt?: Maybe<Int>;
  nonReservable_gte?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  offloaded_not?: Maybe<Int>;
  offloaded_in?: Maybe<Int[] | Int>;
  offloaded_not_in?: Maybe<Int[] | Int>;
  offloaded_lt?: Maybe<Int>;
  offloaded_lte?: Maybe<Int>;
  offloaded_gt?: Maybe<Int>;
  offloaded_gte?: Maybe<Int>;
  stored?: Maybe<Int>;
  stored_not?: Maybe<Int>;
  stored_in?: Maybe<Int[] | Int>;
  stored_not_in?: Maybe<Int[] | Int>;
  stored_lt?: Maybe<Int>;
  stored_lte?: Maybe<Int>;
  stored_gt?: Maybe<Int>;
  stored_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductVariantWhereInput[] | ProductVariantWhereInput>;
  OR?: Maybe<ProductVariantWhereInput[] | ProductVariantWhereInput>;
  NOT?: Maybe<ProductVariantWhereInput[] | ProductVariantWhereInput>;
}

export interface ColorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  colorCode?: Maybe<String>;
  colorCode_not?: Maybe<String>;
  colorCode_in?: Maybe<String[] | String>;
  colorCode_not_in?: Maybe<String[] | String>;
  colorCode_lt?: Maybe<String>;
  colorCode_lte?: Maybe<String>;
  colorCode_gt?: Maybe<String>;
  colorCode_gte?: Maybe<String>;
  colorCode_contains?: Maybe<String>;
  colorCode_not_contains?: Maybe<String>;
  colorCode_starts_with?: Maybe<String>;
  colorCode_not_starts_with?: Maybe<String>;
  colorCode_ends_with?: Maybe<String>;
  colorCode_not_ends_with?: Maybe<String>;
  hexCode?: Maybe<String>;
  hexCode_not?: Maybe<String>;
  hexCode_in?: Maybe<String[] | String>;
  hexCode_not_in?: Maybe<String[] | String>;
  hexCode_lt?: Maybe<String>;
  hexCode_lte?: Maybe<String>;
  hexCode_gt?: Maybe<String>;
  hexCode_gte?: Maybe<String>;
  hexCode_contains?: Maybe<String>;
  hexCode_not_contains?: Maybe<String>;
  hexCode_starts_with?: Maybe<String>;
  hexCode_not_starts_with?: Maybe<String>;
  hexCode_ends_with?: Maybe<String>;
  hexCode_not_ends_with?: Maybe<String>;
  productVariants_every?: Maybe<ProductVariantWhereInput>;
  productVariants_some?: Maybe<ProductVariantWhereInput>;
  productVariants_none?: Maybe<ProductVariantWhereInput>;
  AND?: Maybe<ColorWhereInput[] | ColorWhereInput>;
  OR?: Maybe<ColorWhereInput[] | ColorWhereInput>;
  NOT?: Maybe<ColorWhereInput[] | ColorWhereInput>;
}

export interface SizeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  productType?: Maybe<ProductType>;
  productType_not?: Maybe<ProductType>;
  productType_in?: Maybe<ProductType[] | ProductType>;
  productType_not_in?: Maybe<ProductType[] | ProductType>;
  top?: Maybe<TopSizeWhereInput>;
  bottom?: Maybe<BottomSizeWhereInput>;
  display?: Maybe<String>;
  display_not?: Maybe<String>;
  display_in?: Maybe<String[] | String>;
  display_not_in?: Maybe<String[] | String>;
  display_lt?: Maybe<String>;
  display_lte?: Maybe<String>;
  display_gt?: Maybe<String>;
  display_gte?: Maybe<String>;
  display_contains?: Maybe<String>;
  display_not_contains?: Maybe<String>;
  display_starts_with?: Maybe<String>;
  display_not_starts_with?: Maybe<String>;
  display_ends_with?: Maybe<String>;
  display_not_ends_with?: Maybe<String>;
  AND?: Maybe<SizeWhereInput[] | SizeWhereInput>;
  OR?: Maybe<SizeWhereInput[] | SizeWhereInput>;
  NOT?: Maybe<SizeWhereInput[] | SizeWhereInput>;
}

export interface TopSizeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  letter?: Maybe<LetterSize>;
  letter_not?: Maybe<LetterSize>;
  letter_in?: Maybe<LetterSize[] | LetterSize>;
  letter_not_in?: Maybe<LetterSize[] | LetterSize>;
  sleeve?: Maybe<Float>;
  sleeve_not?: Maybe<Float>;
  sleeve_in?: Maybe<Float[] | Float>;
  sleeve_not_in?: Maybe<Float[] | Float>;
  sleeve_lt?: Maybe<Float>;
  sleeve_lte?: Maybe<Float>;
  sleeve_gt?: Maybe<Float>;
  sleeve_gte?: Maybe<Float>;
  shoulder?: Maybe<Float>;
  shoulder_not?: Maybe<Float>;
  shoulder_in?: Maybe<Float[] | Float>;
  shoulder_not_in?: Maybe<Float[] | Float>;
  shoulder_lt?: Maybe<Float>;
  shoulder_lte?: Maybe<Float>;
  shoulder_gt?: Maybe<Float>;
  shoulder_gte?: Maybe<Float>;
  chest?: Maybe<Float>;
  chest_not?: Maybe<Float>;
  chest_in?: Maybe<Float[] | Float>;
  chest_not_in?: Maybe<Float[] | Float>;
  chest_lt?: Maybe<Float>;
  chest_lte?: Maybe<Float>;
  chest_gt?: Maybe<Float>;
  chest_gte?: Maybe<Float>;
  neck?: Maybe<Float>;
  neck_not?: Maybe<Float>;
  neck_in?: Maybe<Float[] | Float>;
  neck_not_in?: Maybe<Float[] | Float>;
  neck_lt?: Maybe<Float>;
  neck_lte?: Maybe<Float>;
  neck_gt?: Maybe<Float>;
  neck_gte?: Maybe<Float>;
  length?: Maybe<Float>;
  length_not?: Maybe<Float>;
  length_in?: Maybe<Float[] | Float>;
  length_not_in?: Maybe<Float[] | Float>;
  length_lt?: Maybe<Float>;
  length_lte?: Maybe<Float>;
  length_gt?: Maybe<Float>;
  length_gte?: Maybe<Float>;
  AND?: Maybe<TopSizeWhereInput[] | TopSizeWhereInput>;
  OR?: Maybe<TopSizeWhereInput[] | TopSizeWhereInput>;
  NOT?: Maybe<TopSizeWhereInput[] | TopSizeWhereInput>;
}

export interface BottomSizeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<BottomSizeType>;
  type_not?: Maybe<BottomSizeType>;
  type_in?: Maybe<BottomSizeType[] | BottomSizeType>;
  type_not_in?: Maybe<BottomSizeType[] | BottomSizeType>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  waist?: Maybe<Float>;
  waist_not?: Maybe<Float>;
  waist_in?: Maybe<Float[] | Float>;
  waist_not_in?: Maybe<Float[] | Float>;
  waist_lt?: Maybe<Float>;
  waist_lte?: Maybe<Float>;
  waist_gt?: Maybe<Float>;
  waist_gte?: Maybe<Float>;
  rise?: Maybe<Float>;
  rise_not?: Maybe<Float>;
  rise_in?: Maybe<Float[] | Float>;
  rise_not_in?: Maybe<Float[] | Float>;
  rise_lt?: Maybe<Float>;
  rise_lte?: Maybe<Float>;
  rise_gt?: Maybe<Float>;
  rise_gte?: Maybe<Float>;
  hem?: Maybe<Float>;
  hem_not?: Maybe<Float>;
  hem_in?: Maybe<Float[] | Float>;
  hem_not_in?: Maybe<Float[] | Float>;
  hem_lt?: Maybe<Float>;
  hem_lte?: Maybe<Float>;
  hem_gt?: Maybe<Float>;
  hem_gte?: Maybe<Float>;
  inseam?: Maybe<Float>;
  inseam_not?: Maybe<Float>;
  inseam_in?: Maybe<Float[] | Float>;
  inseam_not_in?: Maybe<Float[] | Float>;
  inseam_lt?: Maybe<Float>;
  inseam_lte?: Maybe<Float>;
  inseam_gt?: Maybe<Float>;
  inseam_gte?: Maybe<Float>;
  AND?: Maybe<BottomSizeWhereInput[] | BottomSizeWhereInput>;
  OR?: Maybe<BottomSizeWhereInput[] | BottomSizeWhereInput>;
  NOT?: Maybe<BottomSizeWhereInput[] | BottomSizeWhereInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  architecture_not?: Maybe<ProductArchitecture>;
  architecture_in?: Maybe<ProductArchitecture[] | ProductArchitecture>;
  architecture_not_in?: Maybe<ProductArchitecture[] | ProductArchitecture>;
  brand?: Maybe<BrandWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  color?: Maybe<ColorWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  externalURL?: Maybe<String>;
  externalURL_not?: Maybe<String>;
  externalURL_in?: Maybe<String[] | String>;
  externalURL_not_in?: Maybe<String[] | String>;
  externalURL_lt?: Maybe<String>;
  externalURL_lte?: Maybe<String>;
  externalURL_gt?: Maybe<String>;
  externalURL_gte?: Maybe<String>;
  externalURL_contains?: Maybe<String>;
  externalURL_not_contains?: Maybe<String>;
  externalURL_starts_with?: Maybe<String>;
  externalURL_not_starts_with?: Maybe<String>;
  externalURL_ends_with?: Maybe<String>;
  externalURL_not_ends_with?: Maybe<String>;
  functions_every?: Maybe<ProductFunctionWhereInput>;
  functions_some?: Maybe<ProductFunctionWhereInput>;
  functions_none?: Maybe<ProductFunctionWhereInput>;
  buyNewEnabled?: Maybe<Boolean>;
  buyNewEnabled_not?: Maybe<Boolean>;
  images_every?: Maybe<ImageWhereInput>;
  images_some?: Maybe<ImageWhereInput>;
  images_none?: Maybe<ImageWhereInput>;
  materialCategory?: Maybe<ProductMaterialCategoryWhereInput>;
  model?: Maybe<ProductModelWhereInput>;
  modelHeight?: Maybe<Int>;
  modelHeight_not?: Maybe<Int>;
  modelHeight_in?: Maybe<Int[] | Int>;
  modelHeight_not_in?: Maybe<Int[] | Int>;
  modelHeight_lt?: Maybe<Int>;
  modelHeight_lte?: Maybe<Int>;
  modelHeight_gt?: Maybe<Int>;
  modelHeight_gte?: Maybe<Int>;
  modelSize?: Maybe<SizeWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  photographyStatus?: Maybe<PhotographyStatus>;
  photographyStatus_not?: Maybe<PhotographyStatus>;
  photographyStatus_in?: Maybe<PhotographyStatus[] | PhotographyStatus>;
  photographyStatus_not_in?: Maybe<PhotographyStatus[] | PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  productFit_not?: Maybe<ProductFit>;
  productFit_in?: Maybe<ProductFit[] | ProductFit>;
  productFit_not_in?: Maybe<ProductFit[] | ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  retailPrice_not?: Maybe<Int>;
  retailPrice_in?: Maybe<Int[] | Int>;
  retailPrice_not_in?: Maybe<Int[] | Int>;
  retailPrice_lt?: Maybe<Int>;
  retailPrice_lte?: Maybe<Int>;
  retailPrice_gt?: Maybe<Int>;
  retailPrice_gte?: Maybe<Int>;
  season?: Maybe<ProductSeasonWhereInput>;
  secondaryColor?: Maybe<ColorWhereInput>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  status_not?: Maybe<ProductStatus>;
  status_in?: Maybe<ProductStatus[] | ProductStatus>;
  status_not_in?: Maybe<ProductStatus[] | ProductStatus>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  tier?: Maybe<ProductTierWhereInput>;
  type?: Maybe<ProductType>;
  type_not?: Maybe<ProductType>;
  type_in?: Maybe<ProductType[] | ProductType>;
  type_not_in?: Maybe<ProductType[] | ProductType>;
  variants_every?: Maybe<ProductVariantWhereInput>;
  variants_some?: Maybe<ProductVariantWhereInput>;
  variants_none?: Maybe<ProductVariantWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface BrandWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  brandCode?: Maybe<String>;
  brandCode_not?: Maybe<String>;
  brandCode_in?: Maybe<String[] | String>;
  brandCode_not_in?: Maybe<String[] | String>;
  brandCode_lt?: Maybe<String>;
  brandCode_lte?: Maybe<String>;
  brandCode_gt?: Maybe<String>;
  brandCode_gte?: Maybe<String>;
  brandCode_contains?: Maybe<String>;
  brandCode_not_contains?: Maybe<String>;
  brandCode_starts_with?: Maybe<String>;
  brandCode_not_starts_with?: Maybe<String>;
  brandCode_ends_with?: Maybe<String>;
  brandCode_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  isPrimaryBrand_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  designer?: Maybe<String>;
  designer_not?: Maybe<String>;
  designer_in?: Maybe<String[] | String>;
  designer_not_in?: Maybe<String[] | String>;
  designer_lt?: Maybe<String>;
  designer_lte?: Maybe<String>;
  designer_gt?: Maybe<String>;
  designer_gte?: Maybe<String>;
  designer_contains?: Maybe<String>;
  designer_not_contains?: Maybe<String>;
  designer_starts_with?: Maybe<String>;
  designer_not_starts_with?: Maybe<String>;
  designer_ends_with?: Maybe<String>;
  designer_not_ends_with?: Maybe<String>;
  basedIn?: Maybe<String>;
  basedIn_not?: Maybe<String>;
  basedIn_in?: Maybe<String[] | String>;
  basedIn_not_in?: Maybe<String[] | String>;
  basedIn_lt?: Maybe<String>;
  basedIn_lte?: Maybe<String>;
  basedIn_gt?: Maybe<String>;
  basedIn_gte?: Maybe<String>;
  basedIn_contains?: Maybe<String>;
  basedIn_not_contains?: Maybe<String>;
  basedIn_starts_with?: Maybe<String>;
  basedIn_not_starts_with?: Maybe<String>;
  basedIn_ends_with?: Maybe<String>;
  basedIn_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  images_every?: Maybe<ImageWhereInput>;
  images_some?: Maybe<ImageWhereInput>;
  images_none?: Maybe<ImageWhereInput>;
  since?: Maybe<DateTimeInput>;
  since_not?: Maybe<DateTimeInput>;
  since_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  since_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  since_lt?: Maybe<DateTimeInput>;
  since_lte?: Maybe<DateTimeInput>;
  since_gt?: Maybe<DateTimeInput>;
  since_gte?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  tier_not?: Maybe<BrandTier>;
  tier_in?: Maybe<BrandTier[] | BrandTier>;
  tier_not_in?: Maybe<BrandTier[] | BrandTier>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  websiteUrl?: Maybe<String>;
  websiteUrl_not?: Maybe<String>;
  websiteUrl_in?: Maybe<String[] | String>;
  websiteUrl_not_in?: Maybe<String[] | String>;
  websiteUrl_lt?: Maybe<String>;
  websiteUrl_lte?: Maybe<String>;
  websiteUrl_gt?: Maybe<String>;
  websiteUrl_gte?: Maybe<String>;
  websiteUrl_contains?: Maybe<String>;
  websiteUrl_not_contains?: Maybe<String>;
  websiteUrl_starts_with?: Maybe<String>;
  websiteUrl_not_starts_with?: Maybe<String>;
  websiteUrl_ends_with?: Maybe<String>;
  websiteUrl_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  externalShopifyIntegration?: Maybe<ExternalShopifyIntegrationWhereInput>;
  AND?: Maybe<BrandWhereInput[] | BrandWhereInput>;
  OR?: Maybe<BrandWhereInput[] | BrandWhereInput>;
  NOT?: Maybe<BrandWhereInput[] | BrandWhereInput>;
}

export interface ExternalShopifyIntegrationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  shopName?: Maybe<String>;
  shopName_not?: Maybe<String>;
  shopName_in?: Maybe<String[] | String>;
  shopName_not_in?: Maybe<String[] | String>;
  shopName_lt?: Maybe<String>;
  shopName_lte?: Maybe<String>;
  shopName_gt?: Maybe<String>;
  shopName_gte?: Maybe<String>;
  shopName_contains?: Maybe<String>;
  shopName_not_contains?: Maybe<String>;
  shopName_starts_with?: Maybe<String>;
  shopName_not_starts_with?: Maybe<String>;
  shopName_ends_with?: Maybe<String>;
  shopName_not_ends_with?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  enabled_not?: Maybe<Boolean>;
  accessToken?: Maybe<String>;
  accessToken_not?: Maybe<String>;
  accessToken_in?: Maybe<String[] | String>;
  accessToken_not_in?: Maybe<String[] | String>;
  accessToken_lt?: Maybe<String>;
  accessToken_lte?: Maybe<String>;
  accessToken_gt?: Maybe<String>;
  accessToken_gte?: Maybe<String>;
  accessToken_contains?: Maybe<String>;
  accessToken_not_contains?: Maybe<String>;
  accessToken_starts_with?: Maybe<String>;
  accessToken_not_starts_with?: Maybe<String>;
  accessToken_ends_with?: Maybe<String>;
  accessToken_not_ends_with?: Maybe<String>;
  nonce?: Maybe<String>;
  nonce_not?: Maybe<String>;
  nonce_in?: Maybe<String[] | String>;
  nonce_not_in?: Maybe<String[] | String>;
  nonce_lt?: Maybe<String>;
  nonce_lte?: Maybe<String>;
  nonce_gt?: Maybe<String>;
  nonce_gte?: Maybe<String>;
  nonce_contains?: Maybe<String>;
  nonce_not_contains?: Maybe<String>;
  nonce_starts_with?: Maybe<String>;
  nonce_not_starts_with?: Maybe<String>;
  nonce_ends_with?: Maybe<String>;
  nonce_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | ExternalShopifyIntegrationWhereInput[]
    | ExternalShopifyIntegrationWhereInput
  >;
  OR?: Maybe<
    | ExternalShopifyIntegrationWhereInput[]
    | ExternalShopifyIntegrationWhereInput
  >;
  NOT?: Maybe<
    | ExternalShopifyIntegrationWhereInput[]
    | ExternalShopifyIntegrationWhereInput
  >;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  children_every?: Maybe<CategoryWhereInput>;
  children_some?: Maybe<CategoryWhereInput>;
  children_none?: Maybe<CategoryWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface ProductFunctionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductFunctionWhereInput[] | ProductFunctionWhereInput>;
  OR?: Maybe<ProductFunctionWhereInput[] | ProductFunctionWhereInput>;
  NOT?: Maybe<ProductFunctionWhereInput[] | ProductFunctionWhereInput>;
}

export interface ProductMaterialCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  lifeExpectancy?: Maybe<Float>;
  lifeExpectancy_not?: Maybe<Float>;
  lifeExpectancy_in?: Maybe<Float[] | Float>;
  lifeExpectancy_not_in?: Maybe<Float[] | Float>;
  lifeExpectancy_lt?: Maybe<Float>;
  lifeExpectancy_lte?: Maybe<Float>;
  lifeExpectancy_gt?: Maybe<Float>;
  lifeExpectancy_gte?: Maybe<Float>;
  category?: Maybe<CategoryWhereInput>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<
    ProductMaterialCategoryWhereInput[] | ProductMaterialCategoryWhereInput
  >;
  OR?: Maybe<
    ProductMaterialCategoryWhereInput[] | ProductMaterialCategoryWhereInput
  >;
  NOT?: Maybe<
    ProductMaterialCategoryWhereInput[] | ProductMaterialCategoryWhereInput
  >;
}

export interface ProductModelWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductModelWhereInput[] | ProductModelWhereInput>;
  OR?: Maybe<ProductModelWhereInput[] | ProductModelWhereInput>;
  NOT?: Maybe<ProductModelWhereInput[] | ProductModelWhereInput>;
}

export interface ProductSeasonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  vendorSeason?: Maybe<SeasonWhereInput>;
  internalSeason?: Maybe<SeasonWhereInput>;
  AND?: Maybe<ProductSeasonWhereInput[] | ProductSeasonWhereInput>;
  OR?: Maybe<ProductSeasonWhereInput[] | ProductSeasonWhereInput>;
  NOT?: Maybe<ProductSeasonWhereInput[] | ProductSeasonWhereInput>;
}

export interface SeasonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  seasonCode?: Maybe<SeasonCode>;
  seasonCode_not?: Maybe<SeasonCode>;
  seasonCode_in?: Maybe<SeasonCode[] | SeasonCode>;
  seasonCode_not_in?: Maybe<SeasonCode[] | SeasonCode>;
  AND?: Maybe<SeasonWhereInput[] | SeasonWhereInput>;
  OR?: Maybe<SeasonWhereInput[] | SeasonWhereInput>;
  NOT?: Maybe<SeasonWhereInput[] | SeasonWhereInput>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface ProductTierWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  tier?: Maybe<ProductTierName>;
  tier_not?: Maybe<ProductTierName>;
  tier_in?: Maybe<ProductTierName[] | ProductTierName>;
  tier_not_in?: Maybe<ProductTierName[] | ProductTierName>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductTierWhereInput[] | ProductTierWhereInput>;
  OR?: Maybe<ProductTierWhereInput[] | ProductTierWhereInput>;
  NOT?: Maybe<ProductTierWhereInput[] | ProductTierWhereInput>;
}

export interface ProductVariantPriceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  retailPrice?: Maybe<Float>;
  retailPrice_not?: Maybe<Float>;
  retailPrice_in?: Maybe<Float[] | Float>;
  retailPrice_not_in?: Maybe<Float[] | Float>;
  retailPrice_lt?: Maybe<Float>;
  retailPrice_lte?: Maybe<Float>;
  retailPrice_gt?: Maybe<Float>;
  retailPrice_gte?: Maybe<Float>;
  AND?: Maybe<ProductVariantPriceWhereInput[] | ProductVariantPriceWhereInput>;
  OR?: Maybe<ProductVariantPriceWhereInput[] | ProductVariantPriceWhereInput>;
  NOT?: Maybe<ProductVariantPriceWhereInput[] | ProductVariantPriceWhereInput>;
}

export interface ShopifyProductVariantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  externalId?: Maybe<String>;
  externalId_not?: Maybe<String>;
  externalId_in?: Maybe<String[] | String>;
  externalId_not_in?: Maybe<String[] | String>;
  externalId_lt?: Maybe<String>;
  externalId_lte?: Maybe<String>;
  externalId_gt?: Maybe<String>;
  externalId_gte?: Maybe<String>;
  externalId_contains?: Maybe<String>;
  externalId_not_contains?: Maybe<String>;
  externalId_starts_with?: Maybe<String>;
  externalId_not_starts_with?: Maybe<String>;
  externalId_ends_with?: Maybe<String>;
  externalId_not_ends_with?: Maybe<String>;
  cachedPrice?: Maybe<Float>;
  cachedPrice_not?: Maybe<Float>;
  cachedPrice_in?: Maybe<Float[] | Float>;
  cachedPrice_not_in?: Maybe<Float[] | Float>;
  cachedPrice_lt?: Maybe<Float>;
  cachedPrice_lte?: Maybe<Float>;
  cachedPrice_gt?: Maybe<Float>;
  cachedPrice_gte?: Maybe<Float>;
  cachedAvailableForSale?: Maybe<Boolean>;
  cachedAvailableForSale_not?: Maybe<Boolean>;
  cacheExpiresAt?: Maybe<DateTimeInput>;
  cacheExpiresAt_not?: Maybe<DateTimeInput>;
  cacheExpiresAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  cacheExpiresAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  cacheExpiresAt_lt?: Maybe<DateTimeInput>;
  cacheExpiresAt_lte?: Maybe<DateTimeInput>;
  cacheExpiresAt_gt?: Maybe<DateTimeInput>;
  cacheExpiresAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ShopifyProductVariantWhereInput[] | ShopifyProductVariantWhereInput
  >;
  OR?: Maybe<
    ShopifyProductVariantWhereInput[] | ShopifyProductVariantWhereInput
  >;
  NOT?: Maybe<
    ShopifyProductVariantWhereInput[] | ShopifyProductVariantWhereInput
  >;
}

export interface WarehouseLocationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<WarehouseLocationType>;
  type_not?: Maybe<WarehouseLocationType>;
  type_in?: Maybe<WarehouseLocationType[] | WarehouseLocationType>;
  type_not_in?: Maybe<WarehouseLocationType[] | WarehouseLocationType>;
  barcode?: Maybe<String>;
  barcode_not?: Maybe<String>;
  barcode_in?: Maybe<String[] | String>;
  barcode_not_in?: Maybe<String[] | String>;
  barcode_lt?: Maybe<String>;
  barcode_lte?: Maybe<String>;
  barcode_gt?: Maybe<String>;
  barcode_gte?: Maybe<String>;
  barcode_contains?: Maybe<String>;
  barcode_not_contains?: Maybe<String>;
  barcode_starts_with?: Maybe<String>;
  barcode_not_starts_with?: Maybe<String>;
  barcode_ends_with?: Maybe<String>;
  barcode_not_ends_with?: Maybe<String>;
  locationCode?: Maybe<String>;
  locationCode_not?: Maybe<String>;
  locationCode_in?: Maybe<String[] | String>;
  locationCode_not_in?: Maybe<String[] | String>;
  locationCode_lt?: Maybe<String>;
  locationCode_lte?: Maybe<String>;
  locationCode_gt?: Maybe<String>;
  locationCode_gte?: Maybe<String>;
  locationCode_contains?: Maybe<String>;
  locationCode_not_contains?: Maybe<String>;
  locationCode_starts_with?: Maybe<String>;
  locationCode_not_starts_with?: Maybe<String>;
  locationCode_ends_with?: Maybe<String>;
  locationCode_not_ends_with?: Maybe<String>;
  itemCode?: Maybe<String>;
  itemCode_not?: Maybe<String>;
  itemCode_in?: Maybe<String[] | String>;
  itemCode_not_in?: Maybe<String[] | String>;
  itemCode_lt?: Maybe<String>;
  itemCode_lte?: Maybe<String>;
  itemCode_gt?: Maybe<String>;
  itemCode_gte?: Maybe<String>;
  itemCode_contains?: Maybe<String>;
  itemCode_not_contains?: Maybe<String>;
  itemCode_starts_with?: Maybe<String>;
  itemCode_not_starts_with?: Maybe<String>;
  itemCode_ends_with?: Maybe<String>;
  itemCode_not_ends_with?: Maybe<String>;
  physicalProducts_every?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_some?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_none?: Maybe<PhysicalProductWhereInput>;
  constraints_every?: Maybe<WarehouseLocationConstraintWhereInput>;
  constraints_some?: Maybe<WarehouseLocationConstraintWhereInput>;
  constraints_none?: Maybe<WarehouseLocationConstraintWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<WarehouseLocationWhereInput[] | WarehouseLocationWhereInput>;
  OR?: Maybe<WarehouseLocationWhereInput[] | WarehouseLocationWhereInput>;
  NOT?: Maybe<WarehouseLocationWhereInput[] | WarehouseLocationWhereInput>;
}

export interface WarehouseLocationConstraintWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  category?: Maybe<CategoryWhereInput>;
  limit?: Maybe<Int>;
  limit_not?: Maybe<Int>;
  limit_in?: Maybe<Int[] | Int>;
  limit_not_in?: Maybe<Int[] | Int>;
  limit_lt?: Maybe<Int>;
  limit_lte?: Maybe<Int>;
  limit_gt?: Maybe<Int>;
  limit_gte?: Maybe<Int>;
  locations_every?: Maybe<WarehouseLocationWhereInput>;
  locations_some?: Maybe<WarehouseLocationWhereInput>;
  locations_none?: Maybe<WarehouseLocationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | WarehouseLocationConstraintWhereInput[]
    | WarehouseLocationConstraintWhereInput
  >;
  OR?: Maybe<
    | WarehouseLocationConstraintWhereInput[]
    | WarehouseLocationConstraintWhereInput
  >;
  NOT?: Maybe<
    | WarehouseLocationConstraintWhereInput[]
    | WarehouseLocationConstraintWhereInput
  >;
}

export interface PhysicalProductPriceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  buyUsedEnabled?: Maybe<Boolean>;
  buyUsedEnabled_not?: Maybe<Boolean>;
  buyUsedPrice?: Maybe<Float>;
  buyUsedPrice_not?: Maybe<Float>;
  buyUsedPrice_in?: Maybe<Float[] | Float>;
  buyUsedPrice_not_in?: Maybe<Float[] | Float>;
  buyUsedPrice_lt?: Maybe<Float>;
  buyUsedPrice_lte?: Maybe<Float>;
  buyUsedPrice_gt?: Maybe<Float>;
  buyUsedPrice_gte?: Maybe<Float>;
  AND?: Maybe<
    PhysicalProductPriceWhereInput[] | PhysicalProductPriceWhereInput
  >;
  OR?: Maybe<PhysicalProductPriceWhereInput[] | PhysicalProductPriceWhereInput>;
  NOT?: Maybe<
    PhysicalProductPriceWhereInput[] | PhysicalProductPriceWhereInput
  >;
}

export interface PhysicalProductQualityReportWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  damageType?: Maybe<PhysicalProductDamageType>;
  damageType_not?: Maybe<PhysicalProductDamageType>;
  damageType_in?: Maybe<
    PhysicalProductDamageType[] | PhysicalProductDamageType
  >;
  damageType_not_in?: Maybe<
    PhysicalProductDamageType[] | PhysicalProductDamageType
  >;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  physicalProduct?: Maybe<PhysicalProductWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | PhysicalProductQualityReportWhereInput[]
    | PhysicalProductQualityReportWhereInput
  >;
  OR?: Maybe<
    | PhysicalProductQualityReportWhereInput[]
    | PhysicalProductQualityReportWhereInput
  >;
  NOT?: Maybe<
    | PhysicalProductQualityReportWhereInput[]
    | PhysicalProductQualityReportWhereInput
  >;
}

export interface ShippingOptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  origin?: Maybe<LocationWhereInput>;
  destination?: Maybe<LocationWhereInput>;
  shippingMethod?: Maybe<ShippingMethodWhereInput>;
  externalCost?: Maybe<Int>;
  externalCost_not?: Maybe<Int>;
  externalCost_in?: Maybe<Int[] | Int>;
  externalCost_not_in?: Maybe<Int[] | Int>;
  externalCost_lt?: Maybe<Int>;
  externalCost_lte?: Maybe<Int>;
  externalCost_gt?: Maybe<Int>;
  externalCost_gte?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
  averageDuration_not?: Maybe<Int>;
  averageDuration_in?: Maybe<Int[] | Int>;
  averageDuration_not_in?: Maybe<Int[] | Int>;
  averageDuration_lt?: Maybe<Int>;
  averageDuration_lte?: Maybe<Int>;
  averageDuration_gt?: Maybe<Int>;
  averageDuration_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ShippingOptionWhereInput[] | ShippingOptionWhereInput>;
  OR?: Maybe<ShippingOptionWhereInput[] | ShippingOptionWhereInput>;
  NOT?: Maybe<ShippingOptionWhereInput[] | ShippingOptionWhereInput>;
}

export interface ShippingMethodWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<ShippingCode>;
  code_not?: Maybe<ShippingCode>;
  code_in?: Maybe<ShippingCode[] | ShippingCode>;
  code_not_in?: Maybe<ShippingCode[] | ShippingCode>;
  displayText?: Maybe<String>;
  displayText_not?: Maybe<String>;
  displayText_in?: Maybe<String[] | String>;
  displayText_not_in?: Maybe<String[] | String>;
  displayText_lt?: Maybe<String>;
  displayText_lte?: Maybe<String>;
  displayText_gt?: Maybe<String>;
  displayText_gte?: Maybe<String>;
  displayText_contains?: Maybe<String>;
  displayText_not_contains?: Maybe<String>;
  displayText_starts_with?: Maybe<String>;
  displayText_not_starts_with?: Maybe<String>;
  displayText_ends_with?: Maybe<String>;
  displayText_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ShippingMethodWhereInput[] | ShippingMethodWhereInput>;
  OR?: Maybe<ShippingMethodWhereInput[] | ShippingMethodWhereInput>;
  NOT?: Maybe<ShippingMethodWhereInput[] | ShippingMethodWhereInput>;
}

export interface FitPicReportWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reporter?: Maybe<UserWhereInput>;
  reported?: Maybe<FitPicWhereInput>;
  status?: Maybe<FitPicReportStatus>;
  status_not?: Maybe<FitPicReportStatus>;
  status_in?: Maybe<FitPicReportStatus[] | FitPicReportStatus>;
  status_not_in?: Maybe<FitPicReportStatus[] | FitPicReportStatus>;
  reportedAt?: Maybe<DateTimeInput>;
  reportedAt_not?: Maybe<DateTimeInput>;
  reportedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportedAt_lt?: Maybe<DateTimeInput>;
  reportedAt_lte?: Maybe<DateTimeInput>;
  reportedAt_gt?: Maybe<DateTimeInput>;
  reportedAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FitPicReportWhereInput[] | FitPicReportWhereInput>;
  OR?: Maybe<FitPicReportWhereInput[] | FitPicReportWhereInput>;
  NOT?: Maybe<FitPicReportWhereInput[] | FitPicReportWhereInput>;
}

export interface ActiveAdminUserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  admin?: Maybe<UserWhereInput>;
  AND?: Maybe<ActiveAdminUserWhereInput[] | ActiveAdminUserWhereInput>;
  OR?: Maybe<ActiveAdminUserWhereInput[] | ActiveAdminUserWhereInput>;
  NOT?: Maybe<ActiveAdminUserWhereInput[] | ActiveAdminUserWhereInput>;
}

export type AdminActionLogWhereUniqueInput = AtLeastOne<{
  actionId: Maybe<Int>;
}>;

export interface AdminActionLogWhereInput {
  actionId?: Maybe<Int>;
  actionId_not?: Maybe<Int>;
  actionId_in?: Maybe<Int[] | Int>;
  actionId_not_in?: Maybe<Int[] | Int>;
  actionId_lt?: Maybe<Int>;
  actionId_lte?: Maybe<Int>;
  actionId_gt?: Maybe<Int>;
  actionId_gte?: Maybe<Int>;
  entityId?: Maybe<String>;
  entityId_not?: Maybe<String>;
  entityId_in?: Maybe<String[] | String>;
  entityId_not_in?: Maybe<String[] | String>;
  entityId_lt?: Maybe<String>;
  entityId_lte?: Maybe<String>;
  entityId_gt?: Maybe<String>;
  entityId_gte?: Maybe<String>;
  entityId_contains?: Maybe<String>;
  entityId_not_contains?: Maybe<String>;
  entityId_starts_with?: Maybe<String>;
  entityId_not_starts_with?: Maybe<String>;
  entityId_ends_with?: Maybe<String>;
  entityId_not_ends_with?: Maybe<String>;
  tableName?: Maybe<String>;
  tableName_not?: Maybe<String>;
  tableName_in?: Maybe<String[] | String>;
  tableName_not_in?: Maybe<String[] | String>;
  tableName_lt?: Maybe<String>;
  tableName_lte?: Maybe<String>;
  tableName_gt?: Maybe<String>;
  tableName_gte?: Maybe<String>;
  tableName_contains?: Maybe<String>;
  tableName_not_contains?: Maybe<String>;
  tableName_starts_with?: Maybe<String>;
  tableName_not_starts_with?: Maybe<String>;
  tableName_ends_with?: Maybe<String>;
  tableName_not_ends_with?: Maybe<String>;
  activeAdminUser?: Maybe<UserWhereInput>;
  triggeredAt?: Maybe<DateTimeInput>;
  triggeredAt_not?: Maybe<DateTimeInput>;
  triggeredAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  triggeredAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  triggeredAt_lt?: Maybe<DateTimeInput>;
  triggeredAt_lte?: Maybe<DateTimeInput>;
  triggeredAt_gt?: Maybe<DateTimeInput>;
  triggeredAt_gte?: Maybe<DateTimeInput>;
  action?: Maybe<AdminAction>;
  action_not?: Maybe<AdminAction>;
  action_in?: Maybe<AdminAction[] | AdminAction>;
  action_not_in?: Maybe<AdminAction[] | AdminAction>;
  statementOnly?: Maybe<Boolean>;
  statementOnly_not?: Maybe<Boolean>;
  AND?: Maybe<AdminActionLogWhereInput[] | AdminActionLogWhereInput>;
  OR?: Maybe<AdminActionLogWhereInput[] | AdminActionLogWhereInput>;
  NOT?: Maybe<AdminActionLogWhereInput[] | AdminActionLogWhereInput>;
}

export type BagItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PauseRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  pausePending?: Maybe<Boolean>;
  pausePending_not?: Maybe<Boolean>;
  pauseDate?: Maybe<DateTimeInput>;
  pauseDate_not?: Maybe<DateTimeInput>;
  pauseDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pauseDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pauseDate_lt?: Maybe<DateTimeInput>;
  pauseDate_lte?: Maybe<DateTimeInput>;
  pauseDate_gt?: Maybe<DateTimeInput>;
  pauseDate_gte?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  resumeDate_not?: Maybe<DateTimeInput>;
  resumeDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resumeDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resumeDate_lt?: Maybe<DateTimeInput>;
  resumeDate_lte?: Maybe<DateTimeInput>;
  resumeDate_gt?: Maybe<DateTimeInput>;
  resumeDate_gte?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
  notified_not?: Maybe<Boolean>;
  membership?: Maybe<CustomerMembershipWhereInput>;
  AND?: Maybe<PauseRequestWhereInput[] | PauseRequestWhereInput>;
  OR?: Maybe<PauseRequestWhereInput[] | PauseRequestWhereInput>;
  NOT?: Maybe<PauseRequestWhereInput[] | PauseRequestWhereInput>;
}

export interface CustomerMembershipWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  plan?: Maybe<PaymentPlanWhereInput>;
  subscriptionId?: Maybe<String>;
  subscriptionId_not?: Maybe<String>;
  subscriptionId_in?: Maybe<String[] | String>;
  subscriptionId_not_in?: Maybe<String[] | String>;
  subscriptionId_lt?: Maybe<String>;
  subscriptionId_lte?: Maybe<String>;
  subscriptionId_gt?: Maybe<String>;
  subscriptionId_gte?: Maybe<String>;
  subscriptionId_contains?: Maybe<String>;
  subscriptionId_not_contains?: Maybe<String>;
  subscriptionId_starts_with?: Maybe<String>;
  subscriptionId_not_starts_with?: Maybe<String>;
  subscriptionId_ends_with?: Maybe<String>;
  subscriptionId_not_ends_with?: Maybe<String>;
  customer?: Maybe<CustomerWhereInput>;
  pauseRequests_every?: Maybe<PauseRequestWhereInput>;
  pauseRequests_some?: Maybe<PauseRequestWhereInput>;
  pauseRequests_none?: Maybe<PauseRequestWhereInput>;
  giftId?: Maybe<String>;
  giftId_not?: Maybe<String>;
  giftId_in?: Maybe<String[] | String>;
  giftId_not_in?: Maybe<String[] | String>;
  giftId_lt?: Maybe<String>;
  giftId_lte?: Maybe<String>;
  giftId_gt?: Maybe<String>;
  giftId_gte?: Maybe<String>;
  giftId_contains?: Maybe<String>;
  giftId_not_contains?: Maybe<String>;
  giftId_starts_with?: Maybe<String>;
  giftId_not_starts_with?: Maybe<String>;
  giftId_ends_with?: Maybe<String>;
  giftId_not_ends_with?: Maybe<String>;
  AND?: Maybe<CustomerMembershipWhereInput[] | CustomerMembershipWhereInput>;
  OR?: Maybe<CustomerMembershipWhereInput[] | CustomerMembershipWhereInput>;
  NOT?: Maybe<CustomerMembershipWhereInput[] | CustomerMembershipWhereInput>;
}

export interface PaymentPlanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  planID?: Maybe<String>;
  planID_not?: Maybe<String>;
  planID_in?: Maybe<String[] | String>;
  planID_not_in?: Maybe<String[] | String>;
  planID_lt?: Maybe<String>;
  planID_lte?: Maybe<String>;
  planID_gt?: Maybe<String>;
  planID_gte?: Maybe<String>;
  planID_contains?: Maybe<String>;
  planID_not_contains?: Maybe<String>;
  planID_starts_with?: Maybe<String>;
  planID_not_starts_with?: Maybe<String>;
  planID_ends_with?: Maybe<String>;
  planID_not_ends_with?: Maybe<String>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  itemCount?: Maybe<Int>;
  itemCount_not?: Maybe<Int>;
  itemCount_in?: Maybe<Int[] | Int>;
  itemCount_not_in?: Maybe<Int[] | Int>;
  itemCount_lt?: Maybe<Int>;
  itemCount_lte?: Maybe<Int>;
  itemCount_gt?: Maybe<Int>;
  itemCount_gte?: Maybe<Int>;
  tagline?: Maybe<String>;
  tagline_not?: Maybe<String>;
  tagline_in?: Maybe<String[] | String>;
  tagline_not_in?: Maybe<String[] | String>;
  tagline_lt?: Maybe<String>;
  tagline_lte?: Maybe<String>;
  tagline_gt?: Maybe<String>;
  tagline_gte?: Maybe<String>;
  tagline_contains?: Maybe<String>;
  tagline_not_contains?: Maybe<String>;
  tagline_starts_with?: Maybe<String>;
  tagline_not_starts_with?: Maybe<String>;
  tagline_ends_with?: Maybe<String>;
  tagline_not_ends_with?: Maybe<String>;
  tier?: Maybe<PaymentPlanTier>;
  tier_not?: Maybe<PaymentPlanTier>;
  tier_in?: Maybe<PaymentPlanTier[] | PaymentPlanTier>;
  tier_not_in?: Maybe<PaymentPlanTier[] | PaymentPlanTier>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PaymentPlanWhereInput[] | PaymentPlanWhereInput>;
  OR?: Maybe<PaymentPlanWhereInput[] | PaymentPlanWhereInput>;
  NOT?: Maybe<PaymentPlanWhereInput[] | PaymentPlanWhereInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  status?: Maybe<CustomerStatus>;
  status_not?: Maybe<CustomerStatus>;
  status_in?: Maybe<CustomerStatus[] | CustomerStatus>;
  status_not_in?: Maybe<CustomerStatus[] | CustomerStatus>;
  detail?: Maybe<CustomerDetailWhereInput>;
  billingInfo?: Maybe<BillingInfoWhereInput>;
  plan?: Maybe<Plan>;
  plan_not?: Maybe<Plan>;
  plan_in?: Maybe<Plan[] | Plan>;
  plan_not_in?: Maybe<Plan[] | Plan>;
  membership?: Maybe<CustomerMembershipWhereInput>;
  bagItems_every?: Maybe<BagItemWhereInput>;
  bagItems_some?: Maybe<BagItemWhereInput>;
  bagItems_none?: Maybe<BagItemWhereInput>;
  reservations_every?: Maybe<ReservationWhereInput>;
  reservations_some?: Maybe<ReservationWhereInput>;
  reservations_none?: Maybe<ReservationWhereInput>;
  referralLink?: Maybe<String>;
  referralLink_not?: Maybe<String>;
  referralLink_in?: Maybe<String[] | String>;
  referralLink_not_in?: Maybe<String[] | String>;
  referralLink_lt?: Maybe<String>;
  referralLink_lte?: Maybe<String>;
  referralLink_gt?: Maybe<String>;
  referralLink_gte?: Maybe<String>;
  referralLink_contains?: Maybe<String>;
  referralLink_not_contains?: Maybe<String>;
  referralLink_starts_with?: Maybe<String>;
  referralLink_not_starts_with?: Maybe<String>;
  referralLink_ends_with?: Maybe<String>;
  referralLink_not_ends_with?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrerId_not?: Maybe<String>;
  referrerId_in?: Maybe<String[] | String>;
  referrerId_not_in?: Maybe<String[] | String>;
  referrerId_lt?: Maybe<String>;
  referrerId_lte?: Maybe<String>;
  referrerId_gt?: Maybe<String>;
  referrerId_gte?: Maybe<String>;
  referrerId_contains?: Maybe<String>;
  referrerId_not_contains?: Maybe<String>;
  referrerId_starts_with?: Maybe<String>;
  referrerId_not_starts_with?: Maybe<String>;
  referrerId_ends_with?: Maybe<String>;
  referrerId_not_ends_with?: Maybe<String>;
  referrer?: Maybe<CustomerWhereInput>;
  referrees_every?: Maybe<CustomerWhereInput>;
  referrees_some?: Maybe<CustomerWhereInput>;
  referrees_none?: Maybe<CustomerWhereInput>;
  emailedProducts_every?: Maybe<ProductWhereInput>;
  emailedProducts_some?: Maybe<ProductWhereInput>;
  emailedProducts_none?: Maybe<ProductWhereInput>;
  admissions?: Maybe<CustomerAdmissionsDataWhereInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  authorizedAt_not?: Maybe<DateTimeInput>;
  authorizedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authorizedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authorizedAt_lt?: Maybe<DateTimeInput>;
  authorizedAt_lte?: Maybe<DateTimeInput>;
  authorizedAt_gt?: Maybe<DateTimeInput>;
  authorizedAt_gte?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface CustomerDetailWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  bodyType?: Maybe<String>;
  bodyType_not?: Maybe<String>;
  bodyType_in?: Maybe<String[] | String>;
  bodyType_not_in?: Maybe<String[] | String>;
  bodyType_lt?: Maybe<String>;
  bodyType_lte?: Maybe<String>;
  bodyType_gt?: Maybe<String>;
  bodyType_gte?: Maybe<String>;
  bodyType_contains?: Maybe<String>;
  bodyType_not_contains?: Maybe<String>;
  bodyType_starts_with?: Maybe<String>;
  bodyType_not_starts_with?: Maybe<String>;
  bodyType_ends_with?: Maybe<String>;
  bodyType_not_ends_with?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  averageTopSize_not?: Maybe<String>;
  averageTopSize_in?: Maybe<String[] | String>;
  averageTopSize_not_in?: Maybe<String[] | String>;
  averageTopSize_lt?: Maybe<String>;
  averageTopSize_lte?: Maybe<String>;
  averageTopSize_gt?: Maybe<String>;
  averageTopSize_gte?: Maybe<String>;
  averageTopSize_contains?: Maybe<String>;
  averageTopSize_not_contains?: Maybe<String>;
  averageTopSize_starts_with?: Maybe<String>;
  averageTopSize_not_starts_with?: Maybe<String>;
  averageTopSize_ends_with?: Maybe<String>;
  averageTopSize_not_ends_with?: Maybe<String>;
  averageWaistSize?: Maybe<String>;
  averageWaistSize_not?: Maybe<String>;
  averageWaistSize_in?: Maybe<String[] | String>;
  averageWaistSize_not_in?: Maybe<String[] | String>;
  averageWaistSize_lt?: Maybe<String>;
  averageWaistSize_lte?: Maybe<String>;
  averageWaistSize_gt?: Maybe<String>;
  averageWaistSize_gte?: Maybe<String>;
  averageWaistSize_contains?: Maybe<String>;
  averageWaistSize_not_contains?: Maybe<String>;
  averageWaistSize_starts_with?: Maybe<String>;
  averageWaistSize_not_starts_with?: Maybe<String>;
  averageWaistSize_ends_with?: Maybe<String>;
  averageWaistSize_not_ends_with?: Maybe<String>;
  averagePantLength?: Maybe<String>;
  averagePantLength_not?: Maybe<String>;
  averagePantLength_in?: Maybe<String[] | String>;
  averagePantLength_not_in?: Maybe<String[] | String>;
  averagePantLength_lt?: Maybe<String>;
  averagePantLength_lte?: Maybe<String>;
  averagePantLength_gt?: Maybe<String>;
  averagePantLength_gte?: Maybe<String>;
  averagePantLength_contains?: Maybe<String>;
  averagePantLength_not_contains?: Maybe<String>;
  averagePantLength_starts_with?: Maybe<String>;
  averagePantLength_not_starts_with?: Maybe<String>;
  averagePantLength_ends_with?: Maybe<String>;
  averagePantLength_not_ends_with?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  preferredPronouns_not?: Maybe<String>;
  preferredPronouns_in?: Maybe<String[] | String>;
  preferredPronouns_not_in?: Maybe<String[] | String>;
  preferredPronouns_lt?: Maybe<String>;
  preferredPronouns_lte?: Maybe<String>;
  preferredPronouns_gt?: Maybe<String>;
  preferredPronouns_gte?: Maybe<String>;
  preferredPronouns_contains?: Maybe<String>;
  preferredPronouns_not_contains?: Maybe<String>;
  preferredPronouns_starts_with?: Maybe<String>;
  preferredPronouns_not_starts_with?: Maybe<String>;
  preferredPronouns_ends_with?: Maybe<String>;
  preferredPronouns_not_ends_with?: Maybe<String>;
  profession?: Maybe<String>;
  profession_not?: Maybe<String>;
  profession_in?: Maybe<String[] | String>;
  profession_not_in?: Maybe<String[] | String>;
  profession_lt?: Maybe<String>;
  profession_lte?: Maybe<String>;
  profession_gt?: Maybe<String>;
  profession_gte?: Maybe<String>;
  profession_contains?: Maybe<String>;
  profession_not_contains?: Maybe<String>;
  profession_starts_with?: Maybe<String>;
  profession_not_starts_with?: Maybe<String>;
  profession_ends_with?: Maybe<String>;
  profession_not_ends_with?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  partyFrequency_not?: Maybe<String>;
  partyFrequency_in?: Maybe<String[] | String>;
  partyFrequency_not_in?: Maybe<String[] | String>;
  partyFrequency_lt?: Maybe<String>;
  partyFrequency_lte?: Maybe<String>;
  partyFrequency_gt?: Maybe<String>;
  partyFrequency_gte?: Maybe<String>;
  partyFrequency_contains?: Maybe<String>;
  partyFrequency_not_contains?: Maybe<String>;
  partyFrequency_starts_with?: Maybe<String>;
  partyFrequency_not_starts_with?: Maybe<String>;
  partyFrequency_ends_with?: Maybe<String>;
  partyFrequency_not_ends_with?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  travelFrequency_not?: Maybe<String>;
  travelFrequency_in?: Maybe<String[] | String>;
  travelFrequency_not_in?: Maybe<String[] | String>;
  travelFrequency_lt?: Maybe<String>;
  travelFrequency_lte?: Maybe<String>;
  travelFrequency_gt?: Maybe<String>;
  travelFrequency_gte?: Maybe<String>;
  travelFrequency_contains?: Maybe<String>;
  travelFrequency_not_contains?: Maybe<String>;
  travelFrequency_starts_with?: Maybe<String>;
  travelFrequency_not_starts_with?: Maybe<String>;
  travelFrequency_ends_with?: Maybe<String>;
  travelFrequency_not_ends_with?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  shoppingFrequency_not?: Maybe<String>;
  shoppingFrequency_in?: Maybe<String[] | String>;
  shoppingFrequency_not_in?: Maybe<String[] | String>;
  shoppingFrequency_lt?: Maybe<String>;
  shoppingFrequency_lte?: Maybe<String>;
  shoppingFrequency_gt?: Maybe<String>;
  shoppingFrequency_gte?: Maybe<String>;
  shoppingFrequency_contains?: Maybe<String>;
  shoppingFrequency_not_contains?: Maybe<String>;
  shoppingFrequency_starts_with?: Maybe<String>;
  shoppingFrequency_not_starts_with?: Maybe<String>;
  shoppingFrequency_ends_with?: Maybe<String>;
  shoppingFrequency_not_ends_with?: Maybe<String>;
  averageSpend?: Maybe<String>;
  averageSpend_not?: Maybe<String>;
  averageSpend_in?: Maybe<String[] | String>;
  averageSpend_not_in?: Maybe<String[] | String>;
  averageSpend_lt?: Maybe<String>;
  averageSpend_lte?: Maybe<String>;
  averageSpend_gt?: Maybe<String>;
  averageSpend_gte?: Maybe<String>;
  averageSpend_contains?: Maybe<String>;
  averageSpend_not_contains?: Maybe<String>;
  averageSpend_starts_with?: Maybe<String>;
  averageSpend_not_starts_with?: Maybe<String>;
  averageSpend_ends_with?: Maybe<String>;
  averageSpend_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  commuteStyle_not?: Maybe<String>;
  commuteStyle_in?: Maybe<String[] | String>;
  commuteStyle_not_in?: Maybe<String[] | String>;
  commuteStyle_lt?: Maybe<String>;
  commuteStyle_lte?: Maybe<String>;
  commuteStyle_gt?: Maybe<String>;
  commuteStyle_gte?: Maybe<String>;
  commuteStyle_contains?: Maybe<String>;
  commuteStyle_not_contains?: Maybe<String>;
  commuteStyle_starts_with?: Maybe<String>;
  commuteStyle_not_starts_with?: Maybe<String>;
  commuteStyle_ends_with?: Maybe<String>;
  commuteStyle_not_ends_with?: Maybe<String>;
  stylePreferences?: Maybe<StylePreferencesWhereInput>;
  shippingAddress?: Maybe<LocationWhereInput>;
  phoneOS?: Maybe<String>;
  phoneOS_not?: Maybe<String>;
  phoneOS_in?: Maybe<String[] | String>;
  phoneOS_not_in?: Maybe<String[] | String>;
  phoneOS_lt?: Maybe<String>;
  phoneOS_lte?: Maybe<String>;
  phoneOS_gt?: Maybe<String>;
  phoneOS_gte?: Maybe<String>;
  phoneOS_contains?: Maybe<String>;
  phoneOS_not_contains?: Maybe<String>;
  phoneOS_starts_with?: Maybe<String>;
  phoneOS_not_starts_with?: Maybe<String>;
  phoneOS_ends_with?: Maybe<String>;
  phoneOS_not_ends_with?: Maybe<String>;
  insureShipment?: Maybe<Boolean>;
  insureShipment_not?: Maybe<Boolean>;
  instagramHandle?: Maybe<String>;
  instagramHandle_not?: Maybe<String>;
  instagramHandle_in?: Maybe<String[] | String>;
  instagramHandle_not_in?: Maybe<String[] | String>;
  instagramHandle_lt?: Maybe<String>;
  instagramHandle_lte?: Maybe<String>;
  instagramHandle_gt?: Maybe<String>;
  instagramHandle_gte?: Maybe<String>;
  instagramHandle_contains?: Maybe<String>;
  instagramHandle_not_contains?: Maybe<String>;
  instagramHandle_starts_with?: Maybe<String>;
  instagramHandle_not_starts_with?: Maybe<String>;
  instagramHandle_ends_with?: Maybe<String>;
  instagramHandle_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerDetailWhereInput[] | CustomerDetailWhereInput>;
  OR?: Maybe<CustomerDetailWhereInput[] | CustomerDetailWhereInput>;
  NOT?: Maybe<CustomerDetailWhereInput[] | CustomerDetailWhereInput>;
}

export interface StylePreferencesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<StylePreferencesWhereInput[] | StylePreferencesWhereInput>;
  OR?: Maybe<StylePreferencesWhereInput[] | StylePreferencesWhereInput>;
  NOT?: Maybe<StylePreferencesWhereInput[] | StylePreferencesWhereInput>;
}

export interface BillingInfoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  last_digits?: Maybe<String>;
  last_digits_not?: Maybe<String>;
  last_digits_in?: Maybe<String[] | String>;
  last_digits_not_in?: Maybe<String[] | String>;
  last_digits_lt?: Maybe<String>;
  last_digits_lte?: Maybe<String>;
  last_digits_gt?: Maybe<String>;
  last_digits_gte?: Maybe<String>;
  last_digits_contains?: Maybe<String>;
  last_digits_not_contains?: Maybe<String>;
  last_digits_starts_with?: Maybe<String>;
  last_digits_not_starts_with?: Maybe<String>;
  last_digits_ends_with?: Maybe<String>;
  last_digits_not_ends_with?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_month_not?: Maybe<Int>;
  expiration_month_in?: Maybe<Int[] | Int>;
  expiration_month_not_in?: Maybe<Int[] | Int>;
  expiration_month_lt?: Maybe<Int>;
  expiration_month_lte?: Maybe<Int>;
  expiration_month_gt?: Maybe<Int>;
  expiration_month_gte?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  expiration_year_not?: Maybe<Int>;
  expiration_year_in?: Maybe<Int[] | Int>;
  expiration_year_not_in?: Maybe<Int[] | Int>;
  expiration_year_lt?: Maybe<Int>;
  expiration_year_lte?: Maybe<Int>;
  expiration_year_gt?: Maybe<Int>;
  expiration_year_gte?: Maybe<Int>;
  street1?: Maybe<String>;
  street1_not?: Maybe<String>;
  street1_in?: Maybe<String[] | String>;
  street1_not_in?: Maybe<String[] | String>;
  street1_lt?: Maybe<String>;
  street1_lte?: Maybe<String>;
  street1_gt?: Maybe<String>;
  street1_gte?: Maybe<String>;
  street1_contains?: Maybe<String>;
  street1_not_contains?: Maybe<String>;
  street1_starts_with?: Maybe<String>;
  street1_not_starts_with?: Maybe<String>;
  street1_ends_with?: Maybe<String>;
  street1_not_ends_with?: Maybe<String>;
  street2?: Maybe<String>;
  street2_not?: Maybe<String>;
  street2_in?: Maybe<String[] | String>;
  street2_not_in?: Maybe<String[] | String>;
  street2_lt?: Maybe<String>;
  street2_lte?: Maybe<String>;
  street2_gt?: Maybe<String>;
  street2_gte?: Maybe<String>;
  street2_contains?: Maybe<String>;
  street2_not_contains?: Maybe<String>;
  street2_starts_with?: Maybe<String>;
  street2_not_starts_with?: Maybe<String>;
  street2_ends_with?: Maybe<String>;
  street2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  postal_code?: Maybe<String>;
  postal_code_not?: Maybe<String>;
  postal_code_in?: Maybe<String[] | String>;
  postal_code_not_in?: Maybe<String[] | String>;
  postal_code_lt?: Maybe<String>;
  postal_code_lte?: Maybe<String>;
  postal_code_gt?: Maybe<String>;
  postal_code_gte?: Maybe<String>;
  postal_code_contains?: Maybe<String>;
  postal_code_not_contains?: Maybe<String>;
  postal_code_starts_with?: Maybe<String>;
  postal_code_not_starts_with?: Maybe<String>;
  postal_code_ends_with?: Maybe<String>;
  postal_code_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BillingInfoWhereInput[] | BillingInfoWhereInput>;
  OR?: Maybe<BillingInfoWhereInput[] | BillingInfoWhereInput>;
  NOT?: Maybe<BillingInfoWhereInput[] | BillingInfoWhereInput>;
}

export interface BagItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  productVariant?: Maybe<ProductVariantWhereInput>;
  position?: Maybe<Int>;
  position_not?: Maybe<Int>;
  position_in?: Maybe<Int[] | Int>;
  position_not_in?: Maybe<Int[] | Int>;
  position_lt?: Maybe<Int>;
  position_lte?: Maybe<Int>;
  position_gt?: Maybe<Int>;
  position_gte?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  saved_not?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
  status_not?: Maybe<BagItemStatus>;
  status_in?: Maybe<BagItemStatus[] | BagItemStatus>;
  status_not_in?: Maybe<BagItemStatus[] | BagItemStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BagItemWhereInput[] | BagItemWhereInput>;
  OR?: Maybe<BagItemWhereInput[] | BagItemWhereInput>;
  NOT?: Maybe<BagItemWhereInput[] | BagItemWhereInput>;
}

export interface ReservationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  customer?: Maybe<CustomerWhereInput>;
  sentPackage?: Maybe<PackageWhereInput>;
  returnedPackage?: Maybe<PackageWhereInput>;
  products_every?: Maybe<PhysicalProductWhereInput>;
  products_some?: Maybe<PhysicalProductWhereInput>;
  products_none?: Maybe<PhysicalProductWhereInput>;
  packageEvents_every?: Maybe<PackageTransitEventWhereInput>;
  packageEvents_some?: Maybe<PackageTransitEventWhereInput>;
  packageEvents_none?: Maybe<PackageTransitEventWhereInput>;
  reservationNumber?: Maybe<Int>;
  reservationNumber_not?: Maybe<Int>;
  reservationNumber_in?: Maybe<Int[] | Int>;
  reservationNumber_not_in?: Maybe<Int[] | Int>;
  reservationNumber_lt?: Maybe<Int>;
  reservationNumber_lte?: Maybe<Int>;
  reservationNumber_gt?: Maybe<Int>;
  reservationNumber_gte?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  phase_not?: Maybe<ReservationPhase>;
  phase_in?: Maybe<ReservationPhase[] | ReservationPhase>;
  phase_not_in?: Maybe<ReservationPhase[] | ReservationPhase>;
  shipped?: Maybe<Boolean>;
  shipped_not?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  status_not?: Maybe<ReservationStatus>;
  status_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  status_not_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  shippedAt_not?: Maybe<DateTimeInput>;
  shippedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_lt?: Maybe<DateTimeInput>;
  shippedAt_lte?: Maybe<DateTimeInput>;
  shippedAt_gt?: Maybe<DateTimeInput>;
  shippedAt_gte?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  receivedAt_not?: Maybe<DateTimeInput>;
  receivedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_lt?: Maybe<DateTimeInput>;
  receivedAt_lte?: Maybe<DateTimeInput>;
  receivedAt_gt?: Maybe<DateTimeInput>;
  receivedAt_gte?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  reminderSentAt_not?: Maybe<DateTimeInput>;
  reminderSentAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reminderSentAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reminderSentAt_lt?: Maybe<DateTimeInput>;
  reminderSentAt_lte?: Maybe<DateTimeInput>;
  reminderSentAt_gt?: Maybe<DateTimeInput>;
  reminderSentAt_gte?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  statusUpdatedAt_not?: Maybe<DateTimeInput>;
  statusUpdatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  statusUpdatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  statusUpdatedAt_lt?: Maybe<DateTimeInput>;
  statusUpdatedAt_lte?: Maybe<DateTimeInput>;
  statusUpdatedAt_gt?: Maybe<DateTimeInput>;
  statusUpdatedAt_gte?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptWhereInput>;
  lastLocation?: Maybe<LocationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  shippingOption?: Maybe<ShippingOptionWhereInput>;
  AND?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
  OR?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
  NOT?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
}

export interface PackageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  items_every?: Maybe<PhysicalProductWhereInput>;
  items_some?: Maybe<PhysicalProductWhereInput>;
  items_none?: Maybe<PhysicalProductWhereInput>;
  transactionID?: Maybe<String>;
  transactionID_not?: Maybe<String>;
  transactionID_in?: Maybe<String[] | String>;
  transactionID_not_in?: Maybe<String[] | String>;
  transactionID_lt?: Maybe<String>;
  transactionID_lte?: Maybe<String>;
  transactionID_gt?: Maybe<String>;
  transactionID_gte?: Maybe<String>;
  transactionID_contains?: Maybe<String>;
  transactionID_not_contains?: Maybe<String>;
  transactionID_starts_with?: Maybe<String>;
  transactionID_not_starts_with?: Maybe<String>;
  transactionID_ends_with?: Maybe<String>;
  transactionID_not_ends_with?: Maybe<String>;
  shippingLabel?: Maybe<LabelWhereInput>;
  fromAddress?: Maybe<LocationWhereInput>;
  toAddress?: Maybe<LocationWhereInput>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  events_every?: Maybe<PackageTransitEventWhereInput>;
  events_some?: Maybe<PackageTransitEventWhereInput>;
  events_none?: Maybe<PackageTransitEventWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PackageWhereInput[] | PackageWhereInput>;
  OR?: Maybe<PackageWhereInput[] | PackageWhereInput>;
  NOT?: Maybe<PackageWhereInput[] | PackageWhereInput>;
}

export interface LabelWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingNumber_not?: Maybe<String>;
  trackingNumber_in?: Maybe<String[] | String>;
  trackingNumber_not_in?: Maybe<String[] | String>;
  trackingNumber_lt?: Maybe<String>;
  trackingNumber_lte?: Maybe<String>;
  trackingNumber_gt?: Maybe<String>;
  trackingNumber_gte?: Maybe<String>;
  trackingNumber_contains?: Maybe<String>;
  trackingNumber_not_contains?: Maybe<String>;
  trackingNumber_starts_with?: Maybe<String>;
  trackingNumber_not_starts_with?: Maybe<String>;
  trackingNumber_ends_with?: Maybe<String>;
  trackingNumber_not_ends_with?: Maybe<String>;
  trackingURL?: Maybe<String>;
  trackingURL_not?: Maybe<String>;
  trackingURL_in?: Maybe<String[] | String>;
  trackingURL_not_in?: Maybe<String[] | String>;
  trackingURL_lt?: Maybe<String>;
  trackingURL_lte?: Maybe<String>;
  trackingURL_gt?: Maybe<String>;
  trackingURL_gte?: Maybe<String>;
  trackingURL_contains?: Maybe<String>;
  trackingURL_not_contains?: Maybe<String>;
  trackingURL_starts_with?: Maybe<String>;
  trackingURL_not_starts_with?: Maybe<String>;
  trackingURL_ends_with?: Maybe<String>;
  trackingURL_not_ends_with?: Maybe<String>;
  AND?: Maybe<LabelWhereInput[] | LabelWhereInput>;
  OR?: Maybe<LabelWhereInput[] | LabelWhereInput>;
  NOT?: Maybe<LabelWhereInput[] | LabelWhereInput>;
}

export interface PackageTransitEventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<PackageTransitEventStatus>;
  status_not?: Maybe<PackageTransitEventStatus>;
  status_in?: Maybe<PackageTransitEventStatus[] | PackageTransitEventStatus>;
  status_not_in?: Maybe<
    PackageTransitEventStatus[] | PackageTransitEventStatus
  >;
  subStatus?: Maybe<PackageTransitEventSubStatus>;
  subStatus_not?: Maybe<PackageTransitEventSubStatus>;
  subStatus_in?: Maybe<
    PackageTransitEventSubStatus[] | PackageTransitEventSubStatus
  >;
  subStatus_not_in?: Maybe<
    PackageTransitEventSubStatus[] | PackageTransitEventSubStatus
  >;
  package?: Maybe<PackageWhereInput>;
  reservation?: Maybe<ReservationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PackageTransitEventWhereInput[] | PackageTransitEventWhereInput>;
  OR?: Maybe<PackageTransitEventWhereInput[] | PackageTransitEventWhereInput>;
  NOT?: Maybe<PackageTransitEventWhereInput[] | PackageTransitEventWhereInput>;
}

export interface ReservationReceiptWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reservation?: Maybe<ReservationWhereInput>;
  items_every?: Maybe<ReservationReceiptItemWhereInput>;
  items_some?: Maybe<ReservationReceiptItemWhereInput>;
  items_none?: Maybe<ReservationReceiptItemWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReservationReceiptWhereInput[] | ReservationReceiptWhereInput>;
  OR?: Maybe<ReservationReceiptWhereInput[] | ReservationReceiptWhereInput>;
  NOT?: Maybe<ReservationReceiptWhereInput[] | ReservationReceiptWhereInput>;
}

export interface ReservationReceiptItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  product?: Maybe<PhysicalProductWhereInput>;
  productStatus?: Maybe<PhysicalProductStatus>;
  productStatus_not?: Maybe<PhysicalProductStatus>;
  productStatus_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  productStatus_not_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ReservationReceiptItemWhereInput[] | ReservationReceiptItemWhereInput
  >;
  OR?: Maybe<
    ReservationReceiptItemWhereInput[] | ReservationReceiptItemWhereInput
  >;
  NOT?: Maybe<
    ReservationReceiptItemWhereInput[] | ReservationReceiptItemWhereInput
  >;
}

export interface CustomerAdmissionsDataWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  inServiceableZipcode?: Maybe<Boolean>;
  inServiceableZipcode_not?: Maybe<Boolean>;
  admissable?: Maybe<Boolean>;
  admissable_not?: Maybe<Boolean>;
  inAdmissableReason?: Maybe<InAdmissableReason>;
  inAdmissableReason_not?: Maybe<InAdmissableReason>;
  inAdmissableReason_in?: Maybe<InAdmissableReason[] | InAdmissableReason>;
  inAdmissableReason_not_in?: Maybe<InAdmissableReason[] | InAdmissableReason>;
  allAccessEnabled?: Maybe<Boolean>;
  allAccessEnabled_not?: Maybe<Boolean>;
  customer?: Maybe<CustomerWhereInput>;
  authorizationsCount?: Maybe<Int>;
  authorizationsCount_not?: Maybe<Int>;
  authorizationsCount_in?: Maybe<Int[] | Int>;
  authorizationsCount_not_in?: Maybe<Int[] | Int>;
  authorizationsCount_lt?: Maybe<Int>;
  authorizationsCount_lte?: Maybe<Int>;
  authorizationsCount_gt?: Maybe<Int>;
  authorizationsCount_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  authorizationWindowClosesAt?: Maybe<DateTimeInput>;
  authorizationWindowClosesAt_not?: Maybe<DateTimeInput>;
  authorizationWindowClosesAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authorizationWindowClosesAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authorizationWindowClosesAt_lt?: Maybe<DateTimeInput>;
  authorizationWindowClosesAt_lte?: Maybe<DateTimeInput>;
  authorizationWindowClosesAt_gt?: Maybe<DateTimeInput>;
  authorizationWindowClosesAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CustomerAdmissionsDataWhereInput[] | CustomerAdmissionsDataWhereInput
  >;
  OR?: Maybe<
    CustomerAdmissionsDataWhereInput[] | CustomerAdmissionsDataWhereInput
  >;
  NOT?: Maybe<
    CustomerAdmissionsDataWhereInput[] | CustomerAdmissionsDataWhereInput
  >;
}

export interface UTMDataWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  medium?: Maybe<String>;
  medium_not?: Maybe<String>;
  medium_in?: Maybe<String[] | String>;
  medium_not_in?: Maybe<String[] | String>;
  medium_lt?: Maybe<String>;
  medium_lte?: Maybe<String>;
  medium_gt?: Maybe<String>;
  medium_gte?: Maybe<String>;
  medium_contains?: Maybe<String>;
  medium_not_contains?: Maybe<String>;
  medium_starts_with?: Maybe<String>;
  medium_not_starts_with?: Maybe<String>;
  medium_ends_with?: Maybe<String>;
  medium_not_ends_with?: Maybe<String>;
  campaign?: Maybe<String>;
  campaign_not?: Maybe<String>;
  campaign_in?: Maybe<String[] | String>;
  campaign_not_in?: Maybe<String[] | String>;
  campaign_lt?: Maybe<String>;
  campaign_lte?: Maybe<String>;
  campaign_gt?: Maybe<String>;
  campaign_gte?: Maybe<String>;
  campaign_contains?: Maybe<String>;
  campaign_not_contains?: Maybe<String>;
  campaign_starts_with?: Maybe<String>;
  campaign_not_starts_with?: Maybe<String>;
  campaign_ends_with?: Maybe<String>;
  campaign_not_ends_with?: Maybe<String>;
  term?: Maybe<String>;
  term_not?: Maybe<String>;
  term_in?: Maybe<String[] | String>;
  term_not_in?: Maybe<String[] | String>;
  term_lt?: Maybe<String>;
  term_lte?: Maybe<String>;
  term_gt?: Maybe<String>;
  term_gte?: Maybe<String>;
  term_contains?: Maybe<String>;
  term_not_contains?: Maybe<String>;
  term_starts_with?: Maybe<String>;
  term_not_starts_with?: Maybe<String>;
  term_ends_with?: Maybe<String>;
  term_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UTMDataWhereInput[] | UTMDataWhereInput>;
  OR?: Maybe<UTMDataWhereInput[] | UTMDataWhereInput>;
  NOT?: Maybe<UTMDataWhereInput[] | UTMDataWhereInput>;
}

export type BillingInfoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type BottomSizeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type BrandWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
}>;

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
}>;

export type CollectionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export interface CollectionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  images_every?: Maybe<ImageWhereInput>;
  images_some?: Maybe<ImageWhereInput>;
  images_none?: Maybe<ImageWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subTitle?: Maybe<String>;
  subTitle_not?: Maybe<String>;
  subTitle_in?: Maybe<String[] | String>;
  subTitle_not_in?: Maybe<String[] | String>;
  subTitle_lt?: Maybe<String>;
  subTitle_lte?: Maybe<String>;
  subTitle_gt?: Maybe<String>;
  subTitle_gte?: Maybe<String>;
  subTitle_contains?: Maybe<String>;
  subTitle_not_contains?: Maybe<String>;
  subTitle_starts_with?: Maybe<String>;
  subTitle_not_starts_with?: Maybe<String>;
  subTitle_ends_with?: Maybe<String>;
  subTitle_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CollectionWhereInput[] | CollectionWhereInput>;
  OR?: Maybe<CollectionWhereInput[] | CollectionWhereInput>;
  NOT?: Maybe<CollectionWhereInput[] | CollectionWhereInput>;
}

export type ColorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
  colorCode?: Maybe<String>;
}>;

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  referralLink?: Maybe<String>;
}>;

export type CustomerAdmissionsDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CustomerDetailWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CustomerMembershipWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EmailReceiptWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExternalShopifyIntegrationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  shopName?: Maybe<String>;
}>;

export type FitPicWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FitPicReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  url?: Maybe<String>;
}>;

export type InterestedUserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InterestedUserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  zipcode?: Maybe<String>;
  zipcode_not?: Maybe<String>;
  zipcode_in?: Maybe<String[] | String>;
  zipcode_not_in?: Maybe<String[] | String>;
  zipcode_lt?: Maybe<String>;
  zipcode_lte?: Maybe<String>;
  zipcode_gt?: Maybe<String>;
  zipcode_gte?: Maybe<String>;
  zipcode_contains?: Maybe<String>;
  zipcode_not_contains?: Maybe<String>;
  zipcode_starts_with?: Maybe<String>;
  zipcode_not_starts_with?: Maybe<String>;
  zipcode_ends_with?: Maybe<String>;
  zipcode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InterestedUserWhereInput[] | InterestedUserWhereInput>;
  OR?: Maybe<InterestedUserWhereInput[] | InterestedUserWhereInput>;
  NOT?: Maybe<InterestedUserWhereInput[] | InterestedUserWhereInput>;
}

export type LabelWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type LocationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export type PackageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PackageTransitEventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PauseRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PaymentPlanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  planID?: Maybe<String>;
}>;

export type PhysicalProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  seasonsUID?: Maybe<String>;
}>;

export type PhysicalProductPriceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PhysicalProductQualityReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export type ProductFunctionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type ProductMaterialCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export type ProductModelWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type ProductNotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductNotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<ProductNotificationType>;
  type_not?: Maybe<ProductNotificationType>;
  type_in?: Maybe<ProductNotificationType[] | ProductNotificationType>;
  type_not_in?: Maybe<ProductNotificationType[] | ProductNotificationType>;
  customer?: Maybe<CustomerWhereInput>;
  physicalProduct?: Maybe<PhysicalProductWhereInput>;
  productVariant?: Maybe<ProductVariantWhereInput>;
  shouldNotify?: Maybe<Boolean>;
  shouldNotify_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductNotificationWhereInput[] | ProductNotificationWhereInput>;
  OR?: Maybe<ProductNotificationWhereInput[] | ProductNotificationWhereInput>;
  NOT?: Maybe<ProductNotificationWhereInput[] | ProductNotificationWhereInput>;
}

export type ProductRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  priceCurrency_not?: Maybe<String>;
  priceCurrency_in?: Maybe<String[] | String>;
  priceCurrency_not_in?: Maybe<String[] | String>;
  priceCurrency_lt?: Maybe<String>;
  priceCurrency_lte?: Maybe<String>;
  priceCurrency_gt?: Maybe<String>;
  priceCurrency_gte?: Maybe<String>;
  priceCurrency_contains?: Maybe<String>;
  priceCurrency_not_contains?: Maybe<String>;
  priceCurrency_starts_with?: Maybe<String>;
  priceCurrency_not_starts_with?: Maybe<String>;
  priceCurrency_ends_with?: Maybe<String>;
  priceCurrency_not_ends_with?: Maybe<String>;
  productID?: Maybe<String>;
  productID_not?: Maybe<String>;
  productID_in?: Maybe<String[] | String>;
  productID_not_in?: Maybe<String[] | String>;
  productID_lt?: Maybe<String>;
  productID_lte?: Maybe<String>;
  productID_gt?: Maybe<String>;
  productID_gte?: Maybe<String>;
  productID_contains?: Maybe<String>;
  productID_not_contains?: Maybe<String>;
  productID_starts_with?: Maybe<String>;
  productID_not_starts_with?: Maybe<String>;
  productID_ends_with?: Maybe<String>;
  productID_not_ends_with?: Maybe<String>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<ProductRequestWhereInput[] | ProductRequestWhereInput>;
  OR?: Maybe<ProductRequestWhereInput[] | ProductRequestWhereInput>;
  NOT?: Maybe<ProductRequestWhereInput[] | ProductRequestWhereInput>;
}

export type ProductSeasonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductTierWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductVariantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  sku?: Maybe<String>;
}>;

export type ProductVariantFeedbackWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductVariantFeedbackQuestionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  question?: Maybe<String>;
  question_not?: Maybe<String>;
  question_in?: Maybe<String[] | String>;
  question_not_in?: Maybe<String[] | String>;
  question_lt?: Maybe<String>;
  question_lte?: Maybe<String>;
  question_gt?: Maybe<String>;
  question_gte?: Maybe<String>;
  question_contains?: Maybe<String>;
  question_not_contains?: Maybe<String>;
  question_starts_with?: Maybe<String>;
  question_not_starts_with?: Maybe<String>;
  question_ends_with?: Maybe<String>;
  question_not_ends_with?: Maybe<String>;
  type?: Maybe<QuestionType>;
  type_not?: Maybe<QuestionType>;
  type_in?: Maybe<QuestionType[] | QuestionType>;
  type_not_in?: Maybe<QuestionType[] | QuestionType>;
  variantFeedback?: Maybe<ProductVariantFeedbackWhereInput>;
  AND?: Maybe<
    | ProductVariantFeedbackQuestionWhereInput[]
    | ProductVariantFeedbackQuestionWhereInput
  >;
  OR?: Maybe<
    | ProductVariantFeedbackQuestionWhereInput[]
    | ProductVariantFeedbackQuestionWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantFeedbackQuestionWhereInput[]
    | ProductVariantFeedbackQuestionWhereInput
  >;
}

export interface ProductVariantFeedbackWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  isCompleted?: Maybe<Boolean>;
  isCompleted_not?: Maybe<Boolean>;
  questions_every?: Maybe<ProductVariantFeedbackQuestionWhereInput>;
  questions_some?: Maybe<ProductVariantFeedbackQuestionWhereInput>;
  questions_none?: Maybe<ProductVariantFeedbackQuestionWhereInput>;
  reservationFeedback?: Maybe<ReservationFeedbackWhereInput>;
  variant?: Maybe<ProductVariantWhereInput>;
  AND?: Maybe<
    ProductVariantFeedbackWhereInput[] | ProductVariantFeedbackWhereInput
  >;
  OR?: Maybe<
    ProductVariantFeedbackWhereInput[] | ProductVariantFeedbackWhereInput
  >;
  NOT?: Maybe<
    ProductVariantFeedbackWhereInput[] | ProductVariantFeedbackWhereInput
  >;
}

export interface ReservationFeedbackWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  feedbacks_every?: Maybe<ProductVariantFeedbackWhereInput>;
  feedbacks_some?: Maybe<ProductVariantFeedbackWhereInput>;
  feedbacks_none?: Maybe<ProductVariantFeedbackWhereInput>;
  rating?: Maybe<Rating>;
  rating_not?: Maybe<Rating>;
  rating_in?: Maybe<Rating[] | Rating>;
  rating_not_in?: Maybe<Rating[] | Rating>;
  user?: Maybe<UserWhereInput>;
  reservation?: Maybe<ReservationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  respondedAt?: Maybe<DateTimeInput>;
  respondedAt_not?: Maybe<DateTimeInput>;
  respondedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  respondedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  respondedAt_lt?: Maybe<DateTimeInput>;
  respondedAt_lte?: Maybe<DateTimeInput>;
  respondedAt_gt?: Maybe<DateTimeInput>;
  respondedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReservationFeedbackWhereInput[] | ReservationFeedbackWhereInput>;
  OR?: Maybe<ReservationFeedbackWhereInput[] | ReservationFeedbackWhereInput>;
  NOT?: Maybe<ReservationFeedbackWhereInput[] | ReservationFeedbackWhereInput>;
}

export type ProductVariantFeedbackQuestionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductVariantPriceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductVariantWantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductVariantWantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  productVariant?: Maybe<ProductVariantWhereInput>;
  user?: Maybe<UserWhereInput>;
  isFulfilled?: Maybe<Boolean>;
  isFulfilled_not?: Maybe<Boolean>;
  AND?: Maybe<ProductVariantWantWhereInput[] | ProductVariantWantWhereInput>;
  OR?: Maybe<ProductVariantWantWhereInput[] | ProductVariantWantWhereInput>;
  NOT?: Maybe<ProductVariantWantWhereInput[] | ProductVariantWantWhereInput>;
}

export type PushNotificationReceiptWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RecentlyViewedProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RecentlyViewedProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  product?: Maybe<ProductWhereInput>;
  customer?: Maybe<CustomerWhereInput>;
  viewCount?: Maybe<Int>;
  viewCount_not?: Maybe<Int>;
  viewCount_in?: Maybe<Int[] | Int>;
  viewCount_not_in?: Maybe<Int[] | Int>;
  viewCount_lt?: Maybe<Int>;
  viewCount_lte?: Maybe<Int>;
  viewCount_gt?: Maybe<Int>;
  viewCount_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    RecentlyViewedProductWhereInput[] | RecentlyViewedProductWhereInput
  >;
  OR?: Maybe<
    RecentlyViewedProductWhereInput[] | RecentlyViewedProductWhereInput
  >;
  NOT?: Maybe<
    RecentlyViewedProductWhereInput[] | RecentlyViewedProductWhereInput
  >;
}

export type ReservationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  reservationNumber?: Maybe<Int>;
}>;

export type ReservationFeedbackWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ReservationReceiptWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ReservationReceiptItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SeasonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ShippingMethodWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ShippingOptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ShopifyProductVariantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  externalId?: Maybe<String>;
}>;

export type SizeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export type SmsReceiptWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StylePreferencesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SyncTimingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SyncTimingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<SyncTimingType>;
  type_not?: Maybe<SyncTimingType>;
  type_in?: Maybe<SyncTimingType[] | SyncTimingType>;
  type_not_in?: Maybe<SyncTimingType[] | SyncTimingType>;
  syncedAt?: Maybe<DateTimeInput>;
  syncedAt_not?: Maybe<DateTimeInput>;
  syncedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  syncedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  syncedAt_lt?: Maybe<DateTimeInput>;
  syncedAt_lte?: Maybe<DateTimeInput>;
  syncedAt_gt?: Maybe<DateTimeInput>;
  syncedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SyncTimingWhereInput[] | SyncTimingWhereInput>;
  OR?: Maybe<SyncTimingWhereInput[] | SyncTimingWhereInput>;
  NOT?: Maybe<SyncTimingWhereInput[] | SyncTimingWhereInput>;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type TopSizeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UTMDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
}>;

export type UserPushNotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserPushNotificationInterestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WarehouseLocationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  barcode?: Maybe<String>;
}>;

export type WarehouseLocationConstraintWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ActiveAdminUserCreateInput {
  id?: Maybe<ID_Input>;
  admin: UserCreateOneInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserCreaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotifications?: Maybe<PushNotificationReceiptCreateManyWithoutUsersInput>;
  emails?: Maybe<EmailReceiptCreateManyWithoutUserInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationCreateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptCreateManyInput>;
  fitPics?: Maybe<FitPicCreateManyWithoutUserInput>;
}

export interface UserCreaterolesInput {
  set?: Maybe<UserRole[] | UserRole>;
}

export interface PushNotificationReceiptCreateManyWithoutUsersInput {
  create?: Maybe<
    | PushNotificationReceiptCreateWithoutUsersInput[]
    | PushNotificationReceiptCreateWithoutUsersInput
  >;
  connect?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
}

export interface PushNotificationReceiptCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  route?: Maybe<String>;
  screen?: Maybe<String>;
  uri?: Maybe<String>;
  interest?: Maybe<String>;
  body: String;
  title?: Maybe<String>;
  recordID?: Maybe<String>;
  recordSlug?: Maybe<String>;
  notificationKey?: Maybe<String>;
  sentAt: DateTimeInput;
}

export interface EmailReceiptCreateManyWithoutUserInput {
  create?: Maybe<
    EmailReceiptCreateWithoutUserInput[] | EmailReceiptCreateWithoutUserInput
  >;
  connect?: Maybe<
    EmailReceiptWhereUniqueInput[] | EmailReceiptWhereUniqueInput
  >;
}

export interface EmailReceiptCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  emailId: EmailId;
}

export interface UserPushNotificationCreateOneInput {
  create?: Maybe<UserPushNotificationCreateInput>;
  connect?: Maybe<UserPushNotificationWhereUniqueInput>;
}

export interface UserPushNotificationCreateInput {
  id?: Maybe<ID_Input>;
  interests?: Maybe<UserPushNotificationInterestCreateManyInput>;
  status?: Maybe<Boolean>;
  history?: Maybe<PushNotificationReceiptCreateManyInput>;
}

export interface UserPushNotificationInterestCreateManyInput {
  create?: Maybe<
    | UserPushNotificationInterestCreateInput[]
    | UserPushNotificationInterestCreateInput
  >;
  connect?: Maybe<
    | UserPushNotificationInterestWhereUniqueInput[]
    | UserPushNotificationInterestWhereUniqueInput
  >;
}

export interface UserPushNotificationInterestCreateInput {
  id?: Maybe<ID_Input>;
  type: UserPushNotificationInterestType;
  value: String;
  user: UserCreateOneInput;
  status?: Maybe<Boolean>;
}

export interface PushNotificationReceiptCreateManyInput {
  create?: Maybe<
    PushNotificationReceiptCreateInput[] | PushNotificationReceiptCreateInput
  >;
  connect?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
}

export interface PushNotificationReceiptCreateInput {
  id?: Maybe<ID_Input>;
  route?: Maybe<String>;
  screen?: Maybe<String>;
  uri?: Maybe<String>;
  users?: Maybe<UserCreateManyWithoutPushNotificationsInput>;
  interest?: Maybe<String>;
  body: String;
  title?: Maybe<String>;
  recordID?: Maybe<String>;
  recordSlug?: Maybe<String>;
  notificationKey?: Maybe<String>;
  sentAt: DateTimeInput;
}

export interface UserCreateManyWithoutPushNotificationsInput {
  create?: Maybe<
    | UserCreateWithoutPushNotificationsInput[]
    | UserCreateWithoutPushNotificationsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutPushNotificationsInput {
  id?: Maybe<ID_Input>;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserCreaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  emails?: Maybe<EmailReceiptCreateManyWithoutUserInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationCreateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptCreateManyInput>;
  fitPics?: Maybe<FitPicCreateManyWithoutUserInput>;
}

export interface SmsReceiptCreateManyInput {
  create?: Maybe<SmsReceiptCreateInput[] | SmsReceiptCreateInput>;
  connect?: Maybe<SmsReceiptWhereUniqueInput[] | SmsReceiptWhereUniqueInput>;
}

export interface SmsReceiptCreateInput {
  id?: Maybe<ID_Input>;
  externalId?: Maybe<String>;
  body: String;
  mediaUrls?: Maybe<SmsReceiptCreatemediaUrlsInput>;
  status: SmsStatus;
  smsId?: Maybe<String>;
}

export interface SmsReceiptCreatemediaUrlsInput {
  set?: Maybe<String[] | String>;
}

export interface FitPicCreateManyWithoutUserInput {
  create?: Maybe<FitPicCreateWithoutUserInput[] | FitPicCreateWithoutUserInput>;
  connect?: Maybe<FitPicWhereUniqueInput[] | FitPicWhereUniqueInput>;
}

export interface FitPicCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  image: ImageCreateOneInput;
  includeInstagramHandle?: Maybe<Boolean>;
  location?: Maybe<LocationCreateOneInput>;
  products?: Maybe<ProductCreateManyInput>;
  reports?: Maybe<FitPicReportCreateManyWithoutReportedInput>;
  status?: Maybe<FitPicStatus>;
}

export interface ImageCreateOneInput {
  create?: Maybe<ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ImageCreateInput {
  id?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  url: String;
  height?: Maybe<Int>;
  width?: Maybe<Int>;
  title?: Maybe<String>;
}

export interface LocationCreateOneInput {
  create?: Maybe<LocationCreateInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode: String;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserCreateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutLocationInput>;
  shippingOptions?: Maybe<ShippingOptionCreateManyWithoutDestinationInput>;
}

export interface PhysicalProductCreateManyWithoutLocationInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutLocationInput[]
    | PhysicalProductCreateWithoutLocationInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
}

export interface PhysicalProductCreateWithoutLocationInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber: Int;
  warehouseLocation?: Maybe<
    WarehouseLocationCreateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceCreateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportCreateManyWithoutPhysicalProductInput
  >;
}

export interface ProductVariantCreateOneWithoutPhysicalProductsInput {
  create?: Maybe<ProductVariantCreateWithoutPhysicalProductsInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface ProductVariantCreateWithoutPhysicalProductsInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  displayShort: String;
  color: ColorCreateOneWithoutProductVariantsInput;
  internalSize?: Maybe<SizeCreateOneInput>;
  manufacturerSizes?: Maybe<SizeCreateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  product: ProductCreateOneWithoutVariantsInput;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceCreateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantCreateOneInput>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  offloaded: Int;
  stored: Int;
}

export interface ColorCreateOneWithoutProductVariantsInput {
  create?: Maybe<ColorCreateWithoutProductVariantsInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface ColorCreateWithoutProductVariantsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
}

export interface SizeCreateOneInput {
  create?: Maybe<SizeCreateInput>;
  connect?: Maybe<SizeWhereUniqueInput>;
}

export interface SizeCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  productType?: Maybe<ProductType>;
  top?: Maybe<TopSizeCreateOneInput>;
  bottom?: Maybe<BottomSizeCreateOneInput>;
  display: String;
}

export interface TopSizeCreateOneInput {
  create?: Maybe<TopSizeCreateInput>;
  connect?: Maybe<TopSizeWhereUniqueInput>;
}

export interface TopSizeCreateInput {
  id?: Maybe<ID_Input>;
  letter?: Maybe<LetterSize>;
  sleeve?: Maybe<Float>;
  shoulder?: Maybe<Float>;
  chest?: Maybe<Float>;
  neck?: Maybe<Float>;
  length?: Maybe<Float>;
}

export interface BottomSizeCreateOneInput {
  create?: Maybe<BottomSizeCreateInput>;
  connect?: Maybe<BottomSizeWhereUniqueInput>;
}

export interface BottomSizeCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<BottomSizeType>;
  value?: Maybe<String>;
  waist?: Maybe<Float>;
  rise?: Maybe<Float>;
  hem?: Maybe<Float>;
  inseam?: Maybe<Float>;
}

export interface SizeCreateManyInput {
  create?: Maybe<SizeCreateInput[] | SizeCreateInput>;
  connect?: Maybe<SizeWhereUniqueInput[] | SizeWhereUniqueInput>;
}

export interface ProductCreateOneWithoutVariantsInput {
  create?: Maybe<ProductCreateWithoutVariantsInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductCreateWithoutVariantsInput {
  id?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  brand: BrandCreateOneWithoutProductsInput;
  category: CategoryCreateOneWithoutProductsInput;
  color: ColorCreateOneInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageCreateManyInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryCreateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelCreateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeCreateOneInput>;
  name: String;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonCreateOneInput>;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  slug: String;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagCreateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierCreateOneInput>;
  type?: Maybe<ProductType>;
}

export interface BrandCreateOneWithoutProductsInput {
  create?: Maybe<BrandCreateWithoutProductsInput>;
  connect?: Maybe<BrandWhereUniqueInput>;
}

export interface BrandCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  brandCode: String;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name: String;
  designer?: Maybe<String>;
  basedIn?: Maybe<String>;
  images?: Maybe<ImageCreateManyInput>;
  since?: Maybe<DateTimeInput>;
  tier: BrandTier;
  published?: Maybe<Boolean>;
  featured?: Maybe<Boolean>;
  websiteUrl?: Maybe<String>;
  externalShopifyIntegration?: Maybe<ExternalShopifyIntegrationCreateOneInput>;
}

export interface ImageCreateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
}

export interface ExternalShopifyIntegrationCreateOneInput {
  create?: Maybe<ExternalShopifyIntegrationCreateInput>;
  connect?: Maybe<ExternalShopifyIntegrationWhereUniqueInput>;
}

export interface ExternalShopifyIntegrationCreateInput {
  id?: Maybe<ID_Input>;
  shopName: String;
  enabled: Boolean;
  accessToken?: Maybe<String>;
  nonce?: Maybe<String>;
}

export interface CategoryCreateOneWithoutProductsInput {
  create?: Maybe<CategoryCreateWithoutProductsInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  children?: Maybe<CategoryCreateManyWithoutChildrenInput>;
}

export interface CategoryCreateManyWithoutChildrenInput {
  create?: Maybe<
    CategoryCreateWithoutChildrenInput[] | CategoryCreateWithoutChildrenInput
  >;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
}

export interface CategoryCreateWithoutChildrenInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductCreateManyWithoutCategoryInput>;
}

export interface ProductCreateManyWithoutCategoryInput {
  create?: Maybe<
    ProductCreateWithoutCategoryInput[] | ProductCreateWithoutCategoryInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  brand: BrandCreateOneWithoutProductsInput;
  color: ColorCreateOneInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageCreateManyInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryCreateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelCreateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeCreateOneInput>;
  name: String;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonCreateOneInput>;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  slug: String;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagCreateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierCreateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
}

export interface ColorCreateOneInput {
  create?: Maybe<ColorCreateInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface ColorCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
  productVariants?: Maybe<ProductVariantCreateManyWithoutColorInput>;
}

export interface ProductVariantCreateManyWithoutColorInput {
  create?: Maybe<
    | ProductVariantCreateWithoutColorInput[]
    | ProductVariantCreateWithoutColorInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
}

export interface ProductVariantCreateWithoutColorInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  displayShort: String;
  internalSize?: Maybe<SizeCreateOneInput>;
  manufacturerSizes?: Maybe<SizeCreateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  product: ProductCreateOneWithoutVariantsInput;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceCreateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantCreateOneInput>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutProductVariantInput>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  offloaded: Int;
  stored: Int;
}

export interface ProductVariantPriceCreateOneInput {
  create?: Maybe<ProductVariantPriceCreateInput>;
  connect?: Maybe<ProductVariantPriceWhereUniqueInput>;
}

export interface ProductVariantPriceCreateInput {
  id?: Maybe<ID_Input>;
  retailPrice?: Maybe<Float>;
}

export interface ShopifyProductVariantCreateOneInput {
  create?: Maybe<ShopifyProductVariantCreateInput>;
  connect?: Maybe<ShopifyProductVariantWhereUniqueInput>;
}

export interface ShopifyProductVariantCreateInput {
  id?: Maybe<ID_Input>;
  externalId?: Maybe<String>;
  cachedPrice?: Maybe<Float>;
  cachedAvailableForSale?: Maybe<Boolean>;
  cacheExpiresAt?: Maybe<DateTimeInput>;
}

export interface PhysicalProductCreateManyWithoutProductVariantInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutProductVariantInput[]
    | PhysicalProductCreateWithoutProductVariantInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
}

export interface PhysicalProductCreateWithoutProductVariantInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  location?: Maybe<LocationCreateOneWithoutPhysicalProductsInput>;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber: Int;
  warehouseLocation?: Maybe<
    WarehouseLocationCreateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceCreateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportCreateManyWithoutPhysicalProductInput
  >;
}

export interface LocationCreateOneWithoutPhysicalProductsInput {
  create?: Maybe<LocationCreateWithoutPhysicalProductsInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationCreateWithoutPhysicalProductsInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode: String;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserCreateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  shippingOptions?: Maybe<ShippingOptionCreateManyWithoutDestinationInput>;
}

export interface ShippingOptionCreateManyWithoutDestinationInput {
  create?: Maybe<
    | ShippingOptionCreateWithoutDestinationInput[]
    | ShippingOptionCreateWithoutDestinationInput
  >;
  connect?: Maybe<
    ShippingOptionWhereUniqueInput[] | ShippingOptionWhereUniqueInput
  >;
}

export interface ShippingOptionCreateWithoutDestinationInput {
  id?: Maybe<ID_Input>;
  origin?: Maybe<LocationCreateOneInput>;
  shippingMethod?: Maybe<ShippingMethodCreateOneInput>;
  externalCost?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
}

export interface ShippingMethodCreateOneInput {
  create?: Maybe<ShippingMethodCreateInput>;
  connect?: Maybe<ShippingMethodWhereUniqueInput>;
}

export interface ShippingMethodCreateInput {
  id?: Maybe<ID_Input>;
  code: ShippingCode;
  displayText: String;
}

export interface WarehouseLocationCreateOneWithoutPhysicalProductsInput {
  create?: Maybe<WarehouseLocationCreateWithoutPhysicalProductsInput>;
  connect?: Maybe<WarehouseLocationWhereUniqueInput>;
}

export interface WarehouseLocationCreateWithoutPhysicalProductsInput {
  id?: Maybe<ID_Input>;
  type: WarehouseLocationType;
  barcode: String;
  locationCode: String;
  itemCode: String;
  constraints?: Maybe<
    WarehouseLocationConstraintCreateManyWithoutLocationsInput
  >;
}

export interface WarehouseLocationConstraintCreateManyWithoutLocationsInput {
  create?: Maybe<
    | WarehouseLocationConstraintCreateWithoutLocationsInput[]
    | WarehouseLocationConstraintCreateWithoutLocationsInput
  >;
  connect?: Maybe<
    | WarehouseLocationConstraintWhereUniqueInput[]
    | WarehouseLocationConstraintWhereUniqueInput
  >;
}

export interface WarehouseLocationConstraintCreateWithoutLocationsInput {
  id?: Maybe<ID_Input>;
  category: CategoryCreateOneInput;
  limit: Int;
}

export interface CategoryCreateOneInput {
  create?: Maybe<CategoryCreateInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductCreateManyWithoutCategoryInput>;
  children?: Maybe<CategoryCreateManyWithoutChildrenInput>;
}

export interface PhysicalProductPriceCreateOneInput {
  create?: Maybe<PhysicalProductPriceCreateInput>;
  connect?: Maybe<PhysicalProductPriceWhereUniqueInput>;
}

export interface PhysicalProductPriceCreateInput {
  id?: Maybe<ID_Input>;
  buyUsedEnabled?: Maybe<Boolean>;
  buyUsedPrice?: Maybe<Float>;
}

export interface PhysicalProductQualityReportCreateManyWithoutPhysicalProductInput {
  create?: Maybe<
    | PhysicalProductQualityReportCreateWithoutPhysicalProductInput[]
    | PhysicalProductQualityReportCreateWithoutPhysicalProductInput
  >;
  connect?: Maybe<
    | PhysicalProductQualityReportWhereUniqueInput[]
    | PhysicalProductQualityReportWhereUniqueInput
  >;
}

export interface PhysicalProductQualityReportCreateWithoutPhysicalProductInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  damageType?: Maybe<PhysicalProductDamageType>;
  notes?: Maybe<String>;
}

export interface ProductFunctionCreateManyInput {
  create?: Maybe<ProductFunctionCreateInput[] | ProductFunctionCreateInput>;
  connect?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
}

export interface ProductFunctionCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface ProductCreateinnerMaterialsInput {
  set?: Maybe<String[] | String>;
}

export interface ProductMaterialCategoryCreateOneWithoutProductsInput {
  create?: Maybe<ProductMaterialCategoryCreateWithoutProductsInput>;
  connect?: Maybe<ProductMaterialCategoryWhereUniqueInput>;
}

export interface ProductMaterialCategoryCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  lifeExpectancy: Float;
  category: CategoryCreateOneInput;
}

export interface ProductModelCreateOneWithoutProductsInput {
  create?: Maybe<ProductModelCreateWithoutProductsInput>;
  connect?: Maybe<ProductModelWhereUniqueInput>;
}

export interface ProductModelCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  name: String;
  height: Float;
}

export interface ProductCreateouterMaterialsInput {
  set?: Maybe<String[] | String>;
}

export interface ProductSeasonCreateOneInput {
  create?: Maybe<ProductSeasonCreateInput>;
  connect?: Maybe<ProductSeasonWhereUniqueInput>;
}

export interface ProductSeasonCreateInput {
  id?: Maybe<ID_Input>;
  vendorSeason?: Maybe<SeasonCreateOneInput>;
  internalSeason?: Maybe<SeasonCreateOneInput>;
  wearableSeasons?: Maybe<ProductSeasonCreatewearableSeasonsInput>;
}

export interface SeasonCreateOneInput {
  create?: Maybe<SeasonCreateInput>;
  connect?: Maybe<SeasonWhereUniqueInput>;
}

export interface SeasonCreateInput {
  id?: Maybe<ID_Input>;
  year?: Maybe<Int>;
  seasonCode?: Maybe<SeasonCode>;
}

export interface ProductSeasonCreatewearableSeasonsInput {
  set?: Maybe<SeasonString[] | SeasonString>;
}

export interface TagCreateManyWithoutProductsInput {
  create?: Maybe<
    TagCreateWithoutProductsInput[] | TagCreateWithoutProductsInput
  >;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
}

export interface ProductTierCreateOneInput {
  create?: Maybe<ProductTierCreateInput>;
  connect?: Maybe<ProductTierWhereUniqueInput>;
}

export interface ProductTierCreateInput {
  id?: Maybe<ID_Input>;
  tier: ProductTierName;
  price: Int;
}

export interface ProductVariantCreateManyWithoutProductInput {
  create?: Maybe<
    | ProductVariantCreateWithoutProductInput[]
    | ProductVariantCreateWithoutProductInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
}

export interface ProductVariantCreateWithoutProductInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  displayShort: String;
  color: ColorCreateOneWithoutProductVariantsInput;
  internalSize?: Maybe<SizeCreateOneInput>;
  manufacturerSizes?: Maybe<SizeCreateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceCreateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantCreateOneInput>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutProductVariantInput>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  offloaded: Int;
  stored: Int;
}

export interface ProductCreateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  brand: BrandCreateOneWithoutProductsInput;
  category: CategoryCreateOneWithoutProductsInput;
  color: ColorCreateOneInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageCreateManyInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryCreateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelCreateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeCreateOneInput>;
  name: String;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonCreateOneInput>;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  slug: String;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagCreateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierCreateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
}

export interface FitPicReportCreateManyWithoutReportedInput {
  create?: Maybe<
    | FitPicReportCreateWithoutReportedInput[]
    | FitPicReportCreateWithoutReportedInput
  >;
  connect?: Maybe<
    FitPicReportWhereUniqueInput[] | FitPicReportWhereUniqueInput
  >;
}

export interface FitPicReportCreateWithoutReportedInput {
  id?: Maybe<ID_Input>;
  reporter: UserCreateOneInput;
  status?: Maybe<FitPicReportStatus>;
}

export interface ActiveAdminUserUpdateInput {
  admin?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserUpdaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotifications?: Maybe<PushNotificationReceiptUpdateManyWithoutUsersInput>;
  emails?: Maybe<EmailReceiptUpdateManyWithoutUserInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationUpdateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptUpdateManyInput>;
  fitPics?: Maybe<FitPicUpdateManyWithoutUserInput>;
}

export interface UserUpdaterolesInput {
  set?: Maybe<UserRole[] | UserRole>;
}

export interface PushNotificationReceiptUpdateManyWithoutUsersInput {
  create?: Maybe<
    | PushNotificationReceiptCreateWithoutUsersInput[]
    | PushNotificationReceiptCreateWithoutUsersInput
  >;
  delete?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  connect?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  set?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  disconnect?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  update?: Maybe<
    | PushNotificationReceiptUpdateWithWhereUniqueWithoutUsersInput[]
    | PushNotificationReceiptUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | PushNotificationReceiptUpsertWithWhereUniqueWithoutUsersInput[]
    | PushNotificationReceiptUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<
    | PushNotificationReceiptScalarWhereInput[]
    | PushNotificationReceiptScalarWhereInput
  >;
  updateMany?: Maybe<
    | PushNotificationReceiptUpdateManyWithWhereNestedInput[]
    | PushNotificationReceiptUpdateManyWithWhereNestedInput
  >;
}

export interface PushNotificationReceiptUpdateWithWhereUniqueWithoutUsersInput {
  where: PushNotificationReceiptWhereUniqueInput;
  data: PushNotificationReceiptUpdateWithoutUsersDataInput;
}

export interface PushNotificationReceiptUpdateWithoutUsersDataInput {
  route?: Maybe<String>;
  screen?: Maybe<String>;
  uri?: Maybe<String>;
  interest?: Maybe<String>;
  body?: Maybe<String>;
  title?: Maybe<String>;
  recordID?: Maybe<String>;
  recordSlug?: Maybe<String>;
  notificationKey?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
}

export interface PushNotificationReceiptUpsertWithWhereUniqueWithoutUsersInput {
  where: PushNotificationReceiptWhereUniqueInput;
  update: PushNotificationReceiptUpdateWithoutUsersDataInput;
  create: PushNotificationReceiptCreateWithoutUsersInput;
}

export interface PushNotificationReceiptScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  route?: Maybe<String>;
  route_not?: Maybe<String>;
  route_in?: Maybe<String[] | String>;
  route_not_in?: Maybe<String[] | String>;
  route_lt?: Maybe<String>;
  route_lte?: Maybe<String>;
  route_gt?: Maybe<String>;
  route_gte?: Maybe<String>;
  route_contains?: Maybe<String>;
  route_not_contains?: Maybe<String>;
  route_starts_with?: Maybe<String>;
  route_not_starts_with?: Maybe<String>;
  route_ends_with?: Maybe<String>;
  route_not_ends_with?: Maybe<String>;
  screen?: Maybe<String>;
  screen_not?: Maybe<String>;
  screen_in?: Maybe<String[] | String>;
  screen_not_in?: Maybe<String[] | String>;
  screen_lt?: Maybe<String>;
  screen_lte?: Maybe<String>;
  screen_gt?: Maybe<String>;
  screen_gte?: Maybe<String>;
  screen_contains?: Maybe<String>;
  screen_not_contains?: Maybe<String>;
  screen_starts_with?: Maybe<String>;
  screen_not_starts_with?: Maybe<String>;
  screen_ends_with?: Maybe<String>;
  screen_not_ends_with?: Maybe<String>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  interest?: Maybe<String>;
  interest_not?: Maybe<String>;
  interest_in?: Maybe<String[] | String>;
  interest_not_in?: Maybe<String[] | String>;
  interest_lt?: Maybe<String>;
  interest_lte?: Maybe<String>;
  interest_gt?: Maybe<String>;
  interest_gte?: Maybe<String>;
  interest_contains?: Maybe<String>;
  interest_not_contains?: Maybe<String>;
  interest_starts_with?: Maybe<String>;
  interest_not_starts_with?: Maybe<String>;
  interest_ends_with?: Maybe<String>;
  interest_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  recordID?: Maybe<String>;
  recordID_not?: Maybe<String>;
  recordID_in?: Maybe<String[] | String>;
  recordID_not_in?: Maybe<String[] | String>;
  recordID_lt?: Maybe<String>;
  recordID_lte?: Maybe<String>;
  recordID_gt?: Maybe<String>;
  recordID_gte?: Maybe<String>;
  recordID_contains?: Maybe<String>;
  recordID_not_contains?: Maybe<String>;
  recordID_starts_with?: Maybe<String>;
  recordID_not_starts_with?: Maybe<String>;
  recordID_ends_with?: Maybe<String>;
  recordID_not_ends_with?: Maybe<String>;
  recordSlug?: Maybe<String>;
  recordSlug_not?: Maybe<String>;
  recordSlug_in?: Maybe<String[] | String>;
  recordSlug_not_in?: Maybe<String[] | String>;
  recordSlug_lt?: Maybe<String>;
  recordSlug_lte?: Maybe<String>;
  recordSlug_gt?: Maybe<String>;
  recordSlug_gte?: Maybe<String>;
  recordSlug_contains?: Maybe<String>;
  recordSlug_not_contains?: Maybe<String>;
  recordSlug_starts_with?: Maybe<String>;
  recordSlug_not_starts_with?: Maybe<String>;
  recordSlug_ends_with?: Maybe<String>;
  recordSlug_not_ends_with?: Maybe<String>;
  notificationKey?: Maybe<String>;
  notificationKey_not?: Maybe<String>;
  notificationKey_in?: Maybe<String[] | String>;
  notificationKey_not_in?: Maybe<String[] | String>;
  notificationKey_lt?: Maybe<String>;
  notificationKey_lte?: Maybe<String>;
  notificationKey_gt?: Maybe<String>;
  notificationKey_gte?: Maybe<String>;
  notificationKey_contains?: Maybe<String>;
  notificationKey_not_contains?: Maybe<String>;
  notificationKey_starts_with?: Maybe<String>;
  notificationKey_not_starts_with?: Maybe<String>;
  notificationKey_ends_with?: Maybe<String>;
  notificationKey_not_ends_with?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
  sentAt_not?: Maybe<DateTimeInput>;
  sentAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_lt?: Maybe<DateTimeInput>;
  sentAt_lte?: Maybe<DateTimeInput>;
  sentAt_gt?: Maybe<DateTimeInput>;
  sentAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | PushNotificationReceiptScalarWhereInput[]
    | PushNotificationReceiptScalarWhereInput
  >;
  OR?: Maybe<
    | PushNotificationReceiptScalarWhereInput[]
    | PushNotificationReceiptScalarWhereInput
  >;
  NOT?: Maybe<
    | PushNotificationReceiptScalarWhereInput[]
    | PushNotificationReceiptScalarWhereInput
  >;
}

export interface PushNotificationReceiptUpdateManyWithWhereNestedInput {
  where: PushNotificationReceiptScalarWhereInput;
  data: PushNotificationReceiptUpdateManyDataInput;
}

export interface PushNotificationReceiptUpdateManyDataInput {
  route?: Maybe<String>;
  screen?: Maybe<String>;
  uri?: Maybe<String>;
  interest?: Maybe<String>;
  body?: Maybe<String>;
  title?: Maybe<String>;
  recordID?: Maybe<String>;
  recordSlug?: Maybe<String>;
  notificationKey?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
}

export interface EmailReceiptUpdateManyWithoutUserInput {
  create?: Maybe<
    EmailReceiptCreateWithoutUserInput[] | EmailReceiptCreateWithoutUserInput
  >;
  delete?: Maybe<EmailReceiptWhereUniqueInput[] | EmailReceiptWhereUniqueInput>;
  connect?: Maybe<
    EmailReceiptWhereUniqueInput[] | EmailReceiptWhereUniqueInput
  >;
  set?: Maybe<EmailReceiptWhereUniqueInput[] | EmailReceiptWhereUniqueInput>;
  disconnect?: Maybe<
    EmailReceiptWhereUniqueInput[] | EmailReceiptWhereUniqueInput
  >;
  update?: Maybe<
    | EmailReceiptUpdateWithWhereUniqueWithoutUserInput[]
    | EmailReceiptUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | EmailReceiptUpsertWithWhereUniqueWithoutUserInput[]
    | EmailReceiptUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    EmailReceiptScalarWhereInput[] | EmailReceiptScalarWhereInput
  >;
  updateMany?: Maybe<
    | EmailReceiptUpdateManyWithWhereNestedInput[]
    | EmailReceiptUpdateManyWithWhereNestedInput
  >;
}

export interface EmailReceiptUpdateWithWhereUniqueWithoutUserInput {
  where: EmailReceiptWhereUniqueInput;
  data: EmailReceiptUpdateWithoutUserDataInput;
}

export interface EmailReceiptUpdateWithoutUserDataInput {
  emailId?: Maybe<EmailId>;
}

export interface EmailReceiptUpsertWithWhereUniqueWithoutUserInput {
  where: EmailReceiptWhereUniqueInput;
  update: EmailReceiptUpdateWithoutUserDataInput;
  create: EmailReceiptCreateWithoutUserInput;
}

export interface EmailReceiptScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  emailId?: Maybe<EmailId>;
  emailId_not?: Maybe<EmailId>;
  emailId_in?: Maybe<EmailId[] | EmailId>;
  emailId_not_in?: Maybe<EmailId[] | EmailId>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmailReceiptScalarWhereInput[] | EmailReceiptScalarWhereInput>;
  OR?: Maybe<EmailReceiptScalarWhereInput[] | EmailReceiptScalarWhereInput>;
  NOT?: Maybe<EmailReceiptScalarWhereInput[] | EmailReceiptScalarWhereInput>;
}

export interface EmailReceiptUpdateManyWithWhereNestedInput {
  where: EmailReceiptScalarWhereInput;
  data: EmailReceiptUpdateManyDataInput;
}

export interface EmailReceiptUpdateManyDataInput {
  emailId?: Maybe<EmailId>;
}

export interface UserPushNotificationUpdateOneInput {
  create?: Maybe<UserPushNotificationCreateInput>;
  update?: Maybe<UserPushNotificationUpdateDataInput>;
  upsert?: Maybe<UserPushNotificationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserPushNotificationWhereUniqueInput>;
}

export interface UserPushNotificationUpdateDataInput {
  interests?: Maybe<UserPushNotificationInterestUpdateManyInput>;
  status?: Maybe<Boolean>;
  history?: Maybe<PushNotificationReceiptUpdateManyInput>;
}

export interface UserPushNotificationInterestUpdateManyInput {
  create?: Maybe<
    | UserPushNotificationInterestCreateInput[]
    | UserPushNotificationInterestCreateInput
  >;
  update?: Maybe<
    | UserPushNotificationInterestUpdateWithWhereUniqueNestedInput[]
    | UserPushNotificationInterestUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserPushNotificationInterestUpsertWithWhereUniqueNestedInput[]
    | UserPushNotificationInterestUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | UserPushNotificationInterestWhereUniqueInput[]
    | UserPushNotificationInterestWhereUniqueInput
  >;
  connect?: Maybe<
    | UserPushNotificationInterestWhereUniqueInput[]
    | UserPushNotificationInterestWhereUniqueInput
  >;
  set?: Maybe<
    | UserPushNotificationInterestWhereUniqueInput[]
    | UserPushNotificationInterestWhereUniqueInput
  >;
  disconnect?: Maybe<
    | UserPushNotificationInterestWhereUniqueInput[]
    | UserPushNotificationInterestWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | UserPushNotificationInterestScalarWhereInput[]
    | UserPushNotificationInterestScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserPushNotificationInterestUpdateManyWithWhereNestedInput[]
    | UserPushNotificationInterestUpdateManyWithWhereNestedInput
  >;
}

export interface UserPushNotificationInterestUpdateWithWhereUniqueNestedInput {
  where: UserPushNotificationInterestWhereUniqueInput;
  data: UserPushNotificationInterestUpdateDataInput;
}

export interface UserPushNotificationInterestUpdateDataInput {
  type?: Maybe<UserPushNotificationInterestType>;
  value?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<Boolean>;
}

export interface UserPushNotificationInterestUpsertWithWhereUniqueNestedInput {
  where: UserPushNotificationInterestWhereUniqueInput;
  update: UserPushNotificationInterestUpdateDataInput;
  create: UserPushNotificationInterestCreateInput;
}

export interface UserPushNotificationInterestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<UserPushNotificationInterestType>;
  type_not?: Maybe<UserPushNotificationInterestType>;
  type_in?: Maybe<
    UserPushNotificationInterestType[] | UserPushNotificationInterestType
  >;
  type_not_in?: Maybe<
    UserPushNotificationInterestType[] | UserPushNotificationInterestType
  >;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  AND?: Maybe<
    | UserPushNotificationInterestScalarWhereInput[]
    | UserPushNotificationInterestScalarWhereInput
  >;
  OR?: Maybe<
    | UserPushNotificationInterestScalarWhereInput[]
    | UserPushNotificationInterestScalarWhereInput
  >;
  NOT?: Maybe<
    | UserPushNotificationInterestScalarWhereInput[]
    | UserPushNotificationInterestScalarWhereInput
  >;
}

export interface UserPushNotificationInterestUpdateManyWithWhereNestedInput {
  where: UserPushNotificationInterestScalarWhereInput;
  data: UserPushNotificationInterestUpdateManyDataInput;
}

export interface UserPushNotificationInterestUpdateManyDataInput {
  type?: Maybe<UserPushNotificationInterestType>;
  value?: Maybe<String>;
  status?: Maybe<Boolean>;
}

export interface PushNotificationReceiptUpdateManyInput {
  create?: Maybe<
    PushNotificationReceiptCreateInput[] | PushNotificationReceiptCreateInput
  >;
  update?: Maybe<
    | PushNotificationReceiptUpdateWithWhereUniqueNestedInput[]
    | PushNotificationReceiptUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PushNotificationReceiptUpsertWithWhereUniqueNestedInput[]
    | PushNotificationReceiptUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  connect?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  set?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  disconnect?: Maybe<
    | PushNotificationReceiptWhereUniqueInput[]
    | PushNotificationReceiptWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | PushNotificationReceiptScalarWhereInput[]
    | PushNotificationReceiptScalarWhereInput
  >;
  updateMany?: Maybe<
    | PushNotificationReceiptUpdateManyWithWhereNestedInput[]
    | PushNotificationReceiptUpdateManyWithWhereNestedInput
  >;
}

export interface PushNotificationReceiptUpdateWithWhereUniqueNestedInput {
  where: PushNotificationReceiptWhereUniqueInput;
  data: PushNotificationReceiptUpdateDataInput;
}

export interface PushNotificationReceiptUpdateDataInput {
  route?: Maybe<String>;
  screen?: Maybe<String>;
  uri?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutPushNotificationsInput>;
  interest?: Maybe<String>;
  body?: Maybe<String>;
  title?: Maybe<String>;
  recordID?: Maybe<String>;
  recordSlug?: Maybe<String>;
  notificationKey?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyWithoutPushNotificationsInput {
  create?: Maybe<
    | UserCreateWithoutPushNotificationsInput[]
    | UserCreateWithoutPushNotificationsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutPushNotificationsInput[]
    | UserUpdateWithWhereUniqueWithoutPushNotificationsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutPushNotificationsInput[]
    | UserUpsertWithWhereUniqueWithoutPushNotificationsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutPushNotificationsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutPushNotificationsDataInput;
}

export interface UserUpdateWithoutPushNotificationsDataInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserUpdaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  emails?: Maybe<EmailReceiptUpdateManyWithoutUserInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationUpdateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptUpdateManyInput>;
  fitPics?: Maybe<FitPicUpdateManyWithoutUserInput>;
}

export interface SmsReceiptUpdateManyInput {
  create?: Maybe<SmsReceiptCreateInput[] | SmsReceiptCreateInput>;
  update?: Maybe<
    | SmsReceiptUpdateWithWhereUniqueNestedInput[]
    | SmsReceiptUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SmsReceiptUpsertWithWhereUniqueNestedInput[]
    | SmsReceiptUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SmsReceiptWhereUniqueInput[] | SmsReceiptWhereUniqueInput>;
  connect?: Maybe<SmsReceiptWhereUniqueInput[] | SmsReceiptWhereUniqueInput>;
  set?: Maybe<SmsReceiptWhereUniqueInput[] | SmsReceiptWhereUniqueInput>;
  disconnect?: Maybe<SmsReceiptWhereUniqueInput[] | SmsReceiptWhereUniqueInput>;
  deleteMany?: Maybe<SmsReceiptScalarWhereInput[] | SmsReceiptScalarWhereInput>;
  updateMany?: Maybe<
    | SmsReceiptUpdateManyWithWhereNestedInput[]
    | SmsReceiptUpdateManyWithWhereNestedInput
  >;
}

export interface SmsReceiptUpdateWithWhereUniqueNestedInput {
  where: SmsReceiptWhereUniqueInput;
  data: SmsReceiptUpdateDataInput;
}

export interface SmsReceiptUpdateDataInput {
  externalId?: Maybe<String>;
  body?: Maybe<String>;
  mediaUrls?: Maybe<SmsReceiptUpdatemediaUrlsInput>;
  status?: Maybe<SmsStatus>;
  smsId?: Maybe<String>;
}

export interface SmsReceiptUpdatemediaUrlsInput {
  set?: Maybe<String[] | String>;
}

export interface SmsReceiptUpsertWithWhereUniqueNestedInput {
  where: SmsReceiptWhereUniqueInput;
  update: SmsReceiptUpdateDataInput;
  create: SmsReceiptCreateInput;
}

export interface SmsReceiptScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  externalId?: Maybe<String>;
  externalId_not?: Maybe<String>;
  externalId_in?: Maybe<String[] | String>;
  externalId_not_in?: Maybe<String[] | String>;
  externalId_lt?: Maybe<String>;
  externalId_lte?: Maybe<String>;
  externalId_gt?: Maybe<String>;
  externalId_gte?: Maybe<String>;
  externalId_contains?: Maybe<String>;
  externalId_not_contains?: Maybe<String>;
  externalId_starts_with?: Maybe<String>;
  externalId_not_starts_with?: Maybe<String>;
  externalId_ends_with?: Maybe<String>;
  externalId_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  status?: Maybe<SmsStatus>;
  status_not?: Maybe<SmsStatus>;
  status_in?: Maybe<SmsStatus[] | SmsStatus>;
  status_not_in?: Maybe<SmsStatus[] | SmsStatus>;
  smsId?: Maybe<String>;
  smsId_not?: Maybe<String>;
  smsId_in?: Maybe<String[] | String>;
  smsId_not_in?: Maybe<String[] | String>;
  smsId_lt?: Maybe<String>;
  smsId_lte?: Maybe<String>;
  smsId_gt?: Maybe<String>;
  smsId_gte?: Maybe<String>;
  smsId_contains?: Maybe<String>;
  smsId_not_contains?: Maybe<String>;
  smsId_starts_with?: Maybe<String>;
  smsId_not_starts_with?: Maybe<String>;
  smsId_ends_with?: Maybe<String>;
  smsId_not_ends_with?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
  sentAt_not?: Maybe<DateTimeInput>;
  sentAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  sentAt_lt?: Maybe<DateTimeInput>;
  sentAt_lte?: Maybe<DateTimeInput>;
  sentAt_gt?: Maybe<DateTimeInput>;
  sentAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SmsReceiptScalarWhereInput[] | SmsReceiptScalarWhereInput>;
  OR?: Maybe<SmsReceiptScalarWhereInput[] | SmsReceiptScalarWhereInput>;
  NOT?: Maybe<SmsReceiptScalarWhereInput[] | SmsReceiptScalarWhereInput>;
}

export interface SmsReceiptUpdateManyWithWhereNestedInput {
  where: SmsReceiptScalarWhereInput;
  data: SmsReceiptUpdateManyDataInput;
}

export interface SmsReceiptUpdateManyDataInput {
  externalId?: Maybe<String>;
  body?: Maybe<String>;
  mediaUrls?: Maybe<SmsReceiptUpdatemediaUrlsInput>;
  status?: Maybe<SmsStatus>;
  smsId?: Maybe<String>;
}

export interface FitPicUpdateManyWithoutUserInput {
  create?: Maybe<FitPicCreateWithoutUserInput[] | FitPicCreateWithoutUserInput>;
  delete?: Maybe<FitPicWhereUniqueInput[] | FitPicWhereUniqueInput>;
  connect?: Maybe<FitPicWhereUniqueInput[] | FitPicWhereUniqueInput>;
  set?: Maybe<FitPicWhereUniqueInput[] | FitPicWhereUniqueInput>;
  disconnect?: Maybe<FitPicWhereUniqueInput[] | FitPicWhereUniqueInput>;
  update?: Maybe<
    | FitPicUpdateWithWhereUniqueWithoutUserInput[]
    | FitPicUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | FitPicUpsertWithWhereUniqueWithoutUserInput[]
    | FitPicUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<FitPicScalarWhereInput[] | FitPicScalarWhereInput>;
  updateMany?: Maybe<
    | FitPicUpdateManyWithWhereNestedInput[]
    | FitPicUpdateManyWithWhereNestedInput
  >;
}

export interface FitPicUpdateWithWhereUniqueWithoutUserInput {
  where: FitPicWhereUniqueInput;
  data: FitPicUpdateWithoutUserDataInput;
}

export interface FitPicUpdateWithoutUserDataInput {
  image?: Maybe<ImageUpdateOneRequiredInput>;
  includeInstagramHandle?: Maybe<Boolean>;
  location?: Maybe<LocationUpdateOneInput>;
  products?: Maybe<ProductUpdateManyInput>;
  reports?: Maybe<FitPicReportUpdateManyWithoutReportedInput>;
  status?: Maybe<FitPicStatus>;
}

export interface ImageUpdateOneRequiredInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ImageUpdateDataInput {
  caption?: Maybe<String>;
  url?: Maybe<String>;
  height?: Maybe<Int>;
  width?: Maybe<Int>;
  title?: Maybe<String>;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface LocationUpdateOneInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserUpdateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutLocationInput>;
  shippingOptions?: Maybe<ShippingOptionUpdateManyWithoutDestinationInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PhysicalProductUpdateManyWithoutLocationInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutLocationInput[]
    | PhysicalProductCreateWithoutLocationInput
  >;
  delete?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  set?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  update?: Maybe<
    | PhysicalProductUpdateWithWhereUniqueWithoutLocationInput[]
    | PhysicalProductUpdateWithWhereUniqueWithoutLocationInput
  >;
  upsert?: Maybe<
    | PhysicalProductUpsertWithWhereUniqueWithoutLocationInput[]
    | PhysicalProductUpsertWithWhereUniqueWithoutLocationInput
  >;
  deleteMany?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductUpdateManyWithWhereNestedInput[]
    | PhysicalProductUpdateManyWithWhereNestedInput
  >;
}

export interface PhysicalProductUpdateWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput;
  data: PhysicalProductUpdateWithoutLocationDataInput;
}

export interface PhysicalProductUpdateWithoutLocationDataInput {
  seasonsUID?: Maybe<String>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  warehouseLocation?: Maybe<
    WarehouseLocationUpdateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceUpdateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportUpdateManyWithoutPhysicalProductInput
  >;
}

export interface ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput {
  create?: Maybe<ProductVariantCreateWithoutPhysicalProductsInput>;
  update?: Maybe<ProductVariantUpdateWithoutPhysicalProductsDataInput>;
  upsert?: Maybe<ProductVariantUpsertWithoutPhysicalProductsInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface ProductVariantUpdateWithoutPhysicalProductsDataInput {
  sku?: Maybe<String>;
  displayShort?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  internalSize?: Maybe<SizeUpdateOneInput>;
  manufacturerSizes?: Maybe<SizeUpdateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceUpdateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantUpdateOneInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  stored?: Maybe<Int>;
}

export interface ColorUpdateOneRequiredWithoutProductVariantsInput {
  create?: Maybe<ColorCreateWithoutProductVariantsInput>;
  update?: Maybe<ColorUpdateWithoutProductVariantsDataInput>;
  upsert?: Maybe<ColorUpsertWithoutProductVariantsInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface ColorUpdateWithoutProductVariantsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
}

export interface ColorUpsertWithoutProductVariantsInput {
  update: ColorUpdateWithoutProductVariantsDataInput;
  create: ColorCreateWithoutProductVariantsInput;
}

export interface SizeUpdateOneInput {
  create?: Maybe<SizeCreateInput>;
  update?: Maybe<SizeUpdateDataInput>;
  upsert?: Maybe<SizeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SizeWhereUniqueInput>;
}

export interface SizeUpdateDataInput {
  slug?: Maybe<String>;
  productType?: Maybe<ProductType>;
  top?: Maybe<TopSizeUpdateOneInput>;
  bottom?: Maybe<BottomSizeUpdateOneInput>;
  display?: Maybe<String>;
}

export interface TopSizeUpdateOneInput {
  create?: Maybe<TopSizeCreateInput>;
  update?: Maybe<TopSizeUpdateDataInput>;
  upsert?: Maybe<TopSizeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TopSizeWhereUniqueInput>;
}

export interface TopSizeUpdateDataInput {
  letter?: Maybe<LetterSize>;
  sleeve?: Maybe<Float>;
  shoulder?: Maybe<Float>;
  chest?: Maybe<Float>;
  neck?: Maybe<Float>;
  length?: Maybe<Float>;
}

export interface TopSizeUpsertNestedInput {
  update: TopSizeUpdateDataInput;
  create: TopSizeCreateInput;
}

export interface BottomSizeUpdateOneInput {
  create?: Maybe<BottomSizeCreateInput>;
  update?: Maybe<BottomSizeUpdateDataInput>;
  upsert?: Maybe<BottomSizeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BottomSizeWhereUniqueInput>;
}

export interface BottomSizeUpdateDataInput {
  type?: Maybe<BottomSizeType>;
  value?: Maybe<String>;
  waist?: Maybe<Float>;
  rise?: Maybe<Float>;
  hem?: Maybe<Float>;
  inseam?: Maybe<Float>;
}

export interface BottomSizeUpsertNestedInput {
  update: BottomSizeUpdateDataInput;
  create: BottomSizeCreateInput;
}

export interface SizeUpsertNestedInput {
  update: SizeUpdateDataInput;
  create: SizeCreateInput;
}

export interface SizeUpdateManyInput {
  create?: Maybe<SizeCreateInput[] | SizeCreateInput>;
  update?: Maybe<
    | SizeUpdateWithWhereUniqueNestedInput[]
    | SizeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SizeUpsertWithWhereUniqueNestedInput[]
    | SizeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SizeWhereUniqueInput[] | SizeWhereUniqueInput>;
  connect?: Maybe<SizeWhereUniqueInput[] | SizeWhereUniqueInput>;
  set?: Maybe<SizeWhereUniqueInput[] | SizeWhereUniqueInput>;
  disconnect?: Maybe<SizeWhereUniqueInput[] | SizeWhereUniqueInput>;
  deleteMany?: Maybe<SizeScalarWhereInput[] | SizeScalarWhereInput>;
  updateMany?: Maybe<
    SizeUpdateManyWithWhereNestedInput[] | SizeUpdateManyWithWhereNestedInput
  >;
}

export interface SizeUpdateWithWhereUniqueNestedInput {
  where: SizeWhereUniqueInput;
  data: SizeUpdateDataInput;
}

export interface SizeUpsertWithWhereUniqueNestedInput {
  where: SizeWhereUniqueInput;
  update: SizeUpdateDataInput;
  create: SizeCreateInput;
}

export interface SizeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  productType?: Maybe<ProductType>;
  productType_not?: Maybe<ProductType>;
  productType_in?: Maybe<ProductType[] | ProductType>;
  productType_not_in?: Maybe<ProductType[] | ProductType>;
  display?: Maybe<String>;
  display_not?: Maybe<String>;
  display_in?: Maybe<String[] | String>;
  display_not_in?: Maybe<String[] | String>;
  display_lt?: Maybe<String>;
  display_lte?: Maybe<String>;
  display_gt?: Maybe<String>;
  display_gte?: Maybe<String>;
  display_contains?: Maybe<String>;
  display_not_contains?: Maybe<String>;
  display_starts_with?: Maybe<String>;
  display_not_starts_with?: Maybe<String>;
  display_ends_with?: Maybe<String>;
  display_not_ends_with?: Maybe<String>;
  AND?: Maybe<SizeScalarWhereInput[] | SizeScalarWhereInput>;
  OR?: Maybe<SizeScalarWhereInput[] | SizeScalarWhereInput>;
  NOT?: Maybe<SizeScalarWhereInput[] | SizeScalarWhereInput>;
}

export interface SizeUpdateManyWithWhereNestedInput {
  where: SizeScalarWhereInput;
  data: SizeUpdateManyDataInput;
}

export interface SizeUpdateManyDataInput {
  slug?: Maybe<String>;
  productType?: Maybe<ProductType>;
  display?: Maybe<String>;
}

export interface ProductUpdateOneRequiredWithoutVariantsInput {
  create?: Maybe<ProductCreateWithoutVariantsInput>;
  update?: Maybe<ProductUpdateWithoutVariantsDataInput>;
  upsert?: Maybe<ProductUpsertWithoutVariantsInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductUpdateWithoutVariantsDataInput {
  architecture?: Maybe<ProductArchitecture>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryUpdateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelUpdateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagUpdateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
}

export interface BrandUpdateOneRequiredWithoutProductsInput {
  create?: Maybe<BrandCreateWithoutProductsInput>;
  update?: Maybe<BrandUpdateWithoutProductsDataInput>;
  upsert?: Maybe<BrandUpsertWithoutProductsInput>;
  connect?: Maybe<BrandWhereUniqueInput>;
}

export interface BrandUpdateWithoutProductsDataInput {
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name?: Maybe<String>;
  designer?: Maybe<String>;
  basedIn?: Maybe<String>;
  images?: Maybe<ImageUpdateManyInput>;
  since?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  published?: Maybe<Boolean>;
  featured?: Maybe<Boolean>;
  websiteUrl?: Maybe<String>;
  externalShopifyIntegration?: Maybe<ExternalShopifyIntegrationUpdateOneInput>;
}

export interface ImageUpdateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  update?: Maybe<
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  set?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  disconnect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  deleteMany?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  updateMany?: Maybe<
    ImageUpdateManyWithWhereNestedInput[] | ImageUpdateManyWithWhereNestedInput
  >;
}

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface ImageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  width?: Maybe<Int>;
  width_not?: Maybe<Int>;
  width_in?: Maybe<Int[] | Int>;
  width_not_in?: Maybe<Int[] | Int>;
  width_lt?: Maybe<Int>;
  width_lte?: Maybe<Int>;
  width_gt?: Maybe<Int>;
  width_gte?: Maybe<Int>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  OR?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  NOT?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface ImageUpdateManyDataInput {
  caption?: Maybe<String>;
  url?: Maybe<String>;
  height?: Maybe<Int>;
  width?: Maybe<Int>;
  title?: Maybe<String>;
}

export interface ExternalShopifyIntegrationUpdateOneInput {
  create?: Maybe<ExternalShopifyIntegrationCreateInput>;
  update?: Maybe<ExternalShopifyIntegrationUpdateDataInput>;
  upsert?: Maybe<ExternalShopifyIntegrationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ExternalShopifyIntegrationWhereUniqueInput>;
}

export interface ExternalShopifyIntegrationUpdateDataInput {
  shopName?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  accessToken?: Maybe<String>;
  nonce?: Maybe<String>;
}

export interface ExternalShopifyIntegrationUpsertNestedInput {
  update: ExternalShopifyIntegrationUpdateDataInput;
  create: ExternalShopifyIntegrationCreateInput;
}

export interface BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput;
  create: BrandCreateWithoutProductsInput;
}

export interface CategoryUpdateOneRequiredWithoutProductsInput {
  create?: Maybe<CategoryCreateWithoutProductsInput>;
  update?: Maybe<CategoryUpdateWithoutProductsDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutProductsInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryUpdateWithoutProductsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  children?: Maybe<CategoryUpdateManyWithoutChildrenInput>;
}

export interface CategoryUpdateManyWithoutChildrenInput {
  create?: Maybe<
    CategoryCreateWithoutChildrenInput[] | CategoryCreateWithoutChildrenInput
  >;
  delete?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  set?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  disconnect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  update?: Maybe<
    | CategoryUpdateWithWhereUniqueWithoutChildrenInput[]
    | CategoryUpdateWithWhereUniqueWithoutChildrenInput
  >;
  upsert?: Maybe<
    | CategoryUpsertWithWhereUniqueWithoutChildrenInput[]
    | CategoryUpsertWithWhereUniqueWithoutChildrenInput
  >;
  deleteMany?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  updateMany?: Maybe<
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput
  >;
}

export interface CategoryUpdateWithWhereUniqueWithoutChildrenInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutChildrenDataInput;
}

export interface CategoryUpdateWithoutChildrenDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductUpdateManyWithoutCategoryInput>;
}

export interface ProductUpdateManyWithoutCategoryInput {
  create?: Maybe<
    ProductCreateWithoutCategoryInput[] | ProductCreateWithoutCategoryInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProductUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProductUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCategoryDataInput;
}

export interface ProductUpdateWithoutCategoryDataInput {
  architecture?: Maybe<ProductArchitecture>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryUpdateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelUpdateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagUpdateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
}

export interface ColorUpdateOneRequiredInput {
  create?: Maybe<ColorCreateInput>;
  update?: Maybe<ColorUpdateDataInput>;
  upsert?: Maybe<ColorUpsertNestedInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface ColorUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
  productVariants?: Maybe<ProductVariantUpdateManyWithoutColorInput>;
}

export interface ProductVariantUpdateManyWithoutColorInput {
  create?: Maybe<
    | ProductVariantCreateWithoutColorInput[]
    | ProductVariantCreateWithoutColorInput
  >;
  delete?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  set?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  update?: Maybe<
    | ProductVariantUpdateWithWhereUniqueWithoutColorInput[]
    | ProductVariantUpdateWithWhereUniqueWithoutColorInput
  >;
  upsert?: Maybe<
    | ProductVariantUpsertWithWhereUniqueWithoutColorInput[]
    | ProductVariantUpsertWithWhereUniqueWithoutColorInput
  >;
  deleteMany?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductVariantUpdateManyWithWhereNestedInput[]
    | ProductVariantUpdateManyWithWhereNestedInput
  >;
}

export interface ProductVariantUpdateWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput;
  data: ProductVariantUpdateWithoutColorDataInput;
}

export interface ProductVariantUpdateWithoutColorDataInput {
  sku?: Maybe<String>;
  displayShort?: Maybe<String>;
  internalSize?: Maybe<SizeUpdateOneInput>;
  manufacturerSizes?: Maybe<SizeUpdateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceUpdateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantUpdateOneInput>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  stored?: Maybe<Int>;
}

export interface ProductVariantPriceUpdateOneInput {
  create?: Maybe<ProductVariantPriceCreateInput>;
  update?: Maybe<ProductVariantPriceUpdateDataInput>;
  upsert?: Maybe<ProductVariantPriceUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductVariantPriceWhereUniqueInput>;
}

export interface ProductVariantPriceUpdateDataInput {
  retailPrice?: Maybe<Float>;
}

export interface ProductVariantPriceUpsertNestedInput {
  update: ProductVariantPriceUpdateDataInput;
  create: ProductVariantPriceCreateInput;
}

export interface ShopifyProductVariantUpdateOneInput {
  create?: Maybe<ShopifyProductVariantCreateInput>;
  update?: Maybe<ShopifyProductVariantUpdateDataInput>;
  upsert?: Maybe<ShopifyProductVariantUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShopifyProductVariantWhereUniqueInput>;
}

export interface ShopifyProductVariantUpdateDataInput {
  externalId?: Maybe<String>;
  cachedPrice?: Maybe<Float>;
  cachedAvailableForSale?: Maybe<Boolean>;
  cacheExpiresAt?: Maybe<DateTimeInput>;
}

export interface ShopifyProductVariantUpsertNestedInput {
  update: ShopifyProductVariantUpdateDataInput;
  create: ShopifyProductVariantCreateInput;
}

export interface PhysicalProductUpdateManyWithoutProductVariantInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutProductVariantInput[]
    | PhysicalProductCreateWithoutProductVariantInput
  >;
  delete?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  set?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  update?: Maybe<
    | PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput[]
    | PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput
  >;
  upsert?: Maybe<
    | PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput[]
    | PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput
  >;
  deleteMany?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductUpdateManyWithWhereNestedInput[]
    | PhysicalProductUpdateManyWithWhereNestedInput
  >;
}

export interface PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput;
  data: PhysicalProductUpdateWithoutProductVariantDataInput;
}

export interface PhysicalProductUpdateWithoutProductVariantDataInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneWithoutPhysicalProductsInput>;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  warehouseLocation?: Maybe<
    WarehouseLocationUpdateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceUpdateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportUpdateManyWithoutPhysicalProductInput
  >;
}

export interface LocationUpdateOneWithoutPhysicalProductsInput {
  create?: Maybe<LocationCreateWithoutPhysicalProductsInput>;
  update?: Maybe<LocationUpdateWithoutPhysicalProductsDataInput>;
  upsert?: Maybe<LocationUpsertWithoutPhysicalProductsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationUpdateWithoutPhysicalProductsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserUpdateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  shippingOptions?: Maybe<ShippingOptionUpdateManyWithoutDestinationInput>;
}

export interface ShippingOptionUpdateManyWithoutDestinationInput {
  create?: Maybe<
    | ShippingOptionCreateWithoutDestinationInput[]
    | ShippingOptionCreateWithoutDestinationInput
  >;
  delete?: Maybe<
    ShippingOptionWhereUniqueInput[] | ShippingOptionWhereUniqueInput
  >;
  connect?: Maybe<
    ShippingOptionWhereUniqueInput[] | ShippingOptionWhereUniqueInput
  >;
  set?: Maybe<
    ShippingOptionWhereUniqueInput[] | ShippingOptionWhereUniqueInput
  >;
  disconnect?: Maybe<
    ShippingOptionWhereUniqueInput[] | ShippingOptionWhereUniqueInput
  >;
  update?: Maybe<
    | ShippingOptionUpdateWithWhereUniqueWithoutDestinationInput[]
    | ShippingOptionUpdateWithWhereUniqueWithoutDestinationInput
  >;
  upsert?: Maybe<
    | ShippingOptionUpsertWithWhereUniqueWithoutDestinationInput[]
    | ShippingOptionUpsertWithWhereUniqueWithoutDestinationInput
  >;
  deleteMany?: Maybe<
    ShippingOptionScalarWhereInput[] | ShippingOptionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ShippingOptionUpdateManyWithWhereNestedInput[]
    | ShippingOptionUpdateManyWithWhereNestedInput
  >;
}

export interface ShippingOptionUpdateWithWhereUniqueWithoutDestinationInput {
  where: ShippingOptionWhereUniqueInput;
  data: ShippingOptionUpdateWithoutDestinationDataInput;
}

export interface ShippingOptionUpdateWithoutDestinationDataInput {
  origin?: Maybe<LocationUpdateOneInput>;
  shippingMethod?: Maybe<ShippingMethodUpdateOneInput>;
  externalCost?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
}

export interface ShippingMethodUpdateOneInput {
  create?: Maybe<ShippingMethodCreateInput>;
  update?: Maybe<ShippingMethodUpdateDataInput>;
  upsert?: Maybe<ShippingMethodUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShippingMethodWhereUniqueInput>;
}

export interface ShippingMethodUpdateDataInput {
  code?: Maybe<ShippingCode>;
  displayText?: Maybe<String>;
}

export interface ShippingMethodUpsertNestedInput {
  update: ShippingMethodUpdateDataInput;
  create: ShippingMethodCreateInput;
}

export interface ShippingOptionUpsertWithWhereUniqueWithoutDestinationInput {
  where: ShippingOptionWhereUniqueInput;
  update: ShippingOptionUpdateWithoutDestinationDataInput;
  create: ShippingOptionCreateWithoutDestinationInput;
}

export interface ShippingOptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  externalCost?: Maybe<Int>;
  externalCost_not?: Maybe<Int>;
  externalCost_in?: Maybe<Int[] | Int>;
  externalCost_not_in?: Maybe<Int[] | Int>;
  externalCost_lt?: Maybe<Int>;
  externalCost_lte?: Maybe<Int>;
  externalCost_gt?: Maybe<Int>;
  externalCost_gte?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
  averageDuration_not?: Maybe<Int>;
  averageDuration_in?: Maybe<Int[] | Int>;
  averageDuration_not_in?: Maybe<Int[] | Int>;
  averageDuration_lt?: Maybe<Int>;
  averageDuration_lte?: Maybe<Int>;
  averageDuration_gt?: Maybe<Int>;
  averageDuration_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ShippingOptionScalarWhereInput[] | ShippingOptionScalarWhereInput
  >;
  OR?: Maybe<ShippingOptionScalarWhereInput[] | ShippingOptionScalarWhereInput>;
  NOT?: Maybe<
    ShippingOptionScalarWhereInput[] | ShippingOptionScalarWhereInput
  >;
}

export interface ShippingOptionUpdateManyWithWhereNestedInput {
  where: ShippingOptionScalarWhereInput;
  data: ShippingOptionUpdateManyDataInput;
}

export interface ShippingOptionUpdateManyDataInput {
  externalCost?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
}

export interface LocationUpsertWithoutPhysicalProductsInput {
  update: LocationUpdateWithoutPhysicalProductsDataInput;
  create: LocationCreateWithoutPhysicalProductsInput;
}

export interface WarehouseLocationUpdateOneWithoutPhysicalProductsInput {
  create?: Maybe<WarehouseLocationCreateWithoutPhysicalProductsInput>;
  update?: Maybe<WarehouseLocationUpdateWithoutPhysicalProductsDataInput>;
  upsert?: Maybe<WarehouseLocationUpsertWithoutPhysicalProductsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WarehouseLocationWhereUniqueInput>;
}

export interface WarehouseLocationUpdateWithoutPhysicalProductsDataInput {
  type?: Maybe<WarehouseLocationType>;
  barcode?: Maybe<String>;
  locationCode?: Maybe<String>;
  itemCode?: Maybe<String>;
  constraints?: Maybe<
    WarehouseLocationConstraintUpdateManyWithoutLocationsInput
  >;
}

export interface WarehouseLocationConstraintUpdateManyWithoutLocationsInput {
  create?: Maybe<
    | WarehouseLocationConstraintCreateWithoutLocationsInput[]
    | WarehouseLocationConstraintCreateWithoutLocationsInput
  >;
  delete?: Maybe<
    | WarehouseLocationConstraintWhereUniqueInput[]
    | WarehouseLocationConstraintWhereUniqueInput
  >;
  connect?: Maybe<
    | WarehouseLocationConstraintWhereUniqueInput[]
    | WarehouseLocationConstraintWhereUniqueInput
  >;
  set?: Maybe<
    | WarehouseLocationConstraintWhereUniqueInput[]
    | WarehouseLocationConstraintWhereUniqueInput
  >;
  disconnect?: Maybe<
    | WarehouseLocationConstraintWhereUniqueInput[]
    | WarehouseLocationConstraintWhereUniqueInput
  >;
  update?: Maybe<
    | WarehouseLocationConstraintUpdateWithWhereUniqueWithoutLocationsInput[]
    | WarehouseLocationConstraintUpdateWithWhereUniqueWithoutLocationsInput
  >;
  upsert?: Maybe<
    | WarehouseLocationConstraintUpsertWithWhereUniqueWithoutLocationsInput[]
    | WarehouseLocationConstraintUpsertWithWhereUniqueWithoutLocationsInput
  >;
  deleteMany?: Maybe<
    | WarehouseLocationConstraintScalarWhereInput[]
    | WarehouseLocationConstraintScalarWhereInput
  >;
  updateMany?: Maybe<
    | WarehouseLocationConstraintUpdateManyWithWhereNestedInput[]
    | WarehouseLocationConstraintUpdateManyWithWhereNestedInput
  >;
}

export interface WarehouseLocationConstraintUpdateWithWhereUniqueWithoutLocationsInput {
  where: WarehouseLocationConstraintWhereUniqueInput;
  data: WarehouseLocationConstraintUpdateWithoutLocationsDataInput;
}

export interface WarehouseLocationConstraintUpdateWithoutLocationsDataInput {
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  limit?: Maybe<Int>;
}

export interface CategoryUpdateOneRequiredInput {
  create?: Maybe<CategoryCreateInput>;
  update?: Maybe<CategoryUpdateDataInput>;
  upsert?: Maybe<CategoryUpsertNestedInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductUpdateManyWithoutCategoryInput>;
  children?: Maybe<CategoryUpdateManyWithoutChildrenInput>;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface WarehouseLocationConstraintUpsertWithWhereUniqueWithoutLocationsInput {
  where: WarehouseLocationConstraintWhereUniqueInput;
  update: WarehouseLocationConstraintUpdateWithoutLocationsDataInput;
  create: WarehouseLocationConstraintCreateWithoutLocationsInput;
}

export interface WarehouseLocationConstraintScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  limit?: Maybe<Int>;
  limit_not?: Maybe<Int>;
  limit_in?: Maybe<Int[] | Int>;
  limit_not_in?: Maybe<Int[] | Int>;
  limit_lt?: Maybe<Int>;
  limit_lte?: Maybe<Int>;
  limit_gt?: Maybe<Int>;
  limit_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | WarehouseLocationConstraintScalarWhereInput[]
    | WarehouseLocationConstraintScalarWhereInput
  >;
  OR?: Maybe<
    | WarehouseLocationConstraintScalarWhereInput[]
    | WarehouseLocationConstraintScalarWhereInput
  >;
  NOT?: Maybe<
    | WarehouseLocationConstraintScalarWhereInput[]
    | WarehouseLocationConstraintScalarWhereInput
  >;
}

export interface WarehouseLocationConstraintUpdateManyWithWhereNestedInput {
  where: WarehouseLocationConstraintScalarWhereInput;
  data: WarehouseLocationConstraintUpdateManyDataInput;
}

export interface WarehouseLocationConstraintUpdateManyDataInput {
  limit?: Maybe<Int>;
}

export interface WarehouseLocationUpsertWithoutPhysicalProductsInput {
  update: WarehouseLocationUpdateWithoutPhysicalProductsDataInput;
  create: WarehouseLocationCreateWithoutPhysicalProductsInput;
}

export interface PhysicalProductPriceUpdateOneInput {
  create?: Maybe<PhysicalProductPriceCreateInput>;
  update?: Maybe<PhysicalProductPriceUpdateDataInput>;
  upsert?: Maybe<PhysicalProductPriceUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PhysicalProductPriceWhereUniqueInput>;
}

export interface PhysicalProductPriceUpdateDataInput {
  buyUsedEnabled?: Maybe<Boolean>;
  buyUsedPrice?: Maybe<Float>;
}

export interface PhysicalProductPriceUpsertNestedInput {
  update: PhysicalProductPriceUpdateDataInput;
  create: PhysicalProductPriceCreateInput;
}

export interface PhysicalProductQualityReportUpdateManyWithoutPhysicalProductInput {
  create?: Maybe<
    | PhysicalProductQualityReportCreateWithoutPhysicalProductInput[]
    | PhysicalProductQualityReportCreateWithoutPhysicalProductInput
  >;
  delete?: Maybe<
    | PhysicalProductQualityReportWhereUniqueInput[]
    | PhysicalProductQualityReportWhereUniqueInput
  >;
  connect?: Maybe<
    | PhysicalProductQualityReportWhereUniqueInput[]
    | PhysicalProductQualityReportWhereUniqueInput
  >;
  set?: Maybe<
    | PhysicalProductQualityReportWhereUniqueInput[]
    | PhysicalProductQualityReportWhereUniqueInput
  >;
  disconnect?: Maybe<
    | PhysicalProductQualityReportWhereUniqueInput[]
    | PhysicalProductQualityReportWhereUniqueInput
  >;
  update?: Maybe<
    | PhysicalProductQualityReportUpdateWithWhereUniqueWithoutPhysicalProductInput[]
    | PhysicalProductQualityReportUpdateWithWhereUniqueWithoutPhysicalProductInput
  >;
  upsert?: Maybe<
    | PhysicalProductQualityReportUpsertWithWhereUniqueWithoutPhysicalProductInput[]
    | PhysicalProductQualityReportUpsertWithWhereUniqueWithoutPhysicalProductInput
  >;
  deleteMany?: Maybe<
    | PhysicalProductQualityReportScalarWhereInput[]
    | PhysicalProductQualityReportScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductQualityReportUpdateManyWithWhereNestedInput[]
    | PhysicalProductQualityReportUpdateManyWithWhereNestedInput
  >;
}

export interface PhysicalProductQualityReportUpdateWithWhereUniqueWithoutPhysicalProductInput {
  where: PhysicalProductQualityReportWhereUniqueInput;
  data: PhysicalProductQualityReportUpdateWithoutPhysicalProductDataInput;
}

export interface PhysicalProductQualityReportUpdateWithoutPhysicalProductDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  damageType?: Maybe<PhysicalProductDamageType>;
  notes?: Maybe<String>;
}

export interface PhysicalProductQualityReportUpsertWithWhereUniqueWithoutPhysicalProductInput {
  where: PhysicalProductQualityReportWhereUniqueInput;
  update: PhysicalProductQualityReportUpdateWithoutPhysicalProductDataInput;
  create: PhysicalProductQualityReportCreateWithoutPhysicalProductInput;
}

export interface PhysicalProductQualityReportScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  damageType?: Maybe<PhysicalProductDamageType>;
  damageType_not?: Maybe<PhysicalProductDamageType>;
  damageType_in?: Maybe<
    PhysicalProductDamageType[] | PhysicalProductDamageType
  >;
  damageType_not_in?: Maybe<
    PhysicalProductDamageType[] | PhysicalProductDamageType
  >;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | PhysicalProductQualityReportScalarWhereInput[]
    | PhysicalProductQualityReportScalarWhereInput
  >;
  OR?: Maybe<
    | PhysicalProductQualityReportScalarWhereInput[]
    | PhysicalProductQualityReportScalarWhereInput
  >;
  NOT?: Maybe<
    | PhysicalProductQualityReportScalarWhereInput[]
    | PhysicalProductQualityReportScalarWhereInput
  >;
}

export interface PhysicalProductQualityReportUpdateManyWithWhereNestedInput {
  where: PhysicalProductQualityReportScalarWhereInput;
  data: PhysicalProductQualityReportUpdateManyDataInput;
}

export interface PhysicalProductQualityReportUpdateManyDataInput {
  damageType?: Maybe<PhysicalProductDamageType>;
  notes?: Maybe<String>;
}

export interface PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput;
  update: PhysicalProductUpdateWithoutProductVariantDataInput;
  create: PhysicalProductCreateWithoutProductVariantInput;
}

export interface PhysicalProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seasonsUID?: Maybe<String>;
  seasonsUID_not?: Maybe<String>;
  seasonsUID_in?: Maybe<String[] | String>;
  seasonsUID_not_in?: Maybe<String[] | String>;
  seasonsUID_lt?: Maybe<String>;
  seasonsUID_lte?: Maybe<String>;
  seasonsUID_gt?: Maybe<String>;
  seasonsUID_gte?: Maybe<String>;
  seasonsUID_contains?: Maybe<String>;
  seasonsUID_not_contains?: Maybe<String>;
  seasonsUID_starts_with?: Maybe<String>;
  seasonsUID_not_starts_with?: Maybe<String>;
  seasonsUID_ends_with?: Maybe<String>;
  seasonsUID_not_ends_with?: Maybe<String>;
  inventoryStatus?: Maybe<InventoryStatus>;
  inventoryStatus_not?: Maybe<InventoryStatus>;
  inventoryStatus_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  inventoryStatus_not_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  productStatus_not?: Maybe<PhysicalProductStatus>;
  productStatus_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  productStatus_not_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadMethod_not?: Maybe<PhysicalProductOffloadMethod>;
  offloadMethod_in?: Maybe<
    PhysicalProductOffloadMethod[] | PhysicalProductOffloadMethod
  >;
  offloadMethod_not_in?: Maybe<
    PhysicalProductOffloadMethod[] | PhysicalProductOffloadMethod
  >;
  offloadNotes?: Maybe<String>;
  offloadNotes_not?: Maybe<String>;
  offloadNotes_in?: Maybe<String[] | String>;
  offloadNotes_not_in?: Maybe<String[] | String>;
  offloadNotes_lt?: Maybe<String>;
  offloadNotes_lte?: Maybe<String>;
  offloadNotes_gt?: Maybe<String>;
  offloadNotes_gte?: Maybe<String>;
  offloadNotes_contains?: Maybe<String>;
  offloadNotes_not_contains?: Maybe<String>;
  offloadNotes_starts_with?: Maybe<String>;
  offloadNotes_not_starts_with?: Maybe<String>;
  offloadNotes_ends_with?: Maybe<String>;
  offloadNotes_not_ends_with?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  sequenceNumber_not?: Maybe<Int>;
  sequenceNumber_in?: Maybe<Int[] | Int>;
  sequenceNumber_not_in?: Maybe<Int[] | Int>;
  sequenceNumber_lt?: Maybe<Int>;
  sequenceNumber_lte?: Maybe<Int>;
  sequenceNumber_gt?: Maybe<Int>;
  sequenceNumber_gte?: Maybe<Int>;
  barcoded?: Maybe<Boolean>;
  barcoded_not?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateOrdered_not?: Maybe<DateTimeInput>;
  dateOrdered_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOrdered_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOrdered_lt?: Maybe<DateTimeInput>;
  dateOrdered_lte?: Maybe<DateTimeInput>;
  dateOrdered_gt?: Maybe<DateTimeInput>;
  dateOrdered_gte?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  dateReceived_not?: Maybe<DateTimeInput>;
  dateReceived_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateReceived_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateReceived_lt?: Maybe<DateTimeInput>;
  dateReceived_lte?: Maybe<DateTimeInput>;
  dateReceived_gt?: Maybe<DateTimeInput>;
  dateReceived_gte?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  unitCost_not?: Maybe<Float>;
  unitCost_in?: Maybe<Float[] | Float>;
  unitCost_not_in?: Maybe<Float[] | Float>;
  unitCost_lt?: Maybe<Float>;
  unitCost_lte?: Maybe<Float>;
  unitCost_gt?: Maybe<Float>;
  unitCost_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  OR?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  NOT?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
}

export interface PhysicalProductUpdateManyWithWhereNestedInput {
  where: PhysicalProductScalarWhereInput;
  data: PhysicalProductUpdateManyDataInput;
}

export interface PhysicalProductUpdateManyDataInput {
  seasonsUID?: Maybe<String>;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
}

export interface ProductVariantUpsertWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput;
  update: ProductVariantUpdateWithoutColorDataInput;
  create: ProductVariantCreateWithoutColorInput;
}

export interface ProductVariantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  displayShort?: Maybe<String>;
  displayShort_not?: Maybe<String>;
  displayShort_in?: Maybe<String[] | String>;
  displayShort_not_in?: Maybe<String[] | String>;
  displayShort_lt?: Maybe<String>;
  displayShort_lte?: Maybe<String>;
  displayShort_gt?: Maybe<String>;
  displayShort_gte?: Maybe<String>;
  displayShort_contains?: Maybe<String>;
  displayShort_not_contains?: Maybe<String>;
  displayShort_starts_with?: Maybe<String>;
  displayShort_not_starts_with?: Maybe<String>;
  displayShort_ends_with?: Maybe<String>;
  displayShort_not_ends_with?: Maybe<String>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  productID?: Maybe<String>;
  productID_not?: Maybe<String>;
  productID_in?: Maybe<String[] | String>;
  productID_not_in?: Maybe<String[] | String>;
  productID_lt?: Maybe<String>;
  productID_lte?: Maybe<String>;
  productID_gt?: Maybe<String>;
  productID_gte?: Maybe<String>;
  productID_contains?: Maybe<String>;
  productID_not_contains?: Maybe<String>;
  productID_starts_with?: Maybe<String>;
  productID_not_starts_with?: Maybe<String>;
  productID_ends_with?: Maybe<String>;
  productID_not_ends_with?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  retailPrice_not?: Maybe<Float>;
  retailPrice_in?: Maybe<Float[] | Float>;
  retailPrice_not_in?: Maybe<Float[] | Float>;
  retailPrice_lt?: Maybe<Float>;
  retailPrice_lte?: Maybe<Float>;
  retailPrice_gt?: Maybe<Float>;
  retailPrice_gte?: Maybe<Float>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reservable_not?: Maybe<Int>;
  reservable_in?: Maybe<Int[] | Int>;
  reservable_not_in?: Maybe<Int[] | Int>;
  reservable_lt?: Maybe<Int>;
  reservable_lte?: Maybe<Int>;
  reservable_gt?: Maybe<Int>;
  reservable_gte?: Maybe<Int>;
  reserved?: Maybe<Int>;
  reserved_not?: Maybe<Int>;
  reserved_in?: Maybe<Int[] | Int>;
  reserved_not_in?: Maybe<Int[] | Int>;
  reserved_lt?: Maybe<Int>;
  reserved_lte?: Maybe<Int>;
  reserved_gt?: Maybe<Int>;
  reserved_gte?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  nonReservable_not?: Maybe<Int>;
  nonReservable_in?: Maybe<Int[] | Int>;
  nonReservable_not_in?: Maybe<Int[] | Int>;
  nonReservable_lt?: Maybe<Int>;
  nonReservable_lte?: Maybe<Int>;
  nonReservable_gt?: Maybe<Int>;
  nonReservable_gte?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  offloaded_not?: Maybe<Int>;
  offloaded_in?: Maybe<Int[] | Int>;
  offloaded_not_in?: Maybe<Int[] | Int>;
  offloaded_lt?: Maybe<Int>;
  offloaded_lte?: Maybe<Int>;
  offloaded_gt?: Maybe<Int>;
  offloaded_gte?: Maybe<Int>;
  stored?: Maybe<Int>;
  stored_not?: Maybe<Int>;
  stored_in?: Maybe<Int[] | Int>;
  stored_not_in?: Maybe<Int[] | Int>;
  stored_lt?: Maybe<Int>;
  stored_lte?: Maybe<Int>;
  stored_gt?: Maybe<Int>;
  stored_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
  OR?: Maybe<ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput>;
  NOT?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
}

export interface ProductVariantUpdateManyWithWhereNestedInput {
  where: ProductVariantScalarWhereInput;
  data: ProductVariantUpdateManyDataInput;
}

export interface ProductVariantUpdateManyDataInput {
  sku?: Maybe<String>;
  displayShort?: Maybe<String>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  stored?: Maybe<Int>;
}

export interface ColorUpsertNestedInput {
  update: ColorUpdateDataInput;
  create: ColorCreateInput;
}

export interface ProductFunctionUpdateManyInput {
  create?: Maybe<ProductFunctionCreateInput[] | ProductFunctionCreateInput>;
  update?: Maybe<
    | ProductFunctionUpdateWithWhereUniqueNestedInput[]
    | ProductFunctionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductFunctionUpsertWithWhereUniqueNestedInput[]
    | ProductFunctionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  connect?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  set?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductFunctionUpdateManyWithWhereNestedInput[]
    | ProductFunctionUpdateManyWithWhereNestedInput
  >;
}

export interface ProductFunctionUpdateWithWhereUniqueNestedInput {
  where: ProductFunctionWhereUniqueInput;
  data: ProductFunctionUpdateDataInput;
}

export interface ProductFunctionUpdateDataInput {
  name?: Maybe<String>;
}

export interface ProductFunctionUpsertWithWhereUniqueNestedInput {
  where: ProductFunctionWhereUniqueInput;
  update: ProductFunctionUpdateDataInput;
  create: ProductFunctionCreateInput;
}

export interface ProductFunctionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
  OR?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
  NOT?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
}

export interface ProductFunctionUpdateManyWithWhereNestedInput {
  where: ProductFunctionScalarWhereInput;
  data: ProductFunctionUpdateManyDataInput;
}

export interface ProductFunctionUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ProductUpdateinnerMaterialsInput {
  set?: Maybe<String[] | String>;
}

export interface ProductMaterialCategoryUpdateOneWithoutProductsInput {
  create?: Maybe<ProductMaterialCategoryCreateWithoutProductsInput>;
  update?: Maybe<ProductMaterialCategoryUpdateWithoutProductsDataInput>;
  upsert?: Maybe<ProductMaterialCategoryUpsertWithoutProductsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductMaterialCategoryWhereUniqueInput>;
}

export interface ProductMaterialCategoryUpdateWithoutProductsDataInput {
  slug?: Maybe<String>;
  lifeExpectancy?: Maybe<Float>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
}

export interface ProductMaterialCategoryUpsertWithoutProductsInput {
  update: ProductMaterialCategoryUpdateWithoutProductsDataInput;
  create: ProductMaterialCategoryCreateWithoutProductsInput;
}

export interface ProductModelUpdateOneWithoutProductsInput {
  create?: Maybe<ProductModelCreateWithoutProductsInput>;
  update?: Maybe<ProductModelUpdateWithoutProductsDataInput>;
  upsert?: Maybe<ProductModelUpsertWithoutProductsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductModelWhereUniqueInput>;
}

export interface ProductModelUpdateWithoutProductsDataInput {
  name?: Maybe<String>;
  height?: Maybe<Float>;
}

export interface ProductModelUpsertWithoutProductsInput {
  update: ProductModelUpdateWithoutProductsDataInput;
  create: ProductModelCreateWithoutProductsInput;
}

export interface ProductUpdateouterMaterialsInput {
  set?: Maybe<String[] | String>;
}

export interface ProductSeasonUpdateOneInput {
  create?: Maybe<ProductSeasonCreateInput>;
  update?: Maybe<ProductSeasonUpdateDataInput>;
  upsert?: Maybe<ProductSeasonUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductSeasonWhereUniqueInput>;
}

export interface ProductSeasonUpdateDataInput {
  vendorSeason?: Maybe<SeasonUpdateOneInput>;
  internalSeason?: Maybe<SeasonUpdateOneInput>;
  wearableSeasons?: Maybe<ProductSeasonUpdatewearableSeasonsInput>;
}

export interface SeasonUpdateOneInput {
  create?: Maybe<SeasonCreateInput>;
  update?: Maybe<SeasonUpdateDataInput>;
  upsert?: Maybe<SeasonUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SeasonWhereUniqueInput>;
}

export interface SeasonUpdateDataInput {
  year?: Maybe<Int>;
  seasonCode?: Maybe<SeasonCode>;
}

export interface SeasonUpsertNestedInput {
  update: SeasonUpdateDataInput;
  create: SeasonCreateInput;
}

export interface ProductSeasonUpdatewearableSeasonsInput {
  set?: Maybe<SeasonString[] | SeasonString>;
}

export interface ProductSeasonUpsertNestedInput {
  update: ProductSeasonUpdateDataInput;
  create: ProductSeasonCreateInput;
}

export interface ColorUpdateOneInput {
  create?: Maybe<ColorCreateInput>;
  update?: Maybe<ColorUpdateDataInput>;
  upsert?: Maybe<ColorUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface TagUpdateManyWithoutProductsInput {
  create?: Maybe<
    TagCreateWithoutProductsInput[] | TagCreateWithoutProductsInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  update?: Maybe<
    | TagUpdateWithWhereUniqueWithoutProductsInput[]
    | TagUpdateWithWhereUniqueWithoutProductsInput
  >;
  upsert?: Maybe<
    | TagUpsertWithWhereUniqueWithoutProductsInput[]
    | TagUpsertWithWhereUniqueWithoutProductsInput
  >;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueWithoutProductsInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutProductsDataInput;
}

export interface TagUpdateWithoutProductsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface TagUpsertWithWhereUniqueWithoutProductsInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutProductsDataInput;
  create: TagCreateWithoutProductsInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ProductTierUpdateOneInput {
  create?: Maybe<ProductTierCreateInput>;
  update?: Maybe<ProductTierUpdateDataInput>;
  upsert?: Maybe<ProductTierUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductTierWhereUniqueInput>;
}

export interface ProductTierUpdateDataInput {
  tier?: Maybe<ProductTierName>;
  price?: Maybe<Int>;
}

export interface ProductTierUpsertNestedInput {
  update: ProductTierUpdateDataInput;
  create: ProductTierCreateInput;
}

export interface ProductVariantUpdateManyWithoutProductInput {
  create?: Maybe<
    | ProductVariantCreateWithoutProductInput[]
    | ProductVariantCreateWithoutProductInput
  >;
  delete?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  set?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  update?: Maybe<
    | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    | ProductVariantUpdateWithWhereUniqueWithoutProductInput
  >;
  upsert?: Maybe<
    | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    | ProductVariantUpsertWithWhereUniqueWithoutProductInput
  >;
  deleteMany?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductVariantUpdateManyWithWhereNestedInput[]
    | ProductVariantUpdateManyWithWhereNestedInput
  >;
}

export interface ProductVariantUpdateWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput;
  data: ProductVariantUpdateWithoutProductDataInput;
}

export interface ProductVariantUpdateWithoutProductDataInput {
  sku?: Maybe<String>;
  displayShort?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  internalSize?: Maybe<SizeUpdateOneInput>;
  manufacturerSizes?: Maybe<SizeUpdateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceUpdateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantUpdateOneInput>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  stored?: Maybe<Int>;
}

export interface ProductVariantUpsertWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput;
  update: ProductVariantUpdateWithoutProductDataInput;
  create: ProductVariantCreateWithoutProductInput;
}

export interface ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCategoryDataInput;
  create: ProductCreateWithoutCategoryInput;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  architecture_not?: Maybe<ProductArchitecture>;
  architecture_in?: Maybe<ProductArchitecture[] | ProductArchitecture>;
  architecture_not_in?: Maybe<ProductArchitecture[] | ProductArchitecture>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  externalURL?: Maybe<String>;
  externalURL_not?: Maybe<String>;
  externalURL_in?: Maybe<String[] | String>;
  externalURL_not_in?: Maybe<String[] | String>;
  externalURL_lt?: Maybe<String>;
  externalURL_lte?: Maybe<String>;
  externalURL_gt?: Maybe<String>;
  externalURL_gte?: Maybe<String>;
  externalURL_contains?: Maybe<String>;
  externalURL_not_contains?: Maybe<String>;
  externalURL_starts_with?: Maybe<String>;
  externalURL_not_starts_with?: Maybe<String>;
  externalURL_ends_with?: Maybe<String>;
  externalURL_not_ends_with?: Maybe<String>;
  buyNewEnabled?: Maybe<Boolean>;
  buyNewEnabled_not?: Maybe<Boolean>;
  modelHeight?: Maybe<Int>;
  modelHeight_not?: Maybe<Int>;
  modelHeight_in?: Maybe<Int[] | Int>;
  modelHeight_not_in?: Maybe<Int[] | Int>;
  modelHeight_lt?: Maybe<Int>;
  modelHeight_lte?: Maybe<Int>;
  modelHeight_gt?: Maybe<Int>;
  modelHeight_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  photographyStatus?: Maybe<PhotographyStatus>;
  photographyStatus_not?: Maybe<PhotographyStatus>;
  photographyStatus_in?: Maybe<PhotographyStatus[] | PhotographyStatus>;
  photographyStatus_not_in?: Maybe<PhotographyStatus[] | PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  productFit_not?: Maybe<ProductFit>;
  productFit_in?: Maybe<ProductFit[] | ProductFit>;
  productFit_not_in?: Maybe<ProductFit[] | ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  retailPrice_not?: Maybe<Int>;
  retailPrice_in?: Maybe<Int[] | Int>;
  retailPrice_not_in?: Maybe<Int[] | Int>;
  retailPrice_lt?: Maybe<Int>;
  retailPrice_lte?: Maybe<Int>;
  retailPrice_gt?: Maybe<Int>;
  retailPrice_gte?: Maybe<Int>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  status_not?: Maybe<ProductStatus>;
  status_in?: Maybe<ProductStatus[] | ProductStatus>;
  status_not_in?: Maybe<ProductStatus[] | ProductStatus>;
  type?: Maybe<ProductType>;
  type_not?: Maybe<ProductType>;
  type_in?: Maybe<ProductType[] | ProductType>;
  type_not_in?: Maybe<ProductType[] | ProductType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductUpdateManyDataInput {
  architecture?: Maybe<ProductArchitecture>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  buyNewEnabled?: Maybe<Boolean>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  modelHeight?: Maybe<Int>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  type?: Maybe<ProductType>;
}

export interface CategoryUpsertWithWhereUniqueWithoutChildrenInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutChildrenDataInput;
  create: CategoryCreateWithoutChildrenInput;
}

export interface CategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  OR?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  NOT?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface CategoryUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
}

export interface CategoryUpsertWithoutProductsInput {
  update: CategoryUpdateWithoutProductsDataInput;
  create: CategoryCreateWithoutProductsInput;
}

export interface ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput;
  create: ProductCreateWithoutVariantsInput;
}

export interface ProductVariantUpsertWithoutPhysicalProductsInput {
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput;
  create: ProductVariantCreateWithoutPhysicalProductsInput;
}

export interface PhysicalProductUpsertWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput;
  update: PhysicalProductUpdateWithoutLocationDataInput;
  create: PhysicalProductCreateWithoutLocationInput;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface ProductUpdateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface ProductUpdateDataInput {
  architecture?: Maybe<ProductArchitecture>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryUpdateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelUpdateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagUpdateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
}

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface FitPicReportUpdateManyWithoutReportedInput {
  create?: Maybe<
    | FitPicReportCreateWithoutReportedInput[]
    | FitPicReportCreateWithoutReportedInput
  >;
  delete?: Maybe<FitPicReportWhereUniqueInput[] | FitPicReportWhereUniqueInput>;
  connect?: Maybe<
    FitPicReportWhereUniqueInput[] | FitPicReportWhereUniqueInput
  >;
  set?: Maybe<FitPicReportWhereUniqueInput[] | FitPicReportWhereUniqueInput>;
  disconnect?: Maybe<
    FitPicReportWhereUniqueInput[] | FitPicReportWhereUniqueInput
  >;
  update?: Maybe<
    | FitPicReportUpdateWithWhereUniqueWithoutReportedInput[]
    | FitPicReportUpdateWithWhereUniqueWithoutReportedInput
  >;
  upsert?: Maybe<
    | FitPicReportUpsertWithWhereUniqueWithoutReportedInput[]
    | FitPicReportUpsertWithWhereUniqueWithoutReportedInput
  >;
  deleteMany?: Maybe<
    FitPicReportScalarWhereInput[] | FitPicReportScalarWhereInput
  >;
  updateMany?: Maybe<
    | FitPicReportUpdateManyWithWhereNestedInput[]
    | FitPicReportUpdateManyWithWhereNestedInput
  >;
}

export interface FitPicReportUpdateWithWhereUniqueWithoutReportedInput {
  where: FitPicReportWhereUniqueInput;
  data: FitPicReportUpdateWithoutReportedDataInput;
}

export interface FitPicReportUpdateWithoutReportedDataInput {
  reporter?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<FitPicReportStatus>;
}

export interface FitPicReportUpsertWithWhereUniqueWithoutReportedInput {
  where: FitPicReportWhereUniqueInput;
  update: FitPicReportUpdateWithoutReportedDataInput;
  create: FitPicReportCreateWithoutReportedInput;
}

export interface FitPicReportScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<FitPicReportStatus>;
  status_not?: Maybe<FitPicReportStatus>;
  status_in?: Maybe<FitPicReportStatus[] | FitPicReportStatus>;
  status_not_in?: Maybe<FitPicReportStatus[] | FitPicReportStatus>;
  reportedAt?: Maybe<DateTimeInput>;
  reportedAt_not?: Maybe<DateTimeInput>;
  reportedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reportedAt_lt?: Maybe<DateTimeInput>;
  reportedAt_lte?: Maybe<DateTimeInput>;
  reportedAt_gt?: Maybe<DateTimeInput>;
  reportedAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FitPicReportScalarWhereInput[] | FitPicReportScalarWhereInput>;
  OR?: Maybe<FitPicReportScalarWhereInput[] | FitPicReportScalarWhereInput>;
  NOT?: Maybe<FitPicReportScalarWhereInput[] | FitPicReportScalarWhereInput>;
}

export interface FitPicReportUpdateManyWithWhereNestedInput {
  where: FitPicReportScalarWhereInput;
  data: FitPicReportUpdateManyDataInput;
}

export interface FitPicReportUpdateManyDataInput {
  status?: Maybe<FitPicReportStatus>;
}

export interface FitPicUpsertWithWhereUniqueWithoutUserInput {
  where: FitPicWhereUniqueInput;
  update: FitPicUpdateWithoutUserDataInput;
  create: FitPicCreateWithoutUserInput;
}

export interface FitPicScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  includeInstagramHandle?: Maybe<Boolean>;
  includeInstagramHandle_not?: Maybe<Boolean>;
  status?: Maybe<FitPicStatus>;
  status_not?: Maybe<FitPicStatus>;
  status_in?: Maybe<FitPicStatus[] | FitPicStatus>;
  status_not_in?: Maybe<FitPicStatus[] | FitPicStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FitPicScalarWhereInput[] | FitPicScalarWhereInput>;
  OR?: Maybe<FitPicScalarWhereInput[] | FitPicScalarWhereInput>;
  NOT?: Maybe<FitPicScalarWhereInput[] | FitPicScalarWhereInput>;
}

export interface FitPicUpdateManyWithWhereNestedInput {
  where: FitPicScalarWhereInput;
  data: FitPicUpdateManyDataInput;
}

export interface FitPicUpdateManyDataInput {
  includeInstagramHandle?: Maybe<Boolean>;
  status?: Maybe<FitPicStatus>;
}

export interface UserUpsertWithWhereUniqueWithoutPushNotificationsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutPushNotificationsDataInput;
  create: UserCreateWithoutPushNotificationsInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  auth0Id?: Maybe<String>;
  auth0Id_not?: Maybe<String>;
  auth0Id_in?: Maybe<String[] | String>;
  auth0Id_not_in?: Maybe<String[] | String>;
  auth0Id_lt?: Maybe<String>;
  auth0Id_lte?: Maybe<String>;
  auth0Id_gt?: Maybe<String>;
  auth0Id_gte?: Maybe<String>;
  auth0Id_contains?: Maybe<String>;
  auth0Id_not_contains?: Maybe<String>;
  auth0Id_starts_with?: Maybe<String>;
  auth0Id_not_starts_with?: Maybe<String>;
  auth0Id_ends_with?: Maybe<String>;
  auth0Id_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotificationStatus_not?: Maybe<PushNotificationStatus>;
  pushNotificationStatus_in?: Maybe<
    PushNotificationStatus[] | PushNotificationStatus
  >;
  pushNotificationStatus_not_in?: Maybe<
    PushNotificationStatus[] | PushNotificationStatus
  >;
  sendSystemEmails?: Maybe<Boolean>;
  sendSystemEmails_not?: Maybe<Boolean>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationStatus_not?: Maybe<UserVerificationStatus>;
  verificationStatus_in?: Maybe<
    UserVerificationStatus[] | UserVerificationStatus
  >;
  verificationStatus_not_in?: Maybe<
    UserVerificationStatus[] | UserVerificationStatus
  >;
  verificationMethod?: Maybe<UserVerificationMethod>;
  verificationMethod_not?: Maybe<UserVerificationMethod>;
  verificationMethod_in?: Maybe<
    UserVerificationMethod[] | UserVerificationMethod
  >;
  verificationMethod_not_in?: Maybe<
    UserVerificationMethod[] | UserVerificationMethod
  >;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserUpdaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  sendSystemEmails?: Maybe<Boolean>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
}

export interface PushNotificationReceiptUpsertWithWhereUniqueNestedInput {
  where: PushNotificationReceiptWhereUniqueInput;
  update: PushNotificationReceiptUpdateDataInput;
  create: PushNotificationReceiptCreateInput;
}

export interface UserPushNotificationUpsertNestedInput {
  update: UserPushNotificationUpdateDataInput;
  create: UserPushNotificationCreateInput;
}

export interface AdminActionLogCreateInput {
  actionId?: Maybe<Int>;
  entityId: String;
  tableName: String;
  activeAdminUser: UserCreateOneInput;
  triggeredAt: DateTimeInput;
  action: AdminAction;
  rowData: Json;
  changedFields?: Maybe<Json>;
  statementOnly: Boolean;
}

export interface AdminActionLogUpdateInput {
  entityId?: Maybe<String>;
  tableName?: Maybe<String>;
  activeAdminUser?: Maybe<UserUpdateOneRequiredInput>;
  triggeredAt?: Maybe<DateTimeInput>;
  action?: Maybe<AdminAction>;
  rowData?: Maybe<Json>;
  changedFields?: Maybe<Json>;
  statementOnly?: Maybe<Boolean>;
}

export interface AdminActionLogUpdateManyMutationInput {
  entityId?: Maybe<String>;
  tableName?: Maybe<String>;
  triggeredAt?: Maybe<DateTimeInput>;
  action?: Maybe<AdminAction>;
  rowData?: Maybe<Json>;
  changedFields?: Maybe<Json>;
  statementOnly?: Maybe<Boolean>;
}

export interface BagItemCreateInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneWithoutBagItemsInput;
  productVariant: ProductVariantCreateOneInput;
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status: BagItemStatus;
}

export interface CustomerCreateOneWithoutBagItemsInput {
  create?: Maybe<CustomerCreateWithoutBagItemsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutBagItemsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipCreateOneWithoutCustomerInput>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerCreateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerCreateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataCreateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataCreateOneWithoutCustomerInput>;
}

export interface CustomerDetailCreateOneInput {
  create?: Maybe<CustomerDetailCreateInput>;
  connect?: Maybe<CustomerDetailWhereUniqueInput>;
}

export interface CustomerDetailCreateInput {
  id?: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<CustomerDetailCreateweightInput>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  topSizes?: Maybe<CustomerDetailCreatetopSizesInput>;
  averageWaistSize?: Maybe<String>;
  waistSizes?: Maybe<CustomerDetailCreatewaistSizesInput>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  stylePreferences?: Maybe<StylePreferencesCreateOneInput>;
  shippingAddress?: Maybe<LocationCreateOneInput>;
  phoneOS?: Maybe<String>;
  insureShipment?: Maybe<Boolean>;
  instagramHandle?: Maybe<String>;
}

export interface CustomerDetailCreateweightInput {
  set?: Maybe<Int[] | Int>;
}

export interface CustomerDetailCreatetopSizesInput {
  set?: Maybe<String[] | String>;
}

export interface CustomerDetailCreatewaistSizesInput {
  set?: Maybe<Int[] | Int>;
}

export interface StylePreferencesCreateOneInput {
  create?: Maybe<StylePreferencesCreateInput>;
  connect?: Maybe<StylePreferencesWhereUniqueInput>;
}

export interface StylePreferencesCreateInput {
  id?: Maybe<ID_Input>;
  styles?: Maybe<StylePreferencesCreatestylesInput>;
  patterns?: Maybe<StylePreferencesCreatepatternsInput>;
  colors?: Maybe<StylePreferencesCreatecolorsInput>;
  brands?: Maybe<StylePreferencesCreatebrandsInput>;
}

export interface StylePreferencesCreatestylesInput {
  set?: Maybe<String[] | String>;
}

export interface StylePreferencesCreatepatternsInput {
  set?: Maybe<String[] | String>;
}

export interface StylePreferencesCreatecolorsInput {
  set?: Maybe<String[] | String>;
}

export interface StylePreferencesCreatebrandsInput {
  set?: Maybe<String[] | String>;
}

export interface BillingInfoCreateOneInput {
  create?: Maybe<BillingInfoCreateInput>;
  connect?: Maybe<BillingInfoWhereUniqueInput>;
}

export interface BillingInfoCreateInput {
  id?: Maybe<ID_Input>;
  brand: String;
  name?: Maybe<String>;
  last_digits: String;
  expiration_month: Int;
  expiration_year: Int;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface CustomerMembershipCreateOneWithoutCustomerInput {
  create?: Maybe<CustomerMembershipCreateWithoutCustomerInput>;
  connect?: Maybe<CustomerMembershipWhereUniqueInput>;
}

export interface CustomerMembershipCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  plan?: Maybe<PaymentPlanCreateOneInput>;
  subscriptionId: String;
  pauseRequests?: Maybe<PauseRequestCreateManyWithoutMembershipInput>;
  giftId?: Maybe<String>;
}

export interface PaymentPlanCreateOneInput {
  create?: Maybe<PaymentPlanCreateInput>;
  connect?: Maybe<PaymentPlanWhereUniqueInput>;
}

export interface PaymentPlanCreateInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  planID: String;
  status?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  itemCount?: Maybe<Int>;
  tagline?: Maybe<String>;
  tier?: Maybe<PaymentPlanTier>;
}

export interface PauseRequestCreateManyWithoutMembershipInput {
  create?: Maybe<
    | PauseRequestCreateWithoutMembershipInput[]
    | PauseRequestCreateWithoutMembershipInput
  >;
  connect?: Maybe<
    PauseRequestWhereUniqueInput[] | PauseRequestWhereUniqueInput
  >;
}

export interface PauseRequestCreateWithoutMembershipInput {
  id?: Maybe<ID_Input>;
  pausePending: Boolean;
  pauseDate?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
}

export interface ReservationCreateManyWithoutCustomerInput {
  create?: Maybe<
    | ReservationCreateWithoutCustomerInput[]
    | ReservationCreateWithoutCustomerInput
  >;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
}

export interface ReservationCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  sentPackage?: Maybe<PackageCreateOneInput>;
  returnedPackage?: Maybe<PackageCreateOneInput>;
  products?: Maybe<PhysicalProductCreateManyInput>;
  packageEvents?: Maybe<PackageTransitEventCreateManyWithoutReservationInput>;
  reservationNumber: Int;
  phase: ReservationPhase;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptCreateOneWithoutReservationInput>;
  lastLocation?: Maybe<LocationCreateOneInput>;
  shippingOption?: Maybe<ShippingOptionCreateOneInput>;
}

export interface PackageCreateOneInput {
  create?: Maybe<PackageCreateInput>;
  connect?: Maybe<PackageWhereUniqueInput>;
}

export interface PackageCreateInput {
  id?: Maybe<ID_Input>;
  items?: Maybe<PhysicalProductCreateManyInput>;
  transactionID: String;
  shippingLabel: LabelCreateOneInput;
  fromAddress: LocationCreateOneInput;
  toAddress: LocationCreateOneInput;
  weight?: Maybe<Float>;
  cost?: Maybe<Int>;
  events?: Maybe<PackageTransitEventCreateManyWithoutPackageInput>;
}

export interface PhysicalProductCreateManyInput {
  create?: Maybe<PhysicalProductCreateInput[] | PhysicalProductCreateInput>;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
}

export interface PhysicalProductCreateInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  location?: Maybe<LocationCreateOneWithoutPhysicalProductsInput>;
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber: Int;
  warehouseLocation?: Maybe<
    WarehouseLocationCreateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceCreateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportCreateManyWithoutPhysicalProductInput
  >;
}

export interface LabelCreateOneInput {
  create?: Maybe<LabelCreateInput>;
  connect?: Maybe<LabelWhereUniqueInput>;
}

export interface LabelCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export interface PackageTransitEventCreateManyWithoutPackageInput {
  create?: Maybe<
    | PackageTransitEventCreateWithoutPackageInput[]
    | PackageTransitEventCreateWithoutPackageInput
  >;
  connect?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
}

export interface PackageTransitEventCreateWithoutPackageInput {
  id?: Maybe<ID_Input>;
  status: PackageTransitEventStatus;
  subStatus: PackageTransitEventSubStatus;
  reservation?: Maybe<ReservationCreateOneWithoutPackageEventsInput>;
  data: Json;
}

export interface ReservationCreateOneWithoutPackageEventsInput {
  create?: Maybe<ReservationCreateWithoutPackageEventsInput>;
  connect?: Maybe<ReservationWhereUniqueInput>;
}

export interface ReservationCreateWithoutPackageEventsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  customer: CustomerCreateOneWithoutReservationsInput;
  sentPackage?: Maybe<PackageCreateOneInput>;
  returnedPackage?: Maybe<PackageCreateOneInput>;
  products?: Maybe<PhysicalProductCreateManyInput>;
  reservationNumber: Int;
  phase: ReservationPhase;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptCreateOneWithoutReservationInput>;
  lastLocation?: Maybe<LocationCreateOneInput>;
  shippingOption?: Maybe<ShippingOptionCreateOneInput>;
}

export interface CustomerCreateOneWithoutReservationsInput {
  create?: Maybe<CustomerCreateWithoutReservationsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutReservationsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipCreateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerCreateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerCreateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataCreateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataCreateOneWithoutCustomerInput>;
}

export interface BagItemCreateManyWithoutCustomerInput {
  create?: Maybe<
    BagItemCreateWithoutCustomerInput[] | BagItemCreateWithoutCustomerInput
  >;
  connect?: Maybe<BagItemWhereUniqueInput[] | BagItemWhereUniqueInput>;
}

export interface BagItemCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  productVariant: ProductVariantCreateOneInput;
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status: BagItemStatus;
}

export interface ProductVariantCreateOneInput {
  create?: Maybe<ProductVariantCreateInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface ProductVariantCreateInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  displayShort: String;
  color: ColorCreateOneWithoutProductVariantsInput;
  internalSize?: Maybe<SizeCreateOneInput>;
  manufacturerSizes?: Maybe<SizeCreateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  product: ProductCreateOneWithoutVariantsInput;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceCreateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantCreateOneInput>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutProductVariantInput>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  offloaded: Int;
  stored: Int;
}

export interface CustomerCreateOneWithoutReferreesInput {
  create?: Maybe<CustomerCreateWithoutReferreesInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutReferreesInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipCreateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemCreateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerCreateOneWithoutReferreesInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataCreateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataCreateOneWithoutCustomerInput>;
}

export interface CustomerAdmissionsDataCreateOneWithoutCustomerInput {
  create?: Maybe<CustomerAdmissionsDataCreateWithoutCustomerInput>;
  connect?: Maybe<CustomerAdmissionsDataWhereUniqueInput>;
}

export interface CustomerAdmissionsDataCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  inServiceableZipcode: Boolean;
  admissable: Boolean;
  inAdmissableReason?: Maybe<InAdmissableReason>;
  allAccessEnabled?: Maybe<Boolean>;
  authorizationsCount: Int;
  authorizationWindowClosesAt?: Maybe<DateTimeInput>;
}

export interface UTMDataCreateOneWithoutCustomerInput {
  create?: Maybe<UTMDataCreateWithoutCustomerInput>;
  connect?: Maybe<UTMDataWhereUniqueInput>;
}

export interface UTMDataCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  source?: Maybe<String>;
  medium?: Maybe<String>;
  campaign?: Maybe<String>;
  term?: Maybe<String>;
  content?: Maybe<String>;
}

export interface CustomerCreateManyWithoutReferrerInput {
  create?: Maybe<
    CustomerCreateWithoutReferrerInput[] | CustomerCreateWithoutReferrerInput
  >;
  connect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutReferrerInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipCreateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemCreateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrees?: Maybe<CustomerCreateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataCreateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataCreateOneWithoutCustomerInput>;
}

export interface ReservationReceiptCreateOneWithoutReservationInput {
  create?: Maybe<ReservationReceiptCreateWithoutReservationInput>;
  connect?: Maybe<ReservationReceiptWhereUniqueInput>;
}

export interface ReservationReceiptCreateWithoutReservationInput {
  id?: Maybe<ID_Input>;
  items?: Maybe<ReservationReceiptItemCreateManyInput>;
}

export interface ReservationReceiptItemCreateManyInput {
  create?: Maybe<
    ReservationReceiptItemCreateInput[] | ReservationReceiptItemCreateInput
  >;
  connect?: Maybe<
    | ReservationReceiptItemWhereUniqueInput[]
    | ReservationReceiptItemWhereUniqueInput
  >;
}

export interface ReservationReceiptItemCreateInput {
  id?: Maybe<ID_Input>;
  product: PhysicalProductCreateOneInput;
  productStatus: PhysicalProductStatus;
  notes?: Maybe<String>;
}

export interface PhysicalProductCreateOneInput {
  create?: Maybe<PhysicalProductCreateInput>;
  connect?: Maybe<PhysicalProductWhereUniqueInput>;
}

export interface ShippingOptionCreateOneInput {
  create?: Maybe<ShippingOptionCreateInput>;
  connect?: Maybe<ShippingOptionWhereUniqueInput>;
}

export interface ShippingOptionCreateInput {
  id?: Maybe<ID_Input>;
  origin?: Maybe<LocationCreateOneInput>;
  destination?: Maybe<LocationCreateOneWithoutShippingOptionsInput>;
  shippingMethod?: Maybe<ShippingMethodCreateOneInput>;
  externalCost?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
}

export interface LocationCreateOneWithoutShippingOptionsInput {
  create?: Maybe<LocationCreateWithoutShippingOptionsInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationCreateWithoutShippingOptionsInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode: String;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserCreateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutLocationInput>;
}

export interface PackageTransitEventCreateManyWithoutReservationInput {
  create?: Maybe<
    | PackageTransitEventCreateWithoutReservationInput[]
    | PackageTransitEventCreateWithoutReservationInput
  >;
  connect?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
}

export interface PackageTransitEventCreateWithoutReservationInput {
  id?: Maybe<ID_Input>;
  status: PackageTransitEventStatus;
  subStatus: PackageTransitEventSubStatus;
  package: PackageCreateOneWithoutEventsInput;
  data: Json;
}

export interface PackageCreateOneWithoutEventsInput {
  create?: Maybe<PackageCreateWithoutEventsInput>;
  connect?: Maybe<PackageWhereUniqueInput>;
}

export interface PackageCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  items?: Maybe<PhysicalProductCreateManyInput>;
  transactionID: String;
  shippingLabel: LabelCreateOneInput;
  fromAddress: LocationCreateOneInput;
  toAddress: LocationCreateOneInput;
  weight?: Maybe<Float>;
  cost?: Maybe<Int>;
}

export interface BagItemUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredWithoutBagItemsInput>;
  productVariant?: Maybe<ProductVariantUpdateOneRequiredInput>;
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
}

export interface CustomerUpdateOneRequiredWithoutBagItemsInput {
  create?: Maybe<CustomerCreateWithoutBagItemsInput>;
  update?: Maybe<CustomerUpdateWithoutBagItemsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutBagItemsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutBagItemsDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface CustomerDetailUpdateOneInput {
  create?: Maybe<CustomerDetailCreateInput>;
  update?: Maybe<CustomerDetailUpdateDataInput>;
  upsert?: Maybe<CustomerDetailUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerDetailWhereUniqueInput>;
}

export interface CustomerDetailUpdateDataInput {
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<CustomerDetailUpdateweightInput>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  topSizes?: Maybe<CustomerDetailUpdatetopSizesInput>;
  averageWaistSize?: Maybe<String>;
  waistSizes?: Maybe<CustomerDetailUpdatewaistSizesInput>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  stylePreferences?: Maybe<StylePreferencesUpdateOneInput>;
  shippingAddress?: Maybe<LocationUpdateOneInput>;
  phoneOS?: Maybe<String>;
  insureShipment?: Maybe<Boolean>;
  instagramHandle?: Maybe<String>;
}

export interface CustomerDetailUpdateweightInput {
  set?: Maybe<Int[] | Int>;
}

export interface CustomerDetailUpdatetopSizesInput {
  set?: Maybe<String[] | String>;
}

export interface CustomerDetailUpdatewaistSizesInput {
  set?: Maybe<Int[] | Int>;
}

export interface StylePreferencesUpdateOneInput {
  create?: Maybe<StylePreferencesCreateInput>;
  update?: Maybe<StylePreferencesUpdateDataInput>;
  upsert?: Maybe<StylePreferencesUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StylePreferencesWhereUniqueInput>;
}

export interface StylePreferencesUpdateDataInput {
  styles?: Maybe<StylePreferencesUpdatestylesInput>;
  patterns?: Maybe<StylePreferencesUpdatepatternsInput>;
  colors?: Maybe<StylePreferencesUpdatecolorsInput>;
  brands?: Maybe<StylePreferencesUpdatebrandsInput>;
}

export interface StylePreferencesUpdatestylesInput {
  set?: Maybe<String[] | String>;
}

export interface StylePreferencesUpdatepatternsInput {
  set?: Maybe<String[] | String>;
}

export interface StylePreferencesUpdatecolorsInput {
  set?: Maybe<String[] | String>;
}

export interface StylePreferencesUpdatebrandsInput {
  set?: Maybe<String[] | String>;
}

export interface StylePreferencesUpsertNestedInput {
  update: StylePreferencesUpdateDataInput;
  create: StylePreferencesCreateInput;
}

export interface CustomerDetailUpsertNestedInput {
  update: CustomerDetailUpdateDataInput;
  create: CustomerDetailCreateInput;
}

export interface BillingInfoUpdateOneInput {
  create?: Maybe<BillingInfoCreateInput>;
  update?: Maybe<BillingInfoUpdateDataInput>;
  upsert?: Maybe<BillingInfoUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BillingInfoWhereUniqueInput>;
}

export interface BillingInfoUpdateDataInput {
  brand?: Maybe<String>;
  name?: Maybe<String>;
  last_digits?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface BillingInfoUpsertNestedInput {
  update: BillingInfoUpdateDataInput;
  create: BillingInfoCreateInput;
}

export interface CustomerMembershipUpdateOneWithoutCustomerInput {
  create?: Maybe<CustomerMembershipCreateWithoutCustomerInput>;
  update?: Maybe<CustomerMembershipUpdateWithoutCustomerDataInput>;
  upsert?: Maybe<CustomerMembershipUpsertWithoutCustomerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerMembershipWhereUniqueInput>;
}

export interface CustomerMembershipUpdateWithoutCustomerDataInput {
  plan?: Maybe<PaymentPlanUpdateOneInput>;
  subscriptionId?: Maybe<String>;
  pauseRequests?: Maybe<PauseRequestUpdateManyWithoutMembershipInput>;
  giftId?: Maybe<String>;
}

export interface PaymentPlanUpdateOneInput {
  create?: Maybe<PaymentPlanCreateInput>;
  update?: Maybe<PaymentPlanUpdateDataInput>;
  upsert?: Maybe<PaymentPlanUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentPlanWhereUniqueInput>;
}

export interface PaymentPlanUpdateDataInput {
  description?: Maybe<String>;
  planID?: Maybe<String>;
  status?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  itemCount?: Maybe<Int>;
  tagline?: Maybe<String>;
  tier?: Maybe<PaymentPlanTier>;
}

export interface PaymentPlanUpsertNestedInput {
  update: PaymentPlanUpdateDataInput;
  create: PaymentPlanCreateInput;
}

export interface PauseRequestUpdateManyWithoutMembershipInput {
  create?: Maybe<
    | PauseRequestCreateWithoutMembershipInput[]
    | PauseRequestCreateWithoutMembershipInput
  >;
  delete?: Maybe<PauseRequestWhereUniqueInput[] | PauseRequestWhereUniqueInput>;
  connect?: Maybe<
    PauseRequestWhereUniqueInput[] | PauseRequestWhereUniqueInput
  >;
  set?: Maybe<PauseRequestWhereUniqueInput[] | PauseRequestWhereUniqueInput>;
  disconnect?: Maybe<
    PauseRequestWhereUniqueInput[] | PauseRequestWhereUniqueInput
  >;
  update?: Maybe<
    | PauseRequestUpdateWithWhereUniqueWithoutMembershipInput[]
    | PauseRequestUpdateWithWhereUniqueWithoutMembershipInput
  >;
  upsert?: Maybe<
    | PauseRequestUpsertWithWhereUniqueWithoutMembershipInput[]
    | PauseRequestUpsertWithWhereUniqueWithoutMembershipInput
  >;
  deleteMany?: Maybe<
    PauseRequestScalarWhereInput[] | PauseRequestScalarWhereInput
  >;
  updateMany?: Maybe<
    | PauseRequestUpdateManyWithWhereNestedInput[]
    | PauseRequestUpdateManyWithWhereNestedInput
  >;
}

export interface PauseRequestUpdateWithWhereUniqueWithoutMembershipInput {
  where: PauseRequestWhereUniqueInput;
  data: PauseRequestUpdateWithoutMembershipDataInput;
}

export interface PauseRequestUpdateWithoutMembershipDataInput {
  pausePending?: Maybe<Boolean>;
  pauseDate?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
}

export interface PauseRequestUpsertWithWhereUniqueWithoutMembershipInput {
  where: PauseRequestWhereUniqueInput;
  update: PauseRequestUpdateWithoutMembershipDataInput;
  create: PauseRequestCreateWithoutMembershipInput;
}

export interface PauseRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  pausePending?: Maybe<Boolean>;
  pausePending_not?: Maybe<Boolean>;
  pauseDate?: Maybe<DateTimeInput>;
  pauseDate_not?: Maybe<DateTimeInput>;
  pauseDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pauseDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pauseDate_lt?: Maybe<DateTimeInput>;
  pauseDate_lte?: Maybe<DateTimeInput>;
  pauseDate_gt?: Maybe<DateTimeInput>;
  pauseDate_gte?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  resumeDate_not?: Maybe<DateTimeInput>;
  resumeDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resumeDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resumeDate_lt?: Maybe<DateTimeInput>;
  resumeDate_lte?: Maybe<DateTimeInput>;
  resumeDate_gt?: Maybe<DateTimeInput>;
  resumeDate_gte?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
  notified_not?: Maybe<Boolean>;
  AND?: Maybe<PauseRequestScalarWhereInput[] | PauseRequestScalarWhereInput>;
  OR?: Maybe<PauseRequestScalarWhereInput[] | PauseRequestScalarWhereInput>;
  NOT?: Maybe<PauseRequestScalarWhereInput[] | PauseRequestScalarWhereInput>;
}

export interface PauseRequestUpdateManyWithWhereNestedInput {
  where: PauseRequestScalarWhereInput;
  data: PauseRequestUpdateManyDataInput;
}

export interface PauseRequestUpdateManyDataInput {
  pausePending?: Maybe<Boolean>;
  pauseDate?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
}

export interface CustomerMembershipUpsertWithoutCustomerInput {
  update: CustomerMembershipUpdateWithoutCustomerDataInput;
  create: CustomerMembershipCreateWithoutCustomerInput;
}

export interface ReservationUpdateManyWithoutCustomerInput {
  create?: Maybe<
    | ReservationCreateWithoutCustomerInput[]
    | ReservationCreateWithoutCustomerInput
  >;
  delete?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  set?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  disconnect?: Maybe<
    ReservationWhereUniqueInput[] | ReservationWhereUniqueInput
  >;
  update?: Maybe<
    | ReservationUpdateWithWhereUniqueWithoutCustomerInput[]
    | ReservationUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | ReservationUpsertWithWhereUniqueWithoutCustomerInput[]
    | ReservationUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<
    ReservationScalarWhereInput[] | ReservationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ReservationUpdateManyWithWhereNestedInput[]
    | ReservationUpdateManyWithWhereNestedInput
  >;
}

export interface ReservationUpdateWithWhereUniqueWithoutCustomerInput {
  where: ReservationWhereUniqueInput;
  data: ReservationUpdateWithoutCustomerDataInput;
}

export interface ReservationUpdateWithoutCustomerDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  sentPackage?: Maybe<PackageUpdateOneInput>;
  returnedPackage?: Maybe<PackageUpdateOneInput>;
  products?: Maybe<PhysicalProductUpdateManyInput>;
  packageEvents?: Maybe<PackageTransitEventUpdateManyWithoutReservationInput>;
  reservationNumber?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptUpdateOneWithoutReservationInput>;
  lastLocation?: Maybe<LocationUpdateOneInput>;
  shippingOption?: Maybe<ShippingOptionUpdateOneInput>;
}

export interface PackageUpdateOneInput {
  create?: Maybe<PackageCreateInput>;
  update?: Maybe<PackageUpdateDataInput>;
  upsert?: Maybe<PackageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PackageWhereUniqueInput>;
}

export interface PackageUpdateDataInput {
  items?: Maybe<PhysicalProductUpdateManyInput>;
  transactionID?: Maybe<String>;
  shippingLabel?: Maybe<LabelUpdateOneRequiredInput>;
  fromAddress?: Maybe<LocationUpdateOneRequiredInput>;
  toAddress?: Maybe<LocationUpdateOneRequiredInput>;
  weight?: Maybe<Float>;
  cost?: Maybe<Int>;
  events?: Maybe<PackageTransitEventUpdateManyWithoutPackageInput>;
}

export interface PhysicalProductUpdateManyInput {
  create?: Maybe<PhysicalProductCreateInput[] | PhysicalProductCreateInput>;
  update?: Maybe<
    | PhysicalProductUpdateWithWhereUniqueNestedInput[]
    | PhysicalProductUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PhysicalProductUpsertWithWhereUniqueNestedInput[]
    | PhysicalProductUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  set?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  deleteMany?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductUpdateManyWithWhereNestedInput[]
    | PhysicalProductUpdateManyWithWhereNestedInput
  >;
}

export interface PhysicalProductUpdateWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput;
  data: PhysicalProductUpdateDataInput;
}

export interface PhysicalProductUpdateDataInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneWithoutPhysicalProductsInput>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  warehouseLocation?: Maybe<
    WarehouseLocationUpdateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceUpdateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportUpdateManyWithoutPhysicalProductInput
  >;
}

export interface PhysicalProductUpsertWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput;
  update: PhysicalProductUpdateDataInput;
  create: PhysicalProductCreateInput;
}

export interface LabelUpdateOneRequiredInput {
  create?: Maybe<LabelCreateInput>;
  update?: Maybe<LabelUpdateDataInput>;
  upsert?: Maybe<LabelUpsertNestedInput>;
  connect?: Maybe<LabelWhereUniqueInput>;
}

export interface LabelUpdateDataInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export interface LabelUpsertNestedInput {
  update: LabelUpdateDataInput;
  create: LabelCreateInput;
}

export interface LocationUpdateOneRequiredInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface PackageTransitEventUpdateManyWithoutPackageInput {
  create?: Maybe<
    | PackageTransitEventCreateWithoutPackageInput[]
    | PackageTransitEventCreateWithoutPackageInput
  >;
  delete?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  connect?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  set?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  disconnect?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  update?: Maybe<
    | PackageTransitEventUpdateWithWhereUniqueWithoutPackageInput[]
    | PackageTransitEventUpdateWithWhereUniqueWithoutPackageInput
  >;
  upsert?: Maybe<
    | PackageTransitEventUpsertWithWhereUniqueWithoutPackageInput[]
    | PackageTransitEventUpsertWithWhereUniqueWithoutPackageInput
  >;
  deleteMany?: Maybe<
    PackageTransitEventScalarWhereInput[] | PackageTransitEventScalarWhereInput
  >;
  updateMany?: Maybe<
    | PackageTransitEventUpdateManyWithWhereNestedInput[]
    | PackageTransitEventUpdateManyWithWhereNestedInput
  >;
}

export interface PackageTransitEventUpdateWithWhereUniqueWithoutPackageInput {
  where: PackageTransitEventWhereUniqueInput;
  data: PackageTransitEventUpdateWithoutPackageDataInput;
}

export interface PackageTransitEventUpdateWithoutPackageDataInput {
  status?: Maybe<PackageTransitEventStatus>;
  subStatus?: Maybe<PackageTransitEventSubStatus>;
  reservation?: Maybe<ReservationUpdateOneWithoutPackageEventsInput>;
  data?: Maybe<Json>;
}

export interface ReservationUpdateOneWithoutPackageEventsInput {
  create?: Maybe<ReservationCreateWithoutPackageEventsInput>;
  update?: Maybe<ReservationUpdateWithoutPackageEventsDataInput>;
  upsert?: Maybe<ReservationUpsertWithoutPackageEventsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ReservationWhereUniqueInput>;
}

export interface ReservationUpdateWithoutPackageEventsDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutReservationsInput>;
  sentPackage?: Maybe<PackageUpdateOneInput>;
  returnedPackage?: Maybe<PackageUpdateOneInput>;
  products?: Maybe<PhysicalProductUpdateManyInput>;
  reservationNumber?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptUpdateOneWithoutReservationInput>;
  lastLocation?: Maybe<LocationUpdateOneInput>;
  shippingOption?: Maybe<ShippingOptionUpdateOneInput>;
}

export interface CustomerUpdateOneRequiredWithoutReservationsInput {
  create?: Maybe<CustomerCreateWithoutReservationsInput>;
  update?: Maybe<CustomerUpdateWithoutReservationsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutReservationsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutReservationsDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface BagItemUpdateManyWithoutCustomerInput {
  create?: Maybe<
    BagItemCreateWithoutCustomerInput[] | BagItemCreateWithoutCustomerInput
  >;
  delete?: Maybe<BagItemWhereUniqueInput[] | BagItemWhereUniqueInput>;
  connect?: Maybe<BagItemWhereUniqueInput[] | BagItemWhereUniqueInput>;
  set?: Maybe<BagItemWhereUniqueInput[] | BagItemWhereUniqueInput>;
  disconnect?: Maybe<BagItemWhereUniqueInput[] | BagItemWhereUniqueInput>;
  update?: Maybe<
    | BagItemUpdateWithWhereUniqueWithoutCustomerInput[]
    | BagItemUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | BagItemUpsertWithWhereUniqueWithoutCustomerInput[]
    | BagItemUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<BagItemScalarWhereInput[] | BagItemScalarWhereInput>;
  updateMany?: Maybe<
    | BagItemUpdateManyWithWhereNestedInput[]
    | BagItemUpdateManyWithWhereNestedInput
  >;
}

export interface BagItemUpdateWithWhereUniqueWithoutCustomerInput {
  where: BagItemWhereUniqueInput;
  data: BagItemUpdateWithoutCustomerDataInput;
}

export interface BagItemUpdateWithoutCustomerDataInput {
  productVariant?: Maybe<ProductVariantUpdateOneRequiredInput>;
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
}

export interface ProductVariantUpdateOneRequiredInput {
  create?: Maybe<ProductVariantCreateInput>;
  update?: Maybe<ProductVariantUpdateDataInput>;
  upsert?: Maybe<ProductVariantUpsertNestedInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface ProductVariantUpdateDataInput {
  sku?: Maybe<String>;
  displayShort?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  internalSize?: Maybe<SizeUpdateOneInput>;
  manufacturerSizes?: Maybe<SizeUpdateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceUpdateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantUpdateOneInput>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  stored?: Maybe<Int>;
}

export interface ProductVariantUpsertNestedInput {
  update: ProductVariantUpdateDataInput;
  create: ProductVariantCreateInput;
}

export interface BagItemUpsertWithWhereUniqueWithoutCustomerInput {
  where: BagItemWhereUniqueInput;
  update: BagItemUpdateWithoutCustomerDataInput;
  create: BagItemCreateWithoutCustomerInput;
}

export interface BagItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  position?: Maybe<Int>;
  position_not?: Maybe<Int>;
  position_in?: Maybe<Int[] | Int>;
  position_not_in?: Maybe<Int[] | Int>;
  position_lt?: Maybe<Int>;
  position_lte?: Maybe<Int>;
  position_gt?: Maybe<Int>;
  position_gte?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  saved_not?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
  status_not?: Maybe<BagItemStatus>;
  status_in?: Maybe<BagItemStatus[] | BagItemStatus>;
  status_not_in?: Maybe<BagItemStatus[] | BagItemStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BagItemScalarWhereInput[] | BagItemScalarWhereInput>;
  OR?: Maybe<BagItemScalarWhereInput[] | BagItemScalarWhereInput>;
  NOT?: Maybe<BagItemScalarWhereInput[] | BagItemScalarWhereInput>;
}

export interface BagItemUpdateManyWithWhereNestedInput {
  where: BagItemScalarWhereInput;
  data: BagItemUpdateManyDataInput;
}

export interface BagItemUpdateManyDataInput {
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
}

export interface CustomerUpdateOneWithoutReferreesInput {
  create?: Maybe<CustomerCreateWithoutReferreesInput>;
  update?: Maybe<CustomerUpdateWithoutReferreesDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutReferreesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutReferreesDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface CustomerAdmissionsDataUpdateOneWithoutCustomerInput {
  create?: Maybe<CustomerAdmissionsDataCreateWithoutCustomerInput>;
  update?: Maybe<CustomerAdmissionsDataUpdateWithoutCustomerDataInput>;
  upsert?: Maybe<CustomerAdmissionsDataUpsertWithoutCustomerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerAdmissionsDataWhereUniqueInput>;
}

export interface CustomerAdmissionsDataUpdateWithoutCustomerDataInput {
  inServiceableZipcode?: Maybe<Boolean>;
  admissable?: Maybe<Boolean>;
  inAdmissableReason?: Maybe<InAdmissableReason>;
  allAccessEnabled?: Maybe<Boolean>;
  authorizationsCount?: Maybe<Int>;
  authorizationWindowClosesAt?: Maybe<DateTimeInput>;
}

export interface CustomerAdmissionsDataUpsertWithoutCustomerInput {
  update: CustomerAdmissionsDataUpdateWithoutCustomerDataInput;
  create: CustomerAdmissionsDataCreateWithoutCustomerInput;
}

export interface UTMDataUpdateOneWithoutCustomerInput {
  create?: Maybe<UTMDataCreateWithoutCustomerInput>;
  update?: Maybe<UTMDataUpdateWithoutCustomerDataInput>;
  upsert?: Maybe<UTMDataUpsertWithoutCustomerInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UTMDataWhereUniqueInput>;
}

export interface UTMDataUpdateWithoutCustomerDataInput {
  source?: Maybe<String>;
  medium?: Maybe<String>;
  campaign?: Maybe<String>;
  term?: Maybe<String>;
  content?: Maybe<String>;
}

export interface UTMDataUpsertWithoutCustomerInput {
  update: UTMDataUpdateWithoutCustomerDataInput;
  create: UTMDataCreateWithoutCustomerInput;
}

export interface CustomerUpsertWithoutReferreesInput {
  update: CustomerUpdateWithoutReferreesDataInput;
  create: CustomerCreateWithoutReferreesInput;
}

export interface CustomerUpdateManyWithoutReferrerInput {
  create?: Maybe<
    CustomerCreateWithoutReferrerInput[] | CustomerCreateWithoutReferrerInput
  >;
  delete?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  connect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  set?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  disconnect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  update?: Maybe<
    | CustomerUpdateWithWhereUniqueWithoutReferrerInput[]
    | CustomerUpdateWithWhereUniqueWithoutReferrerInput
  >;
  upsert?: Maybe<
    | CustomerUpsertWithWhereUniqueWithoutReferrerInput[]
    | CustomerUpsertWithWhereUniqueWithoutReferrerInput
  >;
  deleteMany?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  updateMany?: Maybe<
    | CustomerUpdateManyWithWhereNestedInput[]
    | CustomerUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerUpdateWithWhereUniqueWithoutReferrerInput {
  where: CustomerWhereUniqueInput;
  data: CustomerUpdateWithoutReferrerDataInput;
}

export interface CustomerUpdateWithoutReferrerDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface CustomerUpsertWithWhereUniqueWithoutReferrerInput {
  where: CustomerWhereUniqueInput;
  update: CustomerUpdateWithoutReferrerDataInput;
  create: CustomerCreateWithoutReferrerInput;
}

export interface CustomerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<CustomerStatus>;
  status_not?: Maybe<CustomerStatus>;
  status_in?: Maybe<CustomerStatus[] | CustomerStatus>;
  status_not_in?: Maybe<CustomerStatus[] | CustomerStatus>;
  plan?: Maybe<Plan>;
  plan_not?: Maybe<Plan>;
  plan_in?: Maybe<Plan[] | Plan>;
  plan_not_in?: Maybe<Plan[] | Plan>;
  referralLink?: Maybe<String>;
  referralLink_not?: Maybe<String>;
  referralLink_in?: Maybe<String[] | String>;
  referralLink_not_in?: Maybe<String[] | String>;
  referralLink_lt?: Maybe<String>;
  referralLink_lte?: Maybe<String>;
  referralLink_gt?: Maybe<String>;
  referralLink_gte?: Maybe<String>;
  referralLink_contains?: Maybe<String>;
  referralLink_not_contains?: Maybe<String>;
  referralLink_starts_with?: Maybe<String>;
  referralLink_not_starts_with?: Maybe<String>;
  referralLink_ends_with?: Maybe<String>;
  referralLink_not_ends_with?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrerId_not?: Maybe<String>;
  referrerId_in?: Maybe<String[] | String>;
  referrerId_not_in?: Maybe<String[] | String>;
  referrerId_lt?: Maybe<String>;
  referrerId_lte?: Maybe<String>;
  referrerId_gt?: Maybe<String>;
  referrerId_gte?: Maybe<String>;
  referrerId_contains?: Maybe<String>;
  referrerId_not_contains?: Maybe<String>;
  referrerId_starts_with?: Maybe<String>;
  referrerId_not_starts_with?: Maybe<String>;
  referrerId_ends_with?: Maybe<String>;
  referrerId_not_ends_with?: Maybe<String>;
  authorizedAt?: Maybe<DateTimeInput>;
  authorizedAt_not?: Maybe<DateTimeInput>;
  authorizedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authorizedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authorizedAt_lt?: Maybe<DateTimeInput>;
  authorizedAt_lte?: Maybe<DateTimeInput>;
  authorizedAt_gt?: Maybe<DateTimeInput>;
  authorizedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  OR?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  NOT?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
}

export interface CustomerUpdateManyWithWhereNestedInput {
  where: CustomerScalarWhereInput;
  data: CustomerUpdateManyDataInput;
}

export interface CustomerUpdateManyDataInput {
  status?: Maybe<CustomerStatus>;
  plan?: Maybe<Plan>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  authorizedAt?: Maybe<DateTimeInput>;
}

export interface CustomerUpsertWithoutReservationsInput {
  update: CustomerUpdateWithoutReservationsDataInput;
  create: CustomerCreateWithoutReservationsInput;
}

export interface ReservationReceiptUpdateOneWithoutReservationInput {
  create?: Maybe<ReservationReceiptCreateWithoutReservationInput>;
  update?: Maybe<ReservationReceiptUpdateWithoutReservationDataInput>;
  upsert?: Maybe<ReservationReceiptUpsertWithoutReservationInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ReservationReceiptWhereUniqueInput>;
}

export interface ReservationReceiptUpdateWithoutReservationDataInput {
  items?: Maybe<ReservationReceiptItemUpdateManyInput>;
}

export interface ReservationReceiptItemUpdateManyInput {
  create?: Maybe<
    ReservationReceiptItemCreateInput[] | ReservationReceiptItemCreateInput
  >;
  update?: Maybe<
    | ReservationReceiptItemUpdateWithWhereUniqueNestedInput[]
    | ReservationReceiptItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ReservationReceiptItemUpsertWithWhereUniqueNestedInput[]
    | ReservationReceiptItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | ReservationReceiptItemWhereUniqueInput[]
    | ReservationReceiptItemWhereUniqueInput
  >;
  connect?: Maybe<
    | ReservationReceiptItemWhereUniqueInput[]
    | ReservationReceiptItemWhereUniqueInput
  >;
  set?: Maybe<
    | ReservationReceiptItemWhereUniqueInput[]
    | ReservationReceiptItemWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ReservationReceiptItemWhereUniqueInput[]
    | ReservationReceiptItemWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | ReservationReceiptItemScalarWhereInput[]
    | ReservationReceiptItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | ReservationReceiptItemUpdateManyWithWhereNestedInput[]
    | ReservationReceiptItemUpdateManyWithWhereNestedInput
  >;
}

export interface ReservationReceiptItemUpdateWithWhereUniqueNestedInput {
  where: ReservationReceiptItemWhereUniqueInput;
  data: ReservationReceiptItemUpdateDataInput;
}

export interface ReservationReceiptItemUpdateDataInput {
  product?: Maybe<PhysicalProductUpdateOneRequiredInput>;
  productStatus?: Maybe<PhysicalProductStatus>;
  notes?: Maybe<String>;
}

export interface PhysicalProductUpdateOneRequiredInput {
  create?: Maybe<PhysicalProductCreateInput>;
  update?: Maybe<PhysicalProductUpdateDataInput>;
  upsert?: Maybe<PhysicalProductUpsertNestedInput>;
  connect?: Maybe<PhysicalProductWhereUniqueInput>;
}

export interface PhysicalProductUpsertNestedInput {
  update: PhysicalProductUpdateDataInput;
  create: PhysicalProductCreateInput;
}

export interface ReservationReceiptItemUpsertWithWhereUniqueNestedInput {
  where: ReservationReceiptItemWhereUniqueInput;
  update: ReservationReceiptItemUpdateDataInput;
  create: ReservationReceiptItemCreateInput;
}

export interface ReservationReceiptItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  productStatus?: Maybe<PhysicalProductStatus>;
  productStatus_not?: Maybe<PhysicalProductStatus>;
  productStatus_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  productStatus_not_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | ReservationReceiptItemScalarWhereInput[]
    | ReservationReceiptItemScalarWhereInput
  >;
  OR?: Maybe<
    | ReservationReceiptItemScalarWhereInput[]
    | ReservationReceiptItemScalarWhereInput
  >;
  NOT?: Maybe<
    | ReservationReceiptItemScalarWhereInput[]
    | ReservationReceiptItemScalarWhereInput
  >;
}

export interface ReservationReceiptItemUpdateManyWithWhereNestedInput {
  where: ReservationReceiptItemScalarWhereInput;
  data: ReservationReceiptItemUpdateManyDataInput;
}

export interface ReservationReceiptItemUpdateManyDataInput {
  productStatus?: Maybe<PhysicalProductStatus>;
  notes?: Maybe<String>;
}

export interface ReservationReceiptUpsertWithoutReservationInput {
  update: ReservationReceiptUpdateWithoutReservationDataInput;
  create: ReservationReceiptCreateWithoutReservationInput;
}

export interface ShippingOptionUpdateOneInput {
  create?: Maybe<ShippingOptionCreateInput>;
  update?: Maybe<ShippingOptionUpdateDataInput>;
  upsert?: Maybe<ShippingOptionUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShippingOptionWhereUniqueInput>;
}

export interface ShippingOptionUpdateDataInput {
  origin?: Maybe<LocationUpdateOneInput>;
  destination?: Maybe<LocationUpdateOneWithoutShippingOptionsInput>;
  shippingMethod?: Maybe<ShippingMethodUpdateOneInput>;
  externalCost?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
}

export interface LocationUpdateOneWithoutShippingOptionsInput {
  create?: Maybe<LocationCreateWithoutShippingOptionsInput>;
  update?: Maybe<LocationUpdateWithoutShippingOptionsDataInput>;
  upsert?: Maybe<LocationUpsertWithoutShippingOptionsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationUpdateWithoutShippingOptionsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserUpdateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutLocationInput>;
}

export interface LocationUpsertWithoutShippingOptionsInput {
  update: LocationUpdateWithoutShippingOptionsDataInput;
  create: LocationCreateWithoutShippingOptionsInput;
}

export interface ShippingOptionUpsertNestedInput {
  update: ShippingOptionUpdateDataInput;
  create: ShippingOptionCreateInput;
}

export interface ReservationUpsertWithoutPackageEventsInput {
  update: ReservationUpdateWithoutPackageEventsDataInput;
  create: ReservationCreateWithoutPackageEventsInput;
}

export interface PackageTransitEventUpsertWithWhereUniqueWithoutPackageInput {
  where: PackageTransitEventWhereUniqueInput;
  update: PackageTransitEventUpdateWithoutPackageDataInput;
  create: PackageTransitEventCreateWithoutPackageInput;
}

export interface PackageTransitEventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<PackageTransitEventStatus>;
  status_not?: Maybe<PackageTransitEventStatus>;
  status_in?: Maybe<PackageTransitEventStatus[] | PackageTransitEventStatus>;
  status_not_in?: Maybe<
    PackageTransitEventStatus[] | PackageTransitEventStatus
  >;
  subStatus?: Maybe<PackageTransitEventSubStatus>;
  subStatus_not?: Maybe<PackageTransitEventSubStatus>;
  subStatus_in?: Maybe<
    PackageTransitEventSubStatus[] | PackageTransitEventSubStatus
  >;
  subStatus_not_in?: Maybe<
    PackageTransitEventSubStatus[] | PackageTransitEventSubStatus
  >;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    PackageTransitEventScalarWhereInput[] | PackageTransitEventScalarWhereInput
  >;
  OR?: Maybe<
    PackageTransitEventScalarWhereInput[] | PackageTransitEventScalarWhereInput
  >;
  NOT?: Maybe<
    PackageTransitEventScalarWhereInput[] | PackageTransitEventScalarWhereInput
  >;
}

export interface PackageTransitEventUpdateManyWithWhereNestedInput {
  where: PackageTransitEventScalarWhereInput;
  data: PackageTransitEventUpdateManyDataInput;
}

export interface PackageTransitEventUpdateManyDataInput {
  status?: Maybe<PackageTransitEventStatus>;
  subStatus?: Maybe<PackageTransitEventSubStatus>;
  data?: Maybe<Json>;
}

export interface PackageUpsertNestedInput {
  update: PackageUpdateDataInput;
  create: PackageCreateInput;
}

export interface PackageTransitEventUpdateManyWithoutReservationInput {
  create?: Maybe<
    | PackageTransitEventCreateWithoutReservationInput[]
    | PackageTransitEventCreateWithoutReservationInput
  >;
  delete?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  connect?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  set?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  disconnect?: Maybe<
    PackageTransitEventWhereUniqueInput[] | PackageTransitEventWhereUniqueInput
  >;
  update?: Maybe<
    | PackageTransitEventUpdateWithWhereUniqueWithoutReservationInput[]
    | PackageTransitEventUpdateWithWhereUniqueWithoutReservationInput
  >;
  upsert?: Maybe<
    | PackageTransitEventUpsertWithWhereUniqueWithoutReservationInput[]
    | PackageTransitEventUpsertWithWhereUniqueWithoutReservationInput
  >;
  deleteMany?: Maybe<
    PackageTransitEventScalarWhereInput[] | PackageTransitEventScalarWhereInput
  >;
  updateMany?: Maybe<
    | PackageTransitEventUpdateManyWithWhereNestedInput[]
    | PackageTransitEventUpdateManyWithWhereNestedInput
  >;
}

export interface PackageTransitEventUpdateWithWhereUniqueWithoutReservationInput {
  where: PackageTransitEventWhereUniqueInput;
  data: PackageTransitEventUpdateWithoutReservationDataInput;
}

export interface PackageTransitEventUpdateWithoutReservationDataInput {
  status?: Maybe<PackageTransitEventStatus>;
  subStatus?: Maybe<PackageTransitEventSubStatus>;
  package?: Maybe<PackageUpdateOneRequiredWithoutEventsInput>;
  data?: Maybe<Json>;
}

export interface PackageUpdateOneRequiredWithoutEventsInput {
  create?: Maybe<PackageCreateWithoutEventsInput>;
  update?: Maybe<PackageUpdateWithoutEventsDataInput>;
  upsert?: Maybe<PackageUpsertWithoutEventsInput>;
  connect?: Maybe<PackageWhereUniqueInput>;
}

export interface PackageUpdateWithoutEventsDataInput {
  items?: Maybe<PhysicalProductUpdateManyInput>;
  transactionID?: Maybe<String>;
  shippingLabel?: Maybe<LabelUpdateOneRequiredInput>;
  fromAddress?: Maybe<LocationUpdateOneRequiredInput>;
  toAddress?: Maybe<LocationUpdateOneRequiredInput>;
  weight?: Maybe<Float>;
  cost?: Maybe<Int>;
}

export interface PackageUpsertWithoutEventsInput {
  update: PackageUpdateWithoutEventsDataInput;
  create: PackageCreateWithoutEventsInput;
}

export interface PackageTransitEventUpsertWithWhereUniqueWithoutReservationInput {
  where: PackageTransitEventWhereUniqueInput;
  update: PackageTransitEventUpdateWithoutReservationDataInput;
  create: PackageTransitEventCreateWithoutReservationInput;
}

export interface ReservationUpsertWithWhereUniqueWithoutCustomerInput {
  where: ReservationWhereUniqueInput;
  update: ReservationUpdateWithoutCustomerDataInput;
  create: ReservationCreateWithoutCustomerInput;
}

export interface ReservationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reservationNumber?: Maybe<Int>;
  reservationNumber_not?: Maybe<Int>;
  reservationNumber_in?: Maybe<Int[] | Int>;
  reservationNumber_not_in?: Maybe<Int[] | Int>;
  reservationNumber_lt?: Maybe<Int>;
  reservationNumber_lte?: Maybe<Int>;
  reservationNumber_gt?: Maybe<Int>;
  reservationNumber_gte?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  phase_not?: Maybe<ReservationPhase>;
  phase_in?: Maybe<ReservationPhase[] | ReservationPhase>;
  phase_not_in?: Maybe<ReservationPhase[] | ReservationPhase>;
  shipped?: Maybe<Boolean>;
  shipped_not?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  status_not?: Maybe<ReservationStatus>;
  status_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  status_not_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  shippedAt_not?: Maybe<DateTimeInput>;
  shippedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_lt?: Maybe<DateTimeInput>;
  shippedAt_lte?: Maybe<DateTimeInput>;
  shippedAt_gt?: Maybe<DateTimeInput>;
  shippedAt_gte?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  receivedAt_not?: Maybe<DateTimeInput>;
  receivedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_lt?: Maybe<DateTimeInput>;
  receivedAt_lte?: Maybe<DateTimeInput>;
  receivedAt_gt?: Maybe<DateTimeInput>;
  receivedAt_gte?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  reminderSentAt_not?: Maybe<DateTimeInput>;
  reminderSentAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reminderSentAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  reminderSentAt_lt?: Maybe<DateTimeInput>;
  reminderSentAt_lte?: Maybe<DateTimeInput>;
  reminderSentAt_gt?: Maybe<DateTimeInput>;
  reminderSentAt_gte?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  statusUpdatedAt_not?: Maybe<DateTimeInput>;
  statusUpdatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  statusUpdatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  statusUpdatedAt_lt?: Maybe<DateTimeInput>;
  statusUpdatedAt_lte?: Maybe<DateTimeInput>;
  statusUpdatedAt_gt?: Maybe<DateTimeInput>;
  statusUpdatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
  OR?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
  NOT?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
}

export interface ReservationUpdateManyWithWhereNestedInput {
  where: ReservationScalarWhereInput;
  data: ReservationUpdateManyDataInput;
}

export interface ReservationUpdateManyDataInput {
  reservationNumber?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
}

export interface CustomerUpsertWithoutBagItemsInput {
  update: CustomerUpdateWithoutBagItemsDataInput;
  create: CustomerCreateWithoutBagItemsInput;
}

export interface BagItemUpdateManyMutationInput {
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
}

export interface BillingInfoUpdateInput {
  brand?: Maybe<String>;
  name?: Maybe<String>;
  last_digits?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface BillingInfoUpdateManyMutationInput {
  brand?: Maybe<String>;
  name?: Maybe<String>;
  last_digits?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface BottomSizeUpdateInput {
  type?: Maybe<BottomSizeType>;
  value?: Maybe<String>;
  waist?: Maybe<Float>;
  rise?: Maybe<Float>;
  hem?: Maybe<Float>;
  inseam?: Maybe<Float>;
}

export interface BottomSizeUpdateManyMutationInput {
  type?: Maybe<BottomSizeType>;
  value?: Maybe<String>;
  waist?: Maybe<Float>;
  rise?: Maybe<Float>;
  hem?: Maybe<Float>;
  inseam?: Maybe<Float>;
}

export interface BrandCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  brandCode: String;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name: String;
  designer?: Maybe<String>;
  basedIn?: Maybe<String>;
  products?: Maybe<ProductCreateManyWithoutBrandInput>;
  images?: Maybe<ImageCreateManyInput>;
  since?: Maybe<DateTimeInput>;
  tier: BrandTier;
  published?: Maybe<Boolean>;
  featured?: Maybe<Boolean>;
  websiteUrl?: Maybe<String>;
  externalShopifyIntegration?: Maybe<ExternalShopifyIntegrationCreateOneInput>;
}

export interface ProductCreateManyWithoutBrandInput {
  create?: Maybe<
    ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCreateWithoutBrandInput {
  id?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  category: CategoryCreateOneWithoutProductsInput;
  color: ColorCreateOneInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageCreateManyInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryCreateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelCreateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeCreateOneInput>;
  name: String;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonCreateOneInput>;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  slug: String;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagCreateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierCreateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
}

export interface BrandUpdateInput {
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name?: Maybe<String>;
  designer?: Maybe<String>;
  basedIn?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutBrandInput>;
  images?: Maybe<ImageUpdateManyInput>;
  since?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  published?: Maybe<Boolean>;
  featured?: Maybe<Boolean>;
  websiteUrl?: Maybe<String>;
  externalShopifyIntegration?: Maybe<ExternalShopifyIntegrationUpdateOneInput>;
}

export interface ProductUpdateManyWithoutBrandInput {
  create?: Maybe<
    ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    | ProductUpdateWithWhereUniqueWithoutBrandInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    | ProductUpsertWithWhereUniqueWithoutBrandInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutBrandDataInput;
}

export interface ProductUpdateWithoutBrandDataInput {
  architecture?: Maybe<ProductArchitecture>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryUpdateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelUpdateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagUpdateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutBrandDataInput;
  create: ProductCreateWithoutBrandInput;
}

export interface BrandUpdateManyMutationInput {
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name?: Maybe<String>;
  designer?: Maybe<String>;
  basedIn?: Maybe<String>;
  since?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  published?: Maybe<Boolean>;
  featured?: Maybe<Boolean>;
  websiteUrl?: Maybe<String>;
}

export interface CategoryUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductUpdateManyWithoutCategoryInput>;
  children?: Maybe<CategoryUpdateManyWithoutChildrenInput>;
}

export interface CategoryUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
}

export interface CollectionCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  images?: Maybe<ImageCreateManyInput>;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptions?: Maybe<CollectionCreatedescriptionsInput>;
  products?: Maybe<ProductCreateManyInput>;
  published?: Maybe<Boolean>;
  placements?: Maybe<CollectionCreateplacementsInput>;
}

export interface CollectionCreatedescriptionsInput {
  set?: Maybe<String[] | String>;
}

export interface CollectionCreateplacementsInput {
  set?: Maybe<CollectionPlacement[] | CollectionPlacement>;
}

export interface CollectionUpdateInput {
  slug?: Maybe<String>;
  images?: Maybe<ImageUpdateManyInput>;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptions?: Maybe<CollectionUpdatedescriptionsInput>;
  products?: Maybe<ProductUpdateManyInput>;
  published?: Maybe<Boolean>;
  placements?: Maybe<CollectionUpdateplacementsInput>;
}

export interface CollectionUpdatedescriptionsInput {
  set?: Maybe<String[] | String>;
}

export interface CollectionUpdateplacementsInput {
  set?: Maybe<CollectionPlacement[] | CollectionPlacement>;
}

export interface CollectionUpdateManyMutationInput {
  slug?: Maybe<String>;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptions?: Maybe<CollectionUpdatedescriptionsInput>;
  published?: Maybe<Boolean>;
  placements?: Maybe<CollectionUpdateplacementsInput>;
}

export interface ColorUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
  productVariants?: Maybe<ProductVariantUpdateManyWithoutColorInput>;
}

export interface ColorUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipCreateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemCreateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerCreateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerCreateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataCreateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataCreateOneWithoutCustomerInput>;
}

export interface CustomerUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface CustomerUpdateManyMutationInput {
  status?: Maybe<CustomerStatus>;
  plan?: Maybe<Plan>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  authorizedAt?: Maybe<DateTimeInput>;
}

export interface CustomerAdmissionsDataCreateInput {
  id?: Maybe<ID_Input>;
  inServiceableZipcode: Boolean;
  admissable: Boolean;
  inAdmissableReason?: Maybe<InAdmissableReason>;
  allAccessEnabled?: Maybe<Boolean>;
  customer: CustomerCreateOneWithoutAdmissionsInput;
  authorizationsCount: Int;
  authorizationWindowClosesAt?: Maybe<DateTimeInput>;
}

export interface CustomerCreateOneWithoutAdmissionsInput {
  create?: Maybe<CustomerCreateWithoutAdmissionsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutAdmissionsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipCreateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemCreateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerCreateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerCreateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataCreateOneWithoutCustomerInput>;
}

export interface CustomerAdmissionsDataUpdateInput {
  inServiceableZipcode?: Maybe<Boolean>;
  admissable?: Maybe<Boolean>;
  inAdmissableReason?: Maybe<InAdmissableReason>;
  allAccessEnabled?: Maybe<Boolean>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutAdmissionsInput>;
  authorizationsCount?: Maybe<Int>;
  authorizationWindowClosesAt?: Maybe<DateTimeInput>;
}

export interface CustomerUpdateOneRequiredWithoutAdmissionsInput {
  create?: Maybe<CustomerCreateWithoutAdmissionsInput>;
  update?: Maybe<CustomerUpdateWithoutAdmissionsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutAdmissionsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutAdmissionsDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface CustomerUpsertWithoutAdmissionsInput {
  update: CustomerUpdateWithoutAdmissionsDataInput;
  create: CustomerCreateWithoutAdmissionsInput;
}

export interface CustomerAdmissionsDataUpdateManyMutationInput {
  inServiceableZipcode?: Maybe<Boolean>;
  admissable?: Maybe<Boolean>;
  inAdmissableReason?: Maybe<InAdmissableReason>;
  allAccessEnabled?: Maybe<Boolean>;
  authorizationsCount?: Maybe<Int>;
  authorizationWindowClosesAt?: Maybe<DateTimeInput>;
}

export interface CustomerDetailUpdateInput {
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<CustomerDetailUpdateweightInput>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  topSizes?: Maybe<CustomerDetailUpdatetopSizesInput>;
  averageWaistSize?: Maybe<String>;
  waistSizes?: Maybe<CustomerDetailUpdatewaistSizesInput>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  stylePreferences?: Maybe<StylePreferencesUpdateOneInput>;
  shippingAddress?: Maybe<LocationUpdateOneInput>;
  phoneOS?: Maybe<String>;
  insureShipment?: Maybe<Boolean>;
  instagramHandle?: Maybe<String>;
}

export interface CustomerDetailUpdateManyMutationInput {
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<CustomerDetailUpdateweightInput>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  topSizes?: Maybe<CustomerDetailUpdatetopSizesInput>;
  averageWaistSize?: Maybe<String>;
  waistSizes?: Maybe<CustomerDetailUpdatewaistSizesInput>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  phoneOS?: Maybe<String>;
  insureShipment?: Maybe<Boolean>;
  instagramHandle?: Maybe<String>;
}

export interface CustomerMembershipCreateInput {
  id?: Maybe<ID_Input>;
  plan?: Maybe<PaymentPlanCreateOneInput>;
  subscriptionId: String;
  customer: CustomerCreateOneWithoutMembershipInput;
  pauseRequests?: Maybe<PauseRequestCreateManyWithoutMembershipInput>;
  giftId?: Maybe<String>;
}

export interface CustomerCreateOneWithoutMembershipInput {
  create?: Maybe<CustomerCreateWithoutMembershipInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutMembershipInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  bagItems?: Maybe<BagItemCreateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerCreateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerCreateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataCreateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataCreateOneWithoutCustomerInput>;
}

export interface CustomerMembershipUpdateInput {
  plan?: Maybe<PaymentPlanUpdateOneInput>;
  subscriptionId?: Maybe<String>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutMembershipInput>;
  pauseRequests?: Maybe<PauseRequestUpdateManyWithoutMembershipInput>;
  giftId?: Maybe<String>;
}

export interface CustomerUpdateOneRequiredWithoutMembershipInput {
  create?: Maybe<CustomerCreateWithoutMembershipInput>;
  update?: Maybe<CustomerUpdateWithoutMembershipDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutMembershipInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutMembershipDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface CustomerUpsertWithoutMembershipInput {
  update: CustomerUpdateWithoutMembershipDataInput;
  create: CustomerCreateWithoutMembershipInput;
}

export interface CustomerMembershipUpdateManyMutationInput {
  subscriptionId?: Maybe<String>;
  giftId?: Maybe<String>;
}

export interface EmailReceiptCreateInput {
  id?: Maybe<ID_Input>;
  emailId: EmailId;
  user: UserCreateOneWithoutEmailsInput;
}

export interface UserCreateOneWithoutEmailsInput {
  create?: Maybe<UserCreateWithoutEmailsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEmailsInput {
  id?: Maybe<ID_Input>;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserCreaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotifications?: Maybe<PushNotificationReceiptCreateManyWithoutUsersInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationCreateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptCreateManyInput>;
  fitPics?: Maybe<FitPicCreateManyWithoutUserInput>;
}

export interface EmailReceiptUpdateInput {
  emailId?: Maybe<EmailId>;
  user?: Maybe<UserUpdateOneRequiredWithoutEmailsInput>;
}

export interface UserUpdateOneRequiredWithoutEmailsInput {
  create?: Maybe<UserCreateWithoutEmailsInput>;
  update?: Maybe<UserUpdateWithoutEmailsDataInput>;
  upsert?: Maybe<UserUpsertWithoutEmailsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEmailsDataInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserUpdaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotifications?: Maybe<PushNotificationReceiptUpdateManyWithoutUsersInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationUpdateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptUpdateManyInput>;
  fitPics?: Maybe<FitPicUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutEmailsInput {
  update: UserUpdateWithoutEmailsDataInput;
  create: UserCreateWithoutEmailsInput;
}

export interface EmailReceiptUpdateManyMutationInput {
  emailId?: Maybe<EmailId>;
}

export interface ExternalShopifyIntegrationUpdateInput {
  shopName?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  accessToken?: Maybe<String>;
  nonce?: Maybe<String>;
}

export interface ExternalShopifyIntegrationUpdateManyMutationInput {
  shopName?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  accessToken?: Maybe<String>;
  nonce?: Maybe<String>;
}

export interface FitPicCreateInput {
  id?: Maybe<ID_Input>;
  image: ImageCreateOneInput;
  includeInstagramHandle?: Maybe<Boolean>;
  location?: Maybe<LocationCreateOneInput>;
  products?: Maybe<ProductCreateManyInput>;
  reports?: Maybe<FitPicReportCreateManyWithoutReportedInput>;
  status?: Maybe<FitPicStatus>;
  user: UserCreateOneWithoutFitPicsInput;
}

export interface UserCreateOneWithoutFitPicsInput {
  create?: Maybe<UserCreateWithoutFitPicsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutFitPicsInput {
  id?: Maybe<ID_Input>;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserCreaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotifications?: Maybe<PushNotificationReceiptCreateManyWithoutUsersInput>;
  emails?: Maybe<EmailReceiptCreateManyWithoutUserInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationCreateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptCreateManyInput>;
}

export interface FitPicUpdateInput {
  image?: Maybe<ImageUpdateOneRequiredInput>;
  includeInstagramHandle?: Maybe<Boolean>;
  location?: Maybe<LocationUpdateOneInput>;
  products?: Maybe<ProductUpdateManyInput>;
  reports?: Maybe<FitPicReportUpdateManyWithoutReportedInput>;
  status?: Maybe<FitPicStatus>;
  user?: Maybe<UserUpdateOneRequiredWithoutFitPicsInput>;
}

export interface UserUpdateOneRequiredWithoutFitPicsInput {
  create?: Maybe<UserCreateWithoutFitPicsInput>;
  update?: Maybe<UserUpdateWithoutFitPicsDataInput>;
  upsert?: Maybe<UserUpsertWithoutFitPicsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutFitPicsDataInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserUpdaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotifications?: Maybe<PushNotificationReceiptUpdateManyWithoutUsersInput>;
  emails?: Maybe<EmailReceiptUpdateManyWithoutUserInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationUpdateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptUpdateManyInput>;
}

export interface UserUpsertWithoutFitPicsInput {
  update: UserUpdateWithoutFitPicsDataInput;
  create: UserCreateWithoutFitPicsInput;
}

export interface FitPicUpdateManyMutationInput {
  includeInstagramHandle?: Maybe<Boolean>;
  status?: Maybe<FitPicStatus>;
}

export interface FitPicReportCreateInput {
  id?: Maybe<ID_Input>;
  reporter: UserCreateOneInput;
  reported: FitPicCreateOneWithoutReportsInput;
  status?: Maybe<FitPicReportStatus>;
}

export interface FitPicCreateOneWithoutReportsInput {
  create?: Maybe<FitPicCreateWithoutReportsInput>;
  connect?: Maybe<FitPicWhereUniqueInput>;
}

export interface FitPicCreateWithoutReportsInput {
  id?: Maybe<ID_Input>;
  image: ImageCreateOneInput;
  includeInstagramHandle?: Maybe<Boolean>;
  location?: Maybe<LocationCreateOneInput>;
  products?: Maybe<ProductCreateManyInput>;
  status?: Maybe<FitPicStatus>;
  user: UserCreateOneWithoutFitPicsInput;
}

export interface FitPicReportUpdateInput {
  reporter?: Maybe<UserUpdateOneRequiredInput>;
  reported?: Maybe<FitPicUpdateOneRequiredWithoutReportsInput>;
  status?: Maybe<FitPicReportStatus>;
}

export interface FitPicUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<FitPicCreateWithoutReportsInput>;
  update?: Maybe<FitPicUpdateWithoutReportsDataInput>;
  upsert?: Maybe<FitPicUpsertWithoutReportsInput>;
  connect?: Maybe<FitPicWhereUniqueInput>;
}

export interface FitPicUpdateWithoutReportsDataInput {
  image?: Maybe<ImageUpdateOneRequiredInput>;
  includeInstagramHandle?: Maybe<Boolean>;
  location?: Maybe<LocationUpdateOneInput>;
  products?: Maybe<ProductUpdateManyInput>;
  status?: Maybe<FitPicStatus>;
  user?: Maybe<UserUpdateOneRequiredWithoutFitPicsInput>;
}

export interface FitPicUpsertWithoutReportsInput {
  update: FitPicUpdateWithoutReportsDataInput;
  create: FitPicCreateWithoutReportsInput;
}

export interface FitPicReportUpdateManyMutationInput {
  status?: Maybe<FitPicReportStatus>;
}

export interface ImageUpdateInput {
  caption?: Maybe<String>;
  url?: Maybe<String>;
  height?: Maybe<Int>;
  width?: Maybe<Int>;
  title?: Maybe<String>;
}

export interface ImageUpdateManyMutationInput {
  caption?: Maybe<String>;
  url?: Maybe<String>;
  height?: Maybe<Int>;
  width?: Maybe<Int>;
  title?: Maybe<String>;
}

export interface InterestedUserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  zipcode?: Maybe<String>;
}

export interface InterestedUserUpdateInput {
  email?: Maybe<String>;
  zipcode?: Maybe<String>;
}

export interface InterestedUserUpdateManyMutationInput {
  email?: Maybe<String>;
  zipcode?: Maybe<String>;
}

export interface LabelUpdateInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export interface LabelUpdateManyMutationInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export interface LocationUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserUpdateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutLocationInput>;
  shippingOptions?: Maybe<ShippingOptionUpdateManyWithoutDestinationInput>;
}

export interface LocationUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  country?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
}

export interface PackageUpdateInput {
  items?: Maybe<PhysicalProductUpdateManyInput>;
  transactionID?: Maybe<String>;
  shippingLabel?: Maybe<LabelUpdateOneRequiredInput>;
  fromAddress?: Maybe<LocationUpdateOneRequiredInput>;
  toAddress?: Maybe<LocationUpdateOneRequiredInput>;
  weight?: Maybe<Float>;
  cost?: Maybe<Int>;
  events?: Maybe<PackageTransitEventUpdateManyWithoutPackageInput>;
}

export interface PackageUpdateManyMutationInput {
  transactionID?: Maybe<String>;
  weight?: Maybe<Float>;
  cost?: Maybe<Int>;
}

export interface PackageTransitEventCreateInput {
  id?: Maybe<ID_Input>;
  status: PackageTransitEventStatus;
  subStatus: PackageTransitEventSubStatus;
  package: PackageCreateOneWithoutEventsInput;
  reservation?: Maybe<ReservationCreateOneWithoutPackageEventsInput>;
  data: Json;
}

export interface PackageTransitEventUpdateInput {
  status?: Maybe<PackageTransitEventStatus>;
  subStatus?: Maybe<PackageTransitEventSubStatus>;
  package?: Maybe<PackageUpdateOneRequiredWithoutEventsInput>;
  reservation?: Maybe<ReservationUpdateOneWithoutPackageEventsInput>;
  data?: Maybe<Json>;
}

export interface PackageTransitEventUpdateManyMutationInput {
  status?: Maybe<PackageTransitEventStatus>;
  subStatus?: Maybe<PackageTransitEventSubStatus>;
  data?: Maybe<Json>;
}

export interface PauseRequestCreateInput {
  id?: Maybe<ID_Input>;
  pausePending: Boolean;
  pauseDate?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
  membership: CustomerMembershipCreateOneWithoutPauseRequestsInput;
}

export interface CustomerMembershipCreateOneWithoutPauseRequestsInput {
  create?: Maybe<CustomerMembershipCreateWithoutPauseRequestsInput>;
  connect?: Maybe<CustomerMembershipWhereUniqueInput>;
}

export interface CustomerMembershipCreateWithoutPauseRequestsInput {
  id?: Maybe<ID_Input>;
  plan?: Maybe<PaymentPlanCreateOneInput>;
  subscriptionId: String;
  customer: CustomerCreateOneWithoutMembershipInput;
  giftId?: Maybe<String>;
}

export interface PauseRequestUpdateInput {
  pausePending?: Maybe<Boolean>;
  pauseDate?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
  membership?: Maybe<
    CustomerMembershipUpdateOneRequiredWithoutPauseRequestsInput
  >;
}

export interface CustomerMembershipUpdateOneRequiredWithoutPauseRequestsInput {
  create?: Maybe<CustomerMembershipCreateWithoutPauseRequestsInput>;
  update?: Maybe<CustomerMembershipUpdateWithoutPauseRequestsDataInput>;
  upsert?: Maybe<CustomerMembershipUpsertWithoutPauseRequestsInput>;
  connect?: Maybe<CustomerMembershipWhereUniqueInput>;
}

export interface CustomerMembershipUpdateWithoutPauseRequestsDataInput {
  plan?: Maybe<PaymentPlanUpdateOneInput>;
  subscriptionId?: Maybe<String>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutMembershipInput>;
  giftId?: Maybe<String>;
}

export interface CustomerMembershipUpsertWithoutPauseRequestsInput {
  update: CustomerMembershipUpdateWithoutPauseRequestsDataInput;
  create: CustomerMembershipCreateWithoutPauseRequestsInput;
}

export interface PauseRequestUpdateManyMutationInput {
  pausePending?: Maybe<Boolean>;
  pauseDate?: Maybe<DateTimeInput>;
  resumeDate?: Maybe<DateTimeInput>;
  notified?: Maybe<Boolean>;
}

export interface PaymentPlanUpdateInput {
  description?: Maybe<String>;
  planID?: Maybe<String>;
  status?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  itemCount?: Maybe<Int>;
  tagline?: Maybe<String>;
  tier?: Maybe<PaymentPlanTier>;
}

export interface PaymentPlanUpdateManyMutationInput {
  description?: Maybe<String>;
  planID?: Maybe<String>;
  status?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  itemCount?: Maybe<Int>;
  tagline?: Maybe<String>;
  tier?: Maybe<PaymentPlanTier>;
}

export interface PhysicalProductUpdateInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneWithoutPhysicalProductsInput>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  warehouseLocation?: Maybe<
    WarehouseLocationUpdateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceUpdateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportUpdateManyWithoutPhysicalProductInput
  >;
}

export interface PhysicalProductUpdateManyMutationInput {
  seasonsUID?: Maybe<String>;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
}

export interface PhysicalProductPriceUpdateInput {
  buyUsedEnabled?: Maybe<Boolean>;
  buyUsedPrice?: Maybe<Float>;
}

export interface PhysicalProductPriceUpdateManyMutationInput {
  buyUsedEnabled?: Maybe<Boolean>;
  buyUsedPrice?: Maybe<Float>;
}

export interface PhysicalProductQualityReportCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  damageType?: Maybe<PhysicalProductDamageType>;
  notes?: Maybe<String>;
  physicalProduct: PhysicalProductCreateOneWithoutReportsInput;
}

export interface PhysicalProductCreateOneWithoutReportsInput {
  create?: Maybe<PhysicalProductCreateWithoutReportsInput>;
  connect?: Maybe<PhysicalProductWhereUniqueInput>;
}

export interface PhysicalProductCreateWithoutReportsInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  location?: Maybe<LocationCreateOneWithoutPhysicalProductsInput>;
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber: Int;
  warehouseLocation?: Maybe<
    WarehouseLocationCreateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceCreateOneInput>;
}

export interface PhysicalProductQualityReportUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  damageType?: Maybe<PhysicalProductDamageType>;
  notes?: Maybe<String>;
  physicalProduct?: Maybe<PhysicalProductUpdateOneRequiredWithoutReportsInput>;
}

export interface PhysicalProductUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<PhysicalProductCreateWithoutReportsInput>;
  update?: Maybe<PhysicalProductUpdateWithoutReportsDataInput>;
  upsert?: Maybe<PhysicalProductUpsertWithoutReportsInput>;
  connect?: Maybe<PhysicalProductWhereUniqueInput>;
}

export interface PhysicalProductUpdateWithoutReportsDataInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneWithoutPhysicalProductsInput>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  warehouseLocation?: Maybe<
    WarehouseLocationUpdateOneWithoutPhysicalProductsInput
  >;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceUpdateOneInput>;
}

export interface PhysicalProductUpsertWithoutReportsInput {
  update: PhysicalProductUpdateWithoutReportsDataInput;
  create: PhysicalProductCreateWithoutReportsInput;
}

export interface PhysicalProductQualityReportUpdateManyMutationInput {
  damageType?: Maybe<PhysicalProductDamageType>;
  notes?: Maybe<String>;
}

export interface ProductUpdateInput {
  architecture?: Maybe<ProductArchitecture>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryUpdateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelUpdateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagUpdateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
}

export interface ProductUpdateManyMutationInput {
  architecture?: Maybe<ProductArchitecture>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  buyNewEnabled?: Maybe<Boolean>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  modelHeight?: Maybe<Int>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  type?: Maybe<ProductType>;
}

export interface ProductFunctionUpdateInput {
  name?: Maybe<String>;
}

export interface ProductFunctionUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ProductMaterialCategoryCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  lifeExpectancy: Float;
  category: CategoryCreateOneInput;
  products?: Maybe<ProductCreateManyWithoutMaterialCategoryInput>;
}

export interface ProductCreateManyWithoutMaterialCategoryInput {
  create?: Maybe<
    | ProductCreateWithoutMaterialCategoryInput[]
    | ProductCreateWithoutMaterialCategoryInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCreateWithoutMaterialCategoryInput {
  id?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  brand: BrandCreateOneWithoutProductsInput;
  category: CategoryCreateOneWithoutProductsInput;
  color: ColorCreateOneInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageCreateManyInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  model?: Maybe<ProductModelCreateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeCreateOneInput>;
  name: String;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonCreateOneInput>;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  slug: String;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagCreateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierCreateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
}

export interface ProductMaterialCategoryUpdateInput {
  slug?: Maybe<String>;
  lifeExpectancy?: Maybe<Float>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  products?: Maybe<ProductUpdateManyWithoutMaterialCategoryInput>;
}

export interface ProductUpdateManyWithoutMaterialCategoryInput {
  create?: Maybe<
    | ProductCreateWithoutMaterialCategoryInput[]
    | ProductCreateWithoutMaterialCategoryInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutMaterialCategoryInput[]
    | ProductUpdateWithWhereUniqueWithoutMaterialCategoryInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutMaterialCategoryInput[]
    | ProductUpsertWithWhereUniqueWithoutMaterialCategoryInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutMaterialCategoryInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutMaterialCategoryDataInput;
}

export interface ProductUpdateWithoutMaterialCategoryDataInput {
  architecture?: Maybe<ProductArchitecture>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  model?: Maybe<ProductModelUpdateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagUpdateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutMaterialCategoryInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutMaterialCategoryDataInput;
  create: ProductCreateWithoutMaterialCategoryInput;
}

export interface ProductMaterialCategoryUpdateManyMutationInput {
  slug?: Maybe<String>;
  lifeExpectancy?: Maybe<Float>;
}

export interface ProductModelCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  height: Float;
  products?: Maybe<ProductCreateManyWithoutModelInput>;
}

export interface ProductCreateManyWithoutModelInput {
  create?: Maybe<
    ProductCreateWithoutModelInput[] | ProductCreateWithoutModelInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCreateWithoutModelInput {
  id?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  brand: BrandCreateOneWithoutProductsInput;
  category: CategoryCreateOneWithoutProductsInput;
  color: ColorCreateOneInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageCreateManyInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryCreateOneWithoutProductsInput
  >;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeCreateOneInput>;
  name: String;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonCreateOneInput>;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  slug: String;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagCreateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierCreateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
}

export interface ProductModelUpdateInput {
  name?: Maybe<String>;
  height?: Maybe<Float>;
  products?: Maybe<ProductUpdateManyWithoutModelInput>;
}

export interface ProductUpdateManyWithoutModelInput {
  create?: Maybe<
    ProductCreateWithoutModelInput[] | ProductCreateWithoutModelInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutModelInput[]
    | ProductUpdateWithWhereUniqueWithoutModelInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutModelInput[]
    | ProductUpsertWithWhereUniqueWithoutModelInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutModelInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutModelDataInput;
}

export interface ProductUpdateWithoutModelDataInput {
  architecture?: Maybe<ProductArchitecture>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryUpdateOneWithoutProductsInput
  >;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tags?: Maybe<TagUpdateManyWithoutProductsInput>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutModelInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutModelDataInput;
  create: ProductCreateWithoutModelInput;
}

export interface ProductModelUpdateManyMutationInput {
  name?: Maybe<String>;
  height?: Maybe<Float>;
}

export interface ProductNotificationCreateInput {
  id?: Maybe<ID_Input>;
  type: ProductNotificationType;
  customer: CustomerCreateOneInput;
  physicalProduct?: Maybe<PhysicalProductCreateOneInput>;
  productVariant?: Maybe<ProductVariantCreateOneInput>;
  shouldNotify?: Maybe<Boolean>;
}

export interface CustomerCreateOneInput {
  create?: Maybe<CustomerCreateInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface ProductNotificationUpdateInput {
  type?: Maybe<ProductNotificationType>;
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  physicalProduct?: Maybe<PhysicalProductUpdateOneInput>;
  productVariant?: Maybe<ProductVariantUpdateOneInput>;
  shouldNotify?: Maybe<Boolean>;
}

export interface CustomerUpdateOneRequiredInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
  utm?: Maybe<UTMDataUpdateOneWithoutCustomerInput>;
}

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface PhysicalProductUpdateOneInput {
  create?: Maybe<PhysicalProductCreateInput>;
  update?: Maybe<PhysicalProductUpdateDataInput>;
  upsert?: Maybe<PhysicalProductUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PhysicalProductWhereUniqueInput>;
}

export interface ProductVariantUpdateOneInput {
  create?: Maybe<ProductVariantCreateInput>;
  update?: Maybe<ProductVariantUpdateDataInput>;
  upsert?: Maybe<ProductVariantUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface ProductNotificationUpdateManyMutationInput {
  type?: Maybe<ProductNotificationType>;
  shouldNotify?: Maybe<Boolean>;
}

export interface ProductRequestCreateInput {
  id?: Maybe<ID_Input>;
  brand?: Maybe<String>;
  description?: Maybe<String>;
  images?: Maybe<ProductRequestCreateimagesInput>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  productID?: Maybe<String>;
  reason: String;
  sku?: Maybe<String>;
  url: String;
  user: UserCreateOneInput;
}

export interface ProductRequestCreateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface ProductRequestUpdateInput {
  brand?: Maybe<String>;
  description?: Maybe<String>;
  images?: Maybe<ProductRequestUpdateimagesInput>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  productID?: Maybe<String>;
  reason?: Maybe<String>;
  sku?: Maybe<String>;
  url?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ProductRequestUpdateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface ProductRequestUpdateManyMutationInput {
  brand?: Maybe<String>;
  description?: Maybe<String>;
  images?: Maybe<ProductRequestUpdateimagesInput>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  productID?: Maybe<String>;
  reason?: Maybe<String>;
  sku?: Maybe<String>;
  url?: Maybe<String>;
}

export interface ProductSeasonUpdateInput {
  vendorSeason?: Maybe<SeasonUpdateOneInput>;
  internalSeason?: Maybe<SeasonUpdateOneInput>;
  wearableSeasons?: Maybe<ProductSeasonUpdatewearableSeasonsInput>;
}

export interface ProductSeasonUpdateManyMutationInput {
  wearableSeasons?: Maybe<ProductSeasonUpdatewearableSeasonsInput>;
}

export interface ProductTierUpdateInput {
  tier?: Maybe<ProductTierName>;
  price?: Maybe<Int>;
}

export interface ProductTierUpdateManyMutationInput {
  tier?: Maybe<ProductTierName>;
  price?: Maybe<Int>;
}

export interface ProductVariantUpdateInput {
  sku?: Maybe<String>;
  displayShort?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  internalSize?: Maybe<SizeUpdateOneInput>;
  manufacturerSizes?: Maybe<SizeUpdateManyInput>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  price?: Maybe<ProductVariantPriceUpdateOneInput>;
  shopifyProductVariant?: Maybe<ShopifyProductVariantUpdateOneInput>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  stored?: Maybe<Int>;
}

export interface ProductVariantUpdateManyMutationInput {
  sku?: Maybe<String>;
  displayShort?: Maybe<String>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  offloaded?: Maybe<Int>;
  stored?: Maybe<Int>;
}

export interface ProductVariantFeedbackCreateInput {
  id?: Maybe<ID_Input>;
  isCompleted: Boolean;
  questions?: Maybe<
    ProductVariantFeedbackQuestionCreateManyWithoutVariantFeedbackInput
  >;
  reservationFeedback: ReservationFeedbackCreateOneWithoutFeedbacksInput;
  variant: ProductVariantCreateOneInput;
}

export interface ProductVariantFeedbackQuestionCreateManyWithoutVariantFeedbackInput {
  create?: Maybe<
    | ProductVariantFeedbackQuestionCreateWithoutVariantFeedbackInput[]
    | ProductVariantFeedbackQuestionCreateWithoutVariantFeedbackInput
  >;
  connect?: Maybe<
    | ProductVariantFeedbackQuestionWhereUniqueInput[]
    | ProductVariantFeedbackQuestionWhereUniqueInput
  >;
}

export interface ProductVariantFeedbackQuestionCreateWithoutVariantFeedbackInput {
  id?: Maybe<ID_Input>;
  options?: Maybe<ProductVariantFeedbackQuestionCreateoptionsInput>;
  question: String;
  responses?: Maybe<ProductVariantFeedbackQuestionCreateresponsesInput>;
  type: QuestionType;
}

export interface ProductVariantFeedbackQuestionCreateoptionsInput {
  set?: Maybe<String[] | String>;
}

export interface ProductVariantFeedbackQuestionCreateresponsesInput {
  set?: Maybe<String[] | String>;
}

export interface ReservationFeedbackCreateOneWithoutFeedbacksInput {
  create?: Maybe<ReservationFeedbackCreateWithoutFeedbacksInput>;
  connect?: Maybe<ReservationFeedbackWhereUniqueInput>;
}

export interface ReservationFeedbackCreateWithoutFeedbacksInput {
  id?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  rating?: Maybe<Rating>;
  user: UserCreateOneInput;
  reservation: ReservationCreateOneInput;
  respondedAt?: Maybe<DateTimeInput>;
}

export interface ReservationCreateOneInput {
  create?: Maybe<ReservationCreateInput>;
  connect?: Maybe<ReservationWhereUniqueInput>;
}

export interface ReservationCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  customer: CustomerCreateOneWithoutReservationsInput;
  sentPackage?: Maybe<PackageCreateOneInput>;
  returnedPackage?: Maybe<PackageCreateOneInput>;
  products?: Maybe<PhysicalProductCreateManyInput>;
  packageEvents?: Maybe<PackageTransitEventCreateManyWithoutReservationInput>;
  reservationNumber: Int;
  phase: ReservationPhase;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptCreateOneWithoutReservationInput>;
  lastLocation?: Maybe<LocationCreateOneInput>;
  shippingOption?: Maybe<ShippingOptionCreateOneInput>;
}

export interface ProductVariantFeedbackUpdateInput {
  isCompleted?: Maybe<Boolean>;
  questions?: Maybe<
    ProductVariantFeedbackQuestionUpdateManyWithoutVariantFeedbackInput
  >;
  reservationFeedback?: Maybe<
    ReservationFeedbackUpdateOneRequiredWithoutFeedbacksInput
  >;
  variant?: Maybe<ProductVariantUpdateOneRequiredInput>;
}

export interface ProductVariantFeedbackQuestionUpdateManyWithoutVariantFeedbackInput {
  create?: Maybe<
    | ProductVariantFeedbackQuestionCreateWithoutVariantFeedbackInput[]
    | ProductVariantFeedbackQuestionCreateWithoutVariantFeedbackInput
  >;
  delete?: Maybe<
    | ProductVariantFeedbackQuestionWhereUniqueInput[]
    | ProductVariantFeedbackQuestionWhereUniqueInput
  >;
  connect?: Maybe<
    | ProductVariantFeedbackQuestionWhereUniqueInput[]
    | ProductVariantFeedbackQuestionWhereUniqueInput
  >;
  set?: Maybe<
    | ProductVariantFeedbackQuestionWhereUniqueInput[]
    | ProductVariantFeedbackQuestionWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ProductVariantFeedbackQuestionWhereUniqueInput[]
    | ProductVariantFeedbackQuestionWhereUniqueInput
  >;
  update?: Maybe<
    | ProductVariantFeedbackQuestionUpdateWithWhereUniqueWithoutVariantFeedbackInput[]
    | ProductVariantFeedbackQuestionUpdateWithWhereUniqueWithoutVariantFeedbackInput
  >;
  upsert?: Maybe<
    | ProductVariantFeedbackQuestionUpsertWithWhereUniqueWithoutVariantFeedbackInput[]
    | ProductVariantFeedbackQuestionUpsertWithWhereUniqueWithoutVariantFeedbackInput
  >;
  deleteMany?: Maybe<
    | ProductVariantFeedbackQuestionScalarWhereInput[]
    | ProductVariantFeedbackQuestionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductVariantFeedbackQuestionUpdateManyWithWhereNestedInput[]
    | ProductVariantFeedbackQuestionUpdateManyWithWhereNestedInput
  >;
}

export interface ProductVariantFeedbackQuestionUpdateWithWhereUniqueWithoutVariantFeedbackInput {
  where: ProductVariantFeedbackQuestionWhereUniqueInput;
  data: ProductVariantFeedbackQuestionUpdateWithoutVariantFeedbackDataInput;
}

export interface ProductVariantFeedbackQuestionUpdateWithoutVariantFeedbackDataInput {
  options?: Maybe<ProductVariantFeedbackQuestionUpdateoptionsInput>;
  question?: Maybe<String>;
  responses?: Maybe<ProductVariantFeedbackQuestionUpdateresponsesInput>;
  type?: Maybe<QuestionType>;
}

export interface ProductVariantFeedbackQuestionUpdateoptionsInput {
  set?: Maybe<String[] | String>;
}

export interface ProductVariantFeedbackQuestionUpdateresponsesInput {
  set?: Maybe<String[] | String>;
}

export interface ProductVariantFeedbackQuestionUpsertWithWhereUniqueWithoutVariantFeedbackInput {
  where: ProductVariantFeedbackQuestionWhereUniqueInput;
  update: ProductVariantFeedbackQuestionUpdateWithoutVariantFeedbackDataInput;
  create: ProductVariantFeedbackQuestionCreateWithoutVariantFeedbackInput;
}

export interface ProductVariantFeedbackQuestionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  question?: Maybe<String>;
  question_not?: Maybe<String>;
  question_in?: Maybe<String[] | String>;
  question_not_in?: Maybe<String[] | String>;
  question_lt?: Maybe<String>;
  question_lte?: Maybe<String>;
  question_gt?: Maybe<String>;
  question_gte?: Maybe<String>;
  question_contains?: Maybe<String>;
  question_not_contains?: Maybe<String>;
  question_starts_with?: Maybe<String>;
  question_not_starts_with?: Maybe<String>;
  question_ends_with?: Maybe<String>;
  question_not_ends_with?: Maybe<String>;
  type?: Maybe<QuestionType>;
  type_not?: Maybe<QuestionType>;
  type_in?: Maybe<QuestionType[] | QuestionType>;
  type_not_in?: Maybe<QuestionType[] | QuestionType>;
  AND?: Maybe<
    | ProductVariantFeedbackQuestionScalarWhereInput[]
    | ProductVariantFeedbackQuestionScalarWhereInput
  >;
  OR?: Maybe<
    | ProductVariantFeedbackQuestionScalarWhereInput[]
    | ProductVariantFeedbackQuestionScalarWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantFeedbackQuestionScalarWhereInput[]
    | ProductVariantFeedbackQuestionScalarWhereInput
  >;
}

export interface ProductVariantFeedbackQuestionUpdateManyWithWhereNestedInput {
  where: ProductVariantFeedbackQuestionScalarWhereInput;
  data: ProductVariantFeedbackQuestionUpdateManyDataInput;
}

export interface ProductVariantFeedbackQuestionUpdateManyDataInput {
  options?: Maybe<ProductVariantFeedbackQuestionUpdateoptionsInput>;
  question?: Maybe<String>;
  responses?: Maybe<ProductVariantFeedbackQuestionUpdateresponsesInput>;
  type?: Maybe<QuestionType>;
}

export interface ReservationFeedbackUpdateOneRequiredWithoutFeedbacksInput {
  create?: Maybe<ReservationFeedbackCreateWithoutFeedbacksInput>;
  update?: Maybe<ReservationFeedbackUpdateWithoutFeedbacksDataInput>;
  upsert?: Maybe<ReservationFeedbackUpsertWithoutFeedbacksInput>;
  connect?: Maybe<ReservationFeedbackWhereUniqueInput>;
}

export interface ReservationFeedbackUpdateWithoutFeedbacksDataInput {
  comment?: Maybe<String>;
  rating?: Maybe<Rating>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  reservation?: Maybe<ReservationUpdateOneRequiredInput>;
  respondedAt?: Maybe<DateTimeInput>;
}

export interface ReservationUpdateOneRequiredInput {
  create?: Maybe<ReservationCreateInput>;
  update?: Maybe<ReservationUpdateDataInput>;
  upsert?: Maybe<ReservationUpsertNestedInput>;
  connect?: Maybe<ReservationWhereUniqueInput>;
}

export interface ReservationUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutReservationsInput>;
  sentPackage?: Maybe<PackageUpdateOneInput>;
  returnedPackage?: Maybe<PackageUpdateOneInput>;
  products?: Maybe<PhysicalProductUpdateManyInput>;
  packageEvents?: Maybe<PackageTransitEventUpdateManyWithoutReservationInput>;
  reservationNumber?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptUpdateOneWithoutReservationInput>;
  lastLocation?: Maybe<LocationUpdateOneInput>;
  shippingOption?: Maybe<ShippingOptionUpdateOneInput>;
}

export interface ReservationUpsertNestedInput {
  update: ReservationUpdateDataInput;
  create: ReservationCreateInput;
}

export interface ReservationFeedbackUpsertWithoutFeedbacksInput {
  update: ReservationFeedbackUpdateWithoutFeedbacksDataInput;
  create: ReservationFeedbackCreateWithoutFeedbacksInput;
}

export interface ProductVariantFeedbackUpdateManyMutationInput {
  isCompleted?: Maybe<Boolean>;
}

export interface ProductVariantFeedbackQuestionCreateInput {
  id?: Maybe<ID_Input>;
  options?: Maybe<ProductVariantFeedbackQuestionCreateoptionsInput>;
  question: String;
  responses?: Maybe<ProductVariantFeedbackQuestionCreateresponsesInput>;
  type: QuestionType;
  variantFeedback: ProductVariantFeedbackCreateOneWithoutQuestionsInput;
}

export interface ProductVariantFeedbackCreateOneWithoutQuestionsInput {
  create?: Maybe<ProductVariantFeedbackCreateWithoutQuestionsInput>;
  connect?: Maybe<ProductVariantFeedbackWhereUniqueInput>;
}

export interface ProductVariantFeedbackCreateWithoutQuestionsInput {
  id?: Maybe<ID_Input>;
  isCompleted: Boolean;
  reservationFeedback: ReservationFeedbackCreateOneWithoutFeedbacksInput;
  variant: ProductVariantCreateOneInput;
}

export interface ProductVariantFeedbackQuestionUpdateInput {
  options?: Maybe<ProductVariantFeedbackQuestionUpdateoptionsInput>;
  question?: Maybe<String>;
  responses?: Maybe<ProductVariantFeedbackQuestionUpdateresponsesInput>;
  type?: Maybe<QuestionType>;
  variantFeedback?: Maybe<
    ProductVariantFeedbackUpdateOneRequiredWithoutQuestionsInput
  >;
}

export interface ProductVariantFeedbackUpdateOneRequiredWithoutQuestionsInput {
  create?: Maybe<ProductVariantFeedbackCreateWithoutQuestionsInput>;
  update?: Maybe<ProductVariantFeedbackUpdateWithoutQuestionsDataInput>;
  upsert?: Maybe<ProductVariantFeedbackUpsertWithoutQuestionsInput>;
  connect?: Maybe<ProductVariantFeedbackWhereUniqueInput>;
}

export interface ProductVariantFeedbackUpdateWithoutQuestionsDataInput {
  isCompleted?: Maybe<Boolean>;
  reservationFeedback?: Maybe<
    ReservationFeedbackUpdateOneRequiredWithoutFeedbacksInput
  >;
  variant?: Maybe<ProductVariantUpdateOneRequiredInput>;
}

export interface ProductVariantFeedbackUpsertWithoutQuestionsInput {
  update: ProductVariantFeedbackUpdateWithoutQuestionsDataInput;
  create: ProductVariantFeedbackCreateWithoutQuestionsInput;
}

export interface ProductVariantFeedbackQuestionUpdateManyMutationInput {
  options?: Maybe<ProductVariantFeedbackQuestionUpdateoptionsInput>;
  question?: Maybe<String>;
  responses?: Maybe<ProductVariantFeedbackQuestionUpdateresponsesInput>;
  type?: Maybe<QuestionType>;
}

export interface ProductVariantPriceUpdateInput {
  retailPrice?: Maybe<Float>;
}

export interface ProductVariantPriceUpdateManyMutationInput {
  retailPrice?: Maybe<Float>;
}

export interface ProductVariantWantCreateInput {
  id?: Maybe<ID_Input>;
  productVariant: ProductVariantCreateOneInput;
  user: UserCreateOneInput;
  isFulfilled: Boolean;
}

export interface ProductVariantWantUpdateInput {
  productVariant?: Maybe<ProductVariantUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface ProductVariantWantUpdateManyMutationInput {
  isFulfilled?: Maybe<Boolean>;
}

export interface PushNotificationReceiptUpdateInput {
  route?: Maybe<String>;
  screen?: Maybe<String>;
  uri?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutPushNotificationsInput>;
  interest?: Maybe<String>;
  body?: Maybe<String>;
  title?: Maybe<String>;
  recordID?: Maybe<String>;
  recordSlug?: Maybe<String>;
  notificationKey?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
}

export interface PushNotificationReceiptUpdateManyMutationInput {
  route?: Maybe<String>;
  screen?: Maybe<String>;
  uri?: Maybe<String>;
  interest?: Maybe<String>;
  body?: Maybe<String>;
  title?: Maybe<String>;
  recordID?: Maybe<String>;
  recordSlug?: Maybe<String>;
  notificationKey?: Maybe<String>;
  sentAt?: Maybe<DateTimeInput>;
}

export interface RecentlyViewedProductCreateInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneInput;
  customer: CustomerCreateOneInput;
  viewCount?: Maybe<Int>;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface RecentlyViewedProductUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  viewCount?: Maybe<Int>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface RecentlyViewedProductUpdateManyMutationInput {
  viewCount?: Maybe<Int>;
}

export interface ReservationUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutReservationsInput>;
  sentPackage?: Maybe<PackageUpdateOneInput>;
  returnedPackage?: Maybe<PackageUpdateOneInput>;
  products?: Maybe<PhysicalProductUpdateManyInput>;
  packageEvents?: Maybe<PackageTransitEventUpdateManyWithoutReservationInput>;
  reservationNumber?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  receipt?: Maybe<ReservationReceiptUpdateOneWithoutReservationInput>;
  lastLocation?: Maybe<LocationUpdateOneInput>;
  shippingOption?: Maybe<ShippingOptionUpdateOneInput>;
}

export interface ReservationUpdateManyMutationInput {
  reservationNumber?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
}

export interface ReservationFeedbackCreateInput {
  id?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  feedbacks?: Maybe<
    ProductVariantFeedbackCreateManyWithoutReservationFeedbackInput
  >;
  rating?: Maybe<Rating>;
  user: UserCreateOneInput;
  reservation: ReservationCreateOneInput;
  respondedAt?: Maybe<DateTimeInput>;
}

export interface ProductVariantFeedbackCreateManyWithoutReservationFeedbackInput {
  create?: Maybe<
    | ProductVariantFeedbackCreateWithoutReservationFeedbackInput[]
    | ProductVariantFeedbackCreateWithoutReservationFeedbackInput
  >;
  connect?: Maybe<
    | ProductVariantFeedbackWhereUniqueInput[]
    | ProductVariantFeedbackWhereUniqueInput
  >;
}

export interface ProductVariantFeedbackCreateWithoutReservationFeedbackInput {
  id?: Maybe<ID_Input>;
  isCompleted: Boolean;
  questions?: Maybe<
    ProductVariantFeedbackQuestionCreateManyWithoutVariantFeedbackInput
  >;
  variant: ProductVariantCreateOneInput;
}

export interface ReservationFeedbackUpdateInput {
  comment?: Maybe<String>;
  feedbacks?: Maybe<
    ProductVariantFeedbackUpdateManyWithoutReservationFeedbackInput
  >;
  rating?: Maybe<Rating>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  reservation?: Maybe<ReservationUpdateOneRequiredInput>;
  respondedAt?: Maybe<DateTimeInput>;
}

export interface ProductVariantFeedbackUpdateManyWithoutReservationFeedbackInput {
  create?: Maybe<
    | ProductVariantFeedbackCreateWithoutReservationFeedbackInput[]
    | ProductVariantFeedbackCreateWithoutReservationFeedbackInput
  >;
  delete?: Maybe<
    | ProductVariantFeedbackWhereUniqueInput[]
    | ProductVariantFeedbackWhereUniqueInput
  >;
  connect?: Maybe<
    | ProductVariantFeedbackWhereUniqueInput[]
    | ProductVariantFeedbackWhereUniqueInput
  >;
  set?: Maybe<
    | ProductVariantFeedbackWhereUniqueInput[]
    | ProductVariantFeedbackWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ProductVariantFeedbackWhereUniqueInput[]
    | ProductVariantFeedbackWhereUniqueInput
  >;
  update?: Maybe<
    | ProductVariantFeedbackUpdateWithWhereUniqueWithoutReservationFeedbackInput[]
    | ProductVariantFeedbackUpdateWithWhereUniqueWithoutReservationFeedbackInput
  >;
  upsert?: Maybe<
    | ProductVariantFeedbackUpsertWithWhereUniqueWithoutReservationFeedbackInput[]
    | ProductVariantFeedbackUpsertWithWhereUniqueWithoutReservationFeedbackInput
  >;
  deleteMany?: Maybe<
    | ProductVariantFeedbackScalarWhereInput[]
    | ProductVariantFeedbackScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductVariantFeedbackUpdateManyWithWhereNestedInput[]
    | ProductVariantFeedbackUpdateManyWithWhereNestedInput
  >;
}

export interface ProductVariantFeedbackUpdateWithWhereUniqueWithoutReservationFeedbackInput {
  where: ProductVariantFeedbackWhereUniqueInput;
  data: ProductVariantFeedbackUpdateWithoutReservationFeedbackDataInput;
}

export interface ProductVariantFeedbackUpdateWithoutReservationFeedbackDataInput {
  isCompleted?: Maybe<Boolean>;
  questions?: Maybe<
    ProductVariantFeedbackQuestionUpdateManyWithoutVariantFeedbackInput
  >;
  variant?: Maybe<ProductVariantUpdateOneRequiredInput>;
}

export interface ProductVariantFeedbackUpsertWithWhereUniqueWithoutReservationFeedbackInput {
  where: ProductVariantFeedbackWhereUniqueInput;
  update: ProductVariantFeedbackUpdateWithoutReservationFeedbackDataInput;
  create: ProductVariantFeedbackCreateWithoutReservationFeedbackInput;
}

export interface ProductVariantFeedbackScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  isCompleted?: Maybe<Boolean>;
  isCompleted_not?: Maybe<Boolean>;
  AND?: Maybe<
    | ProductVariantFeedbackScalarWhereInput[]
    | ProductVariantFeedbackScalarWhereInput
  >;
  OR?: Maybe<
    | ProductVariantFeedbackScalarWhereInput[]
    | ProductVariantFeedbackScalarWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantFeedbackScalarWhereInput[]
    | ProductVariantFeedbackScalarWhereInput
  >;
}

export interface ProductVariantFeedbackUpdateManyWithWhereNestedInput {
  where: ProductVariantFeedbackScalarWhereInput;
  data: ProductVariantFeedbackUpdateManyDataInput;
}

export interface ProductVariantFeedbackUpdateManyDataInput {
  isCompleted?: Maybe<Boolean>;
}

export interface ReservationFeedbackUpdateManyMutationInput {
  comment?: Maybe<String>;
  rating?: Maybe<Rating>;
  respondedAt?: Maybe<DateTimeInput>;
}

export interface ReservationReceiptCreateInput {
  id?: Maybe<ID_Input>;
  reservation: ReservationCreateOneWithoutReceiptInput;
  items?: Maybe<ReservationReceiptItemCreateManyInput>;
}

export interface ReservationCreateOneWithoutReceiptInput {
  create?: Maybe<ReservationCreateWithoutReceiptInput>;
  connect?: Maybe<ReservationWhereUniqueInput>;
}

export interface ReservationCreateWithoutReceiptInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  customer: CustomerCreateOneWithoutReservationsInput;
  sentPackage?: Maybe<PackageCreateOneInput>;
  returnedPackage?: Maybe<PackageCreateOneInput>;
  products?: Maybe<PhysicalProductCreateManyInput>;
  packageEvents?: Maybe<PackageTransitEventCreateManyWithoutReservationInput>;
  reservationNumber: Int;
  phase: ReservationPhase;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  lastLocation?: Maybe<LocationCreateOneInput>;
  shippingOption?: Maybe<ShippingOptionCreateOneInput>;
}

export interface ReservationReceiptUpdateInput {
  reservation?: Maybe<ReservationUpdateOneRequiredWithoutReceiptInput>;
  items?: Maybe<ReservationReceiptItemUpdateManyInput>;
}

export interface ReservationUpdateOneRequiredWithoutReceiptInput {
  create?: Maybe<ReservationCreateWithoutReceiptInput>;
  update?: Maybe<ReservationUpdateWithoutReceiptDataInput>;
  upsert?: Maybe<ReservationUpsertWithoutReceiptInput>;
  connect?: Maybe<ReservationWhereUniqueInput>;
}

export interface ReservationUpdateWithoutReceiptDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutReservationsInput>;
  sentPackage?: Maybe<PackageUpdateOneInput>;
  returnedPackage?: Maybe<PackageUpdateOneInput>;
  products?: Maybe<PhysicalProductUpdateManyInput>;
  packageEvents?: Maybe<PackageTransitEventUpdateManyWithoutReservationInput>;
  reservationNumber?: Maybe<Int>;
  phase?: Maybe<ReservationPhase>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  reminderSentAt?: Maybe<DateTimeInput>;
  statusUpdatedAt?: Maybe<DateTimeInput>;
  lastLocation?: Maybe<LocationUpdateOneInput>;
  shippingOption?: Maybe<ShippingOptionUpdateOneInput>;
}

export interface ReservationUpsertWithoutReceiptInput {
  update: ReservationUpdateWithoutReceiptDataInput;
  create: ReservationCreateWithoutReceiptInput;
}

export interface ReservationReceiptItemUpdateInput {
  product?: Maybe<PhysicalProductUpdateOneRequiredInput>;
  productStatus?: Maybe<PhysicalProductStatus>;
  notes?: Maybe<String>;
}

export interface ReservationReceiptItemUpdateManyMutationInput {
  productStatus?: Maybe<PhysicalProductStatus>;
  notes?: Maybe<String>;
}

export interface SeasonUpdateInput {
  year?: Maybe<Int>;
  seasonCode?: Maybe<SeasonCode>;
}

export interface SeasonUpdateManyMutationInput {
  year?: Maybe<Int>;
  seasonCode?: Maybe<SeasonCode>;
}

export interface ShippingMethodUpdateInput {
  code?: Maybe<ShippingCode>;
  displayText?: Maybe<String>;
}

export interface ShippingMethodUpdateManyMutationInput {
  code?: Maybe<ShippingCode>;
  displayText?: Maybe<String>;
}

export interface ShippingOptionUpdateInput {
  origin?: Maybe<LocationUpdateOneInput>;
  destination?: Maybe<LocationUpdateOneWithoutShippingOptionsInput>;
  shippingMethod?: Maybe<ShippingMethodUpdateOneInput>;
  externalCost?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
}

export interface ShippingOptionUpdateManyMutationInput {
  externalCost?: Maybe<Int>;
  averageDuration?: Maybe<Int>;
}

export interface ShopifyProductVariantUpdateInput {
  externalId?: Maybe<String>;
  cachedPrice?: Maybe<Float>;
  cachedAvailableForSale?: Maybe<Boolean>;
  cacheExpiresAt?: Maybe<DateTimeInput>;
}

export interface ShopifyProductVariantUpdateManyMutationInput {
  externalId?: Maybe<String>;
  cachedPrice?: Maybe<Float>;
  cachedAvailableForSale?: Maybe<Boolean>;
  cacheExpiresAt?: Maybe<DateTimeInput>;
}

export interface SizeUpdateInput {
  slug?: Maybe<String>;
  productType?: Maybe<ProductType>;
  top?: Maybe<TopSizeUpdateOneInput>;
  bottom?: Maybe<BottomSizeUpdateOneInput>;
  display?: Maybe<String>;
}

export interface SizeUpdateManyMutationInput {
  slug?: Maybe<String>;
  productType?: Maybe<ProductType>;
  display?: Maybe<String>;
}

export interface SmsReceiptUpdateInput {
  externalId?: Maybe<String>;
  body?: Maybe<String>;
  mediaUrls?: Maybe<SmsReceiptUpdatemediaUrlsInput>;
  status?: Maybe<SmsStatus>;
  smsId?: Maybe<String>;
}

export interface SmsReceiptUpdateManyMutationInput {
  externalId?: Maybe<String>;
  body?: Maybe<String>;
  mediaUrls?: Maybe<SmsReceiptUpdatemediaUrlsInput>;
  status?: Maybe<SmsStatus>;
  smsId?: Maybe<String>;
}

export interface StylePreferencesUpdateInput {
  styles?: Maybe<StylePreferencesUpdatestylesInput>;
  patterns?: Maybe<StylePreferencesUpdatepatternsInput>;
  colors?: Maybe<StylePreferencesUpdatecolorsInput>;
  brands?: Maybe<StylePreferencesUpdatebrandsInput>;
}

export interface StylePreferencesUpdateManyMutationInput {
  styles?: Maybe<StylePreferencesUpdatestylesInput>;
  patterns?: Maybe<StylePreferencesUpdatepatternsInput>;
  colors?: Maybe<StylePreferencesUpdatecolorsInput>;
  brands?: Maybe<StylePreferencesUpdatebrandsInput>;
}

export interface SyncTimingCreateInput {
  id?: Maybe<ID_Input>;
  type: SyncTimingType;
  syncedAt: DateTimeInput;
}

export interface SyncTimingUpdateInput {
  type?: Maybe<SyncTimingType>;
  syncedAt?: Maybe<DateTimeInput>;
}

export interface SyncTimingUpdateManyMutationInput {
  type?: Maybe<SyncTimingType>;
  syncedAt?: Maybe<DateTimeInput>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  products?: Maybe<ProductCreateManyWithoutTagsInput>;
}

export interface ProductCreateManyWithoutTagsInput {
  create?: Maybe<
    ProductCreateWithoutTagsInput[] | ProductCreateWithoutTagsInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  architecture?: Maybe<ProductArchitecture>;
  brand: BrandCreateOneWithoutProductsInput;
  category: CategoryCreateOneWithoutProductsInput;
  color: ColorCreateOneInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageCreateManyInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryCreateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelCreateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeCreateOneInput>;
  name: String;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonCreateOneInput>;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  slug: String;
  status?: Maybe<ProductStatus>;
  tier?: Maybe<ProductTierCreateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
}

export interface TagUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutTagsInput>;
}

export interface ProductUpdateManyWithoutTagsInput {
  create?: Maybe<
    ProductCreateWithoutTagsInput[] | ProductCreateWithoutTagsInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutTagsInput[]
    | ProductUpdateWithWhereUniqueWithoutTagsInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutTagsInput[]
    | ProductUpsertWithWhereUniqueWithoutTagsInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutTagsInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutTagsDataInput;
}

export interface ProductUpdateWithoutTagsDataInput {
  architecture?: Maybe<ProductArchitecture>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  buyNewEnabled?: Maybe<Boolean>;
  images?: Maybe<ImageUpdateManyInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  materialCategory?: Maybe<
    ProductMaterialCategoryUpdateOneWithoutProductsInput
  >;
  model?: Maybe<ProductModelUpdateOneWithoutProductsInput>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<SizeUpdateOneInput>;
  name?: Maybe<String>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  photographyStatus?: Maybe<PhotographyStatus>;
  productFit?: Maybe<ProductFit>;
  publishedAt?: Maybe<DateTimeInput>;
  retailPrice?: Maybe<Int>;
  season?: Maybe<ProductSeasonUpdateOneInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  slug?: Maybe<String>;
  status?: Maybe<ProductStatus>;
  tier?: Maybe<ProductTierUpdateOneInput>;
  type?: Maybe<ProductType>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutTagsInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutTagsDataInput;
  create: ProductCreateWithoutTagsInput;
}

export interface TagUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface TopSizeUpdateInput {
  letter?: Maybe<LetterSize>;
  sleeve?: Maybe<Float>;
  shoulder?: Maybe<Float>;
  chest?: Maybe<Float>;
  neck?: Maybe<Float>;
  length?: Maybe<Float>;
}

export interface TopSizeUpdateManyMutationInput {
  letter?: Maybe<LetterSize>;
  sleeve?: Maybe<Float>;
  shoulder?: Maybe<Float>;
  chest?: Maybe<Float>;
  neck?: Maybe<Float>;
  length?: Maybe<Float>;
}

export interface UTMDataCreateInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneWithoutUtmInput;
  source?: Maybe<String>;
  medium?: Maybe<String>;
  campaign?: Maybe<String>;
  term?: Maybe<String>;
  content?: Maybe<String>;
}

export interface CustomerCreateOneWithoutUtmInput {
  create?: Maybe<CustomerCreateWithoutUtmInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutUtmInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipCreateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemCreateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerCreateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerCreateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductCreateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataCreateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
}

export interface UTMDataUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredWithoutUtmInput>;
  source?: Maybe<String>;
  medium?: Maybe<String>;
  campaign?: Maybe<String>;
  term?: Maybe<String>;
  content?: Maybe<String>;
}

export interface CustomerUpdateOneRequiredWithoutUtmInput {
  create?: Maybe<CustomerCreateWithoutUtmInput>;
  update?: Maybe<CustomerUpdateWithoutUtmDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutUtmInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutUtmDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  membership?: Maybe<CustomerMembershipUpdateOneWithoutCustomerInput>;
  bagItems?: Maybe<BagItemUpdateManyWithoutCustomerInput>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
  referralLink?: Maybe<String>;
  referrerId?: Maybe<String>;
  referrer?: Maybe<CustomerUpdateOneWithoutReferreesInput>;
  referrees?: Maybe<CustomerUpdateManyWithoutReferrerInput>;
  emailedProducts?: Maybe<ProductUpdateManyInput>;
  admissions?: Maybe<CustomerAdmissionsDataUpdateOneWithoutCustomerInput>;
  authorizedAt?: Maybe<DateTimeInput>;
}

export interface CustomerUpsertWithoutUtmInput {
  update: CustomerUpdateWithoutUtmDataInput;
  create: CustomerCreateWithoutUtmInput;
}

export interface UTMDataUpdateManyMutationInput {
  source?: Maybe<String>;
  medium?: Maybe<String>;
  campaign?: Maybe<String>;
  term?: Maybe<String>;
  content?: Maybe<String>;
}

export interface UserUpdateInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserUpdaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  pushNotifications?: Maybe<PushNotificationReceiptUpdateManyWithoutUsersInput>;
  emails?: Maybe<EmailReceiptUpdateManyWithoutUserInput>;
  sendSystemEmails?: Maybe<Boolean>;
  pushNotification?: Maybe<UserPushNotificationUpdateOneInput>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
  smsReceipts?: Maybe<SmsReceiptUpdateManyInput>;
  fitPics?: Maybe<FitPicUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
  roles?: Maybe<UserUpdaterolesInput>;
  pushNotificationStatus?: Maybe<PushNotificationStatus>;
  sendSystemEmails?: Maybe<Boolean>;
  verificationStatus?: Maybe<UserVerificationStatus>;
  verificationMethod?: Maybe<UserVerificationMethod>;
}

export interface UserPushNotificationUpdateInput {
  interests?: Maybe<UserPushNotificationInterestUpdateManyInput>;
  status?: Maybe<Boolean>;
  history?: Maybe<PushNotificationReceiptUpdateManyInput>;
}

export interface UserPushNotificationUpdateManyMutationInput {
  status?: Maybe<Boolean>;
}

export interface UserPushNotificationInterestUpdateInput {
  type?: Maybe<UserPushNotificationInterestType>;
  value?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<Boolean>;
}

export interface UserPushNotificationInterestUpdateManyMutationInput {
  type?: Maybe<UserPushNotificationInterestType>;
  value?: Maybe<String>;
  status?: Maybe<Boolean>;
}

export interface WarehouseLocationCreateInput {
  id?: Maybe<ID_Input>;
  type: WarehouseLocationType;
  barcode: String;
  locationCode: String;
  itemCode: String;
  physicalProducts?: Maybe<
    PhysicalProductCreateManyWithoutWarehouseLocationInput
  >;
  constraints?: Maybe<
    WarehouseLocationConstraintCreateManyWithoutLocationsInput
  >;
}

export interface PhysicalProductCreateManyWithoutWarehouseLocationInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutWarehouseLocationInput[]
    | PhysicalProductCreateWithoutWarehouseLocationInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
}

export interface PhysicalProductCreateWithoutWarehouseLocationInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  location?: Maybe<LocationCreateOneWithoutPhysicalProductsInput>;
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber: Int;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceCreateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportCreateManyWithoutPhysicalProductInput
  >;
}

export interface WarehouseLocationUpdateInput {
  type?: Maybe<WarehouseLocationType>;
  barcode?: Maybe<String>;
  locationCode?: Maybe<String>;
  itemCode?: Maybe<String>;
  physicalProducts?: Maybe<
    PhysicalProductUpdateManyWithoutWarehouseLocationInput
  >;
  constraints?: Maybe<
    WarehouseLocationConstraintUpdateManyWithoutLocationsInput
  >;
}

export interface PhysicalProductUpdateManyWithoutWarehouseLocationInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutWarehouseLocationInput[]
    | PhysicalProductCreateWithoutWarehouseLocationInput
  >;
  delete?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  set?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  update?: Maybe<
    | PhysicalProductUpdateWithWhereUniqueWithoutWarehouseLocationInput[]
    | PhysicalProductUpdateWithWhereUniqueWithoutWarehouseLocationInput
  >;
  upsert?: Maybe<
    | PhysicalProductUpsertWithWhereUniqueWithoutWarehouseLocationInput[]
    | PhysicalProductUpsertWithWhereUniqueWithoutWarehouseLocationInput
  >;
  deleteMany?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductUpdateManyWithWhereNestedInput[]
    | PhysicalProductUpdateManyWithWhereNestedInput
  >;
}

export interface PhysicalProductUpdateWithWhereUniqueWithoutWarehouseLocationInput {
  where: PhysicalProductWhereUniqueInput;
  data: PhysicalProductUpdateWithoutWarehouseLocationDataInput;
}

export interface PhysicalProductUpdateWithoutWarehouseLocationDataInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneWithoutPhysicalProductsInput>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  offloadMethod?: Maybe<PhysicalProductOffloadMethod>;
  offloadNotes?: Maybe<String>;
  sequenceNumber?: Maybe<Int>;
  barcoded?: Maybe<Boolean>;
  dateOrdered?: Maybe<DateTimeInput>;
  dateReceived?: Maybe<DateTimeInput>;
  unitCost?: Maybe<Float>;
  price?: Maybe<PhysicalProductPriceUpdateOneInput>;
  reports?: Maybe<
    PhysicalProductQualityReportUpdateManyWithoutPhysicalProductInput
  >;
}

export interface PhysicalProductUpsertWithWhereUniqueWithoutWarehouseLocationInput {
  where: PhysicalProductWhereUniqueInput;
  update: PhysicalProductUpdateWithoutWarehouseLocationDataInput;
  create: PhysicalProductCreateWithoutWarehouseLocationInput;
}

export interface WarehouseLocationUpdateManyMutationInput {
  type?: Maybe<WarehouseLocationType>;
  barcode?: Maybe<String>;
  locationCode?: Maybe<String>;
  itemCode?: Maybe<String>;
}

export interface WarehouseLocationConstraintCreateInput {
  id?: Maybe<ID_Input>;
  category: CategoryCreateOneInput;
  limit: Int;
  locations?: Maybe<WarehouseLocationCreateManyWithoutConstraintsInput>;
}

export interface WarehouseLocationCreateManyWithoutConstraintsInput {
  create?: Maybe<
    | WarehouseLocationCreateWithoutConstraintsInput[]
    | WarehouseLocationCreateWithoutConstraintsInput
  >;
  connect?: Maybe<
    WarehouseLocationWhereUniqueInput[] | WarehouseLocationWhereUniqueInput
  >;
}

export interface WarehouseLocationCreateWithoutConstraintsInput {
  id?: Maybe<ID_Input>;
  type: WarehouseLocationType;
  barcode: String;
  locationCode: String;
  itemCode: String;
  physicalProducts?: Maybe<
    PhysicalProductCreateManyWithoutWarehouseLocationInput
  >;
}

export interface WarehouseLocationConstraintUpdateInput {
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  limit?: Maybe<Int>;
  locations?: Maybe<WarehouseLocationUpdateManyWithoutConstraintsInput>;
}

export interface WarehouseLocationUpdateManyWithoutConstraintsInput {
  create?: Maybe<
    | WarehouseLocationCreateWithoutConstraintsInput[]
    | WarehouseLocationCreateWithoutConstraintsInput
  >;
  delete?: Maybe<
    WarehouseLocationWhereUniqueInput[] | WarehouseLocationWhereUniqueInput
  >;
  connect?: Maybe<
    WarehouseLocationWhereUniqueInput[] | WarehouseLocationWhereUniqueInput
  >;
  set?: Maybe<
    WarehouseLocationWhereUniqueInput[] | WarehouseLocationWhereUniqueInput
  >;
  disconnect?: Maybe<
    WarehouseLocationWhereUniqueInput[] | WarehouseLocationWhereUniqueInput
  >;
  update?: Maybe<
    | WarehouseLocationUpdateWithWhereUniqueWithoutConstraintsInput[]
    | WarehouseLocationUpdateWithWhereUniqueWithoutConstraintsInput
  >;
  upsert?: Maybe<
    | WarehouseLocationUpsertWithWhereUniqueWithoutConstraintsInput[]
    | WarehouseLocationUpsertWithWhereUniqueWithoutConstraintsInput
  >;
  deleteMany?: Maybe<
    WarehouseLocationScalarWhereInput[] | WarehouseLocationScalarWhereInput
  >;
  updateMany?: Maybe<
    | WarehouseLocationUpdateManyWithWhereNestedInput[]
    | WarehouseLocationUpdateManyWithWhereNestedInput
  >;
}

export interface WarehouseLocationUpdateWithWhereUniqueWithoutConstraintsInput {
  where: WarehouseLocationWhereUniqueInput;
  data: WarehouseLocationUpdateWithoutConstraintsDataInput;
}

export interface WarehouseLocationUpdateWithoutConstraintsDataInput {
  type?: Maybe<WarehouseLocationType>;
  barcode?: Maybe<String>;
  locationCode?: Maybe<String>;
  itemCode?: Maybe<String>;
  physicalProducts?: Maybe<
    PhysicalProductUpdateManyWithoutWarehouseLocationInput
  >;
}

export interface WarehouseLocationUpsertWithWhereUniqueWithoutConstraintsInput {
  where: WarehouseLocationWhereUniqueInput;
  update: WarehouseLocationUpdateWithoutConstraintsDataInput;
  create: WarehouseLocationCreateWithoutConstraintsInput;
}

export interface WarehouseLocationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<WarehouseLocationType>;
  type_not?: Maybe<WarehouseLocationType>;
  type_in?: Maybe<WarehouseLocationType[] | WarehouseLocationType>;
  type_not_in?: Maybe<WarehouseLocationType[] | WarehouseLocationType>;
  barcode?: Maybe<String>;
  barcode_not?: Maybe<String>;
  barcode_in?: Maybe<String[] | String>;
  barcode_not_in?: Maybe<String[] | String>;
  barcode_lt?: Maybe<String>;
  barcode_lte?: Maybe<String>;
  barcode_gt?: Maybe<String>;
  barcode_gte?: Maybe<String>;
  barcode_contains?: Maybe<String>;
  barcode_not_contains?: Maybe<String>;
  barcode_starts_with?: Maybe<String>;
  barcode_not_starts_with?: Maybe<String>;
  barcode_ends_with?: Maybe<String>;
  barcode_not_ends_with?: Maybe<String>;
  locationCode?: Maybe<String>;
  locationCode_not?: Maybe<String>;
  locationCode_in?: Maybe<String[] | String>;
  locationCode_not_in?: Maybe<String[] | String>;
  locationCode_lt?: Maybe<String>;
  locationCode_lte?: Maybe<String>;
  locationCode_gt?: Maybe<String>;
  locationCode_gte?: Maybe<String>;
  locationCode_contains?: Maybe<String>;
  locationCode_not_contains?: Maybe<String>;
  locationCode_starts_with?: Maybe<String>;
  locationCode_not_starts_with?: Maybe<String>;
  locationCode_ends_with?: Maybe<String>;
  locationCode_not_ends_with?: Maybe<String>;
  itemCode?: Maybe<String>;
  itemCode_not?: Maybe<String>;
  itemCode_in?: Maybe<String[] | String>;
  itemCode_not_in?: Maybe<String[] | String>;
  itemCode_lt?: Maybe<String>;
  itemCode_lte?: Maybe<String>;
  itemCode_gt?: Maybe<String>;
  itemCode_gte?: Maybe<String>;
  itemCode_contains?: Maybe<String>;
  itemCode_not_contains?: Maybe<String>;
  itemCode_starts_with?: Maybe<String>;
  itemCode_not_starts_with?: Maybe<String>;
  itemCode_ends_with?: Maybe<String>;
  itemCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    WarehouseLocationScalarWhereInput[] | WarehouseLocationScalarWhereInput
  >;
  OR?: Maybe<
    WarehouseLocationScalarWhereInput[] | WarehouseLocationScalarWhereInput
  >;
  NOT?: Maybe<
    WarehouseLocationScalarWhereInput[] | WarehouseLocationScalarWhereInput
  >;
}

export interface WarehouseLocationUpdateManyWithWhereNestedInput {
  where: WarehouseLocationScalarWhereInput;
  data: WarehouseLocationUpdateManyDataInput;
}

export interface WarehouseLocationUpdateManyDataInput {
  type?: Maybe<WarehouseLocationType>;
  barcode?: Maybe<String>;
  locationCode?: Maybe<String>;
  itemCode?: Maybe<String>;
}

export interface WarehouseLocationConstraintUpdateManyMutationInput {
  limit?: Maybe<Int>;
}

export interface ActiveAdminUserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActiveAdminUserWhereInput>;
  AND?: Maybe<
    | ActiveAdminUserSubscriptionWhereInput[]
    | ActiveAdminUserSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ActiveAdminUserSubscriptionWhereInput[]
    | ActiveAdminUserSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ActiveAdminUserSubscriptionWhereInput[]
    | ActiveAdminUserSubscriptionWhereInput
  >;
}

export interface AdminActionLogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AdminActionLogWhereInput>;
  AND?: Maybe<
    | AdminActionLogSubscriptionWhereInput[]
    | AdminActionLogSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AdminActionLogSubscriptionWhereInput[]
    | AdminActionLogSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AdminActionLogSubscriptionWhereInput[]
    | AdminActionLogSubscriptionWhereInput
  >;
}

export interface BagItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BagItemWhereInput>;
  AND?: Maybe<BagItemSubscriptionWhereInput[] | BagItemSubscriptionWhereInput>;
  OR?: Maybe<BagItemSubscriptionWhereInput[] | BagItemSubscriptionWhereInput>;
  NOT?: Maybe<BagItemSubscriptionWhereInput[] | BagItemSubscriptionWhereInput>;
}

export interface BillingInfoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BillingInfoWhereInput>;
  AND?: Maybe<
    BillingInfoSubscriptionWhereInput[] | BillingInfoSubscriptionWhereInput
  >;
  OR?: Maybe<
    BillingInfoSubscriptionWhereInput[] | BillingInfoSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BillingInfoSubscriptionWhereInput[] | BillingInfoSubscriptionWhereInput
  >;
}

export interface BottomSizeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BottomSizeWhereInput>;
  AND?: Maybe<
    BottomSizeSubscriptionWhereInput[] | BottomSizeSubscriptionWhereInput
  >;
  OR?: Maybe<
    BottomSizeSubscriptionWhereInput[] | BottomSizeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BottomSizeSubscriptionWhereInput[] | BottomSizeSubscriptionWhereInput
  >;
}

export interface BrandSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BrandWhereInput>;
  AND?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
  OR?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
  NOT?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface CollectionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CollectionWhereInput>;
  AND?: Maybe<
    CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput
  >;
  OR?: Maybe<
    CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput
  >;
}

export interface ColorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ColorWhereInput>;
  AND?: Maybe<ColorSubscriptionWhereInput[] | ColorSubscriptionWhereInput>;
  OR?: Maybe<ColorSubscriptionWhereInput[] | ColorSubscriptionWhereInput>;
  NOT?: Maybe<ColorSubscriptionWhereInput[] | ColorSubscriptionWhereInput>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface CustomerAdmissionsDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerAdmissionsDataWhereInput>;
  AND?: Maybe<
    | CustomerAdmissionsDataSubscriptionWhereInput[]
    | CustomerAdmissionsDataSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerAdmissionsDataSubscriptionWhereInput[]
    | CustomerAdmissionsDataSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerAdmissionsDataSubscriptionWhereInput[]
    | CustomerAdmissionsDataSubscriptionWhereInput
  >;
}

export interface CustomerDetailSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerDetailWhereInput>;
  AND?: Maybe<
    | CustomerDetailSubscriptionWhereInput[]
    | CustomerDetailSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerDetailSubscriptionWhereInput[]
    | CustomerDetailSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerDetailSubscriptionWhereInput[]
    | CustomerDetailSubscriptionWhereInput
  >;
}

export interface CustomerMembershipSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerMembershipWhereInput>;
  AND?: Maybe<
    | CustomerMembershipSubscriptionWhereInput[]
    | CustomerMembershipSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerMembershipSubscriptionWhereInput[]
    | CustomerMembershipSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerMembershipSubscriptionWhereInput[]
    | CustomerMembershipSubscriptionWhereInput
  >;
}

export interface EmailReceiptSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmailReceiptWhereInput>;
  AND?: Maybe<
    EmailReceiptSubscriptionWhereInput[] | EmailReceiptSubscriptionWhereInput
  >;
  OR?: Maybe<
    EmailReceiptSubscriptionWhereInput[] | EmailReceiptSubscriptionWhereInput
  >;
  NOT?: Maybe<
    EmailReceiptSubscriptionWhereInput[] | EmailReceiptSubscriptionWhereInput
  >;
}

export interface ExternalShopifyIntegrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExternalShopifyIntegrationWhereInput>;
  AND?: Maybe<
    | ExternalShopifyIntegrationSubscriptionWhereInput[]
    | ExternalShopifyIntegrationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ExternalShopifyIntegrationSubscriptionWhereInput[]
    | ExternalShopifyIntegrationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ExternalShopifyIntegrationSubscriptionWhereInput[]
    | ExternalShopifyIntegrationSubscriptionWhereInput
  >;
}

export interface FitPicSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FitPicWhereInput>;
  AND?: Maybe<FitPicSubscriptionWhereInput[] | FitPicSubscriptionWhereInput>;
  OR?: Maybe<FitPicSubscriptionWhereInput[] | FitPicSubscriptionWhereInput>;
  NOT?: Maybe<FitPicSubscriptionWhereInput[] | FitPicSubscriptionWhereInput>;
}

export interface FitPicReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FitPicReportWhereInput>;
  AND?: Maybe<
    FitPicReportSubscriptionWhereInput[] | FitPicReportSubscriptionWhereInput
  >;
  OR?: Maybe<
    FitPicReportSubscriptionWhereInput[] | FitPicReportSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FitPicReportSubscriptionWhereInput[] | FitPicReportSubscriptionWhereInput
  >;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  OR?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  NOT?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface InterestedUserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InterestedUserWhereInput>;
  AND?: Maybe<
    | InterestedUserSubscriptionWhereInput[]
    | InterestedUserSubscriptionWhereInput
  >;
  OR?: Maybe<
    | InterestedUserSubscriptionWhereInput[]
    | InterestedUserSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | InterestedUserSubscriptionWhereInput[]
    | InterestedUserSubscriptionWhereInput
  >;
}

export interface LabelSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LabelWhereInput>;
  AND?: Maybe<LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput>;
  OR?: Maybe<LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput>;
  NOT?: Maybe<LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput>;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LocationWhereInput>;
  AND?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
  OR?: Maybe<LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput>;
  NOT?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
}

export interface PackageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PackageWhereInput>;
  AND?: Maybe<PackageSubscriptionWhereInput[] | PackageSubscriptionWhereInput>;
  OR?: Maybe<PackageSubscriptionWhereInput[] | PackageSubscriptionWhereInput>;
  NOT?: Maybe<PackageSubscriptionWhereInput[] | PackageSubscriptionWhereInput>;
}

export interface PackageTransitEventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PackageTransitEventWhereInput>;
  AND?: Maybe<
    | PackageTransitEventSubscriptionWhereInput[]
    | PackageTransitEventSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PackageTransitEventSubscriptionWhereInput[]
    | PackageTransitEventSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PackageTransitEventSubscriptionWhereInput[]
    | PackageTransitEventSubscriptionWhereInput
  >;
}

export interface PauseRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PauseRequestWhereInput>;
  AND?: Maybe<
    PauseRequestSubscriptionWhereInput[] | PauseRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    PauseRequestSubscriptionWhereInput[] | PauseRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PauseRequestSubscriptionWhereInput[] | PauseRequestSubscriptionWhereInput
  >;
}

export interface PaymentPlanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentPlanWhereInput>;
  AND?: Maybe<
    PaymentPlanSubscriptionWhereInput[] | PaymentPlanSubscriptionWhereInput
  >;
  OR?: Maybe<
    PaymentPlanSubscriptionWhereInput[] | PaymentPlanSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PaymentPlanSubscriptionWhereInput[] | PaymentPlanSubscriptionWhereInput
  >;
}

export interface PhysicalProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhysicalProductWhereInput>;
  AND?: Maybe<
    | PhysicalProductSubscriptionWhereInput[]
    | PhysicalProductSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PhysicalProductSubscriptionWhereInput[]
    | PhysicalProductSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PhysicalProductSubscriptionWhereInput[]
    | PhysicalProductSubscriptionWhereInput
  >;
}

export interface PhysicalProductPriceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhysicalProductPriceWhereInput>;
  AND?: Maybe<
    | PhysicalProductPriceSubscriptionWhereInput[]
    | PhysicalProductPriceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PhysicalProductPriceSubscriptionWhereInput[]
    | PhysicalProductPriceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PhysicalProductPriceSubscriptionWhereInput[]
    | PhysicalProductPriceSubscriptionWhereInput
  >;
}

export interface PhysicalProductQualityReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhysicalProductQualityReportWhereInput>;
  AND?: Maybe<
    | PhysicalProductQualityReportSubscriptionWhereInput[]
    | PhysicalProductQualityReportSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PhysicalProductQualityReportSubscriptionWhereInput[]
    | PhysicalProductQualityReportSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PhysicalProductQualityReportSubscriptionWhereInput[]
    | PhysicalProductQualityReportSubscriptionWhereInput
  >;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface ProductFunctionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductFunctionWhereInput>;
  AND?: Maybe<
    | ProductFunctionSubscriptionWhereInput[]
    | ProductFunctionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductFunctionSubscriptionWhereInput[]
    | ProductFunctionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductFunctionSubscriptionWhereInput[]
    | ProductFunctionSubscriptionWhereInput
  >;
}

export interface ProductMaterialCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductMaterialCategoryWhereInput>;
  AND?: Maybe<
    | ProductMaterialCategorySubscriptionWhereInput[]
    | ProductMaterialCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductMaterialCategorySubscriptionWhereInput[]
    | ProductMaterialCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductMaterialCategorySubscriptionWhereInput[]
    | ProductMaterialCategorySubscriptionWhereInput
  >;
}

export interface ProductModelSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductModelWhereInput>;
  AND?: Maybe<
    ProductModelSubscriptionWhereInput[] | ProductModelSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProductModelSubscriptionWhereInput[] | ProductModelSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProductModelSubscriptionWhereInput[] | ProductModelSubscriptionWhereInput
  >;
}

export interface ProductNotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductNotificationWhereInput>;
  AND?: Maybe<
    | ProductNotificationSubscriptionWhereInput[]
    | ProductNotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductNotificationSubscriptionWhereInput[]
    | ProductNotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductNotificationSubscriptionWhereInput[]
    | ProductNotificationSubscriptionWhereInput
  >;
}

export interface ProductRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductRequestWhereInput>;
  AND?: Maybe<
    | ProductRequestSubscriptionWhereInput[]
    | ProductRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductRequestSubscriptionWhereInput[]
    | ProductRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductRequestSubscriptionWhereInput[]
    | ProductRequestSubscriptionWhereInput
  >;
}

export interface ProductSeasonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductSeasonWhereInput>;
  AND?: Maybe<
    ProductSeasonSubscriptionWhereInput[] | ProductSeasonSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProductSeasonSubscriptionWhereInput[] | ProductSeasonSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProductSeasonSubscriptionWhereInput[] | ProductSeasonSubscriptionWhereInput
  >;
}

export interface ProductTierSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductTierWhereInput>;
  AND?: Maybe<
    ProductTierSubscriptionWhereInput[] | ProductTierSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProductTierSubscriptionWhereInput[] | ProductTierSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProductTierSubscriptionWhereInput[] | ProductTierSubscriptionWhereInput
  >;
}

export interface ProductVariantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductVariantWhereInput>;
  AND?: Maybe<
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput
  >;
}

export interface ProductVariantFeedbackSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductVariantFeedbackWhereInput>;
  AND?: Maybe<
    | ProductVariantFeedbackSubscriptionWhereInput[]
    | ProductVariantFeedbackSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductVariantFeedbackSubscriptionWhereInput[]
    | ProductVariantFeedbackSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantFeedbackSubscriptionWhereInput[]
    | ProductVariantFeedbackSubscriptionWhereInput
  >;
}

export interface ProductVariantFeedbackQuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductVariantFeedbackQuestionWhereInput>;
  AND?: Maybe<
    | ProductVariantFeedbackQuestionSubscriptionWhereInput[]
    | ProductVariantFeedbackQuestionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductVariantFeedbackQuestionSubscriptionWhereInput[]
    | ProductVariantFeedbackQuestionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantFeedbackQuestionSubscriptionWhereInput[]
    | ProductVariantFeedbackQuestionSubscriptionWhereInput
  >;
}

export interface ProductVariantPriceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductVariantPriceWhereInput>;
  AND?: Maybe<
    | ProductVariantPriceSubscriptionWhereInput[]
    | ProductVariantPriceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductVariantPriceSubscriptionWhereInput[]
    | ProductVariantPriceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantPriceSubscriptionWhereInput[]
    | ProductVariantPriceSubscriptionWhereInput
  >;
}

export interface ProductVariantWantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductVariantWantWhereInput>;
  AND?: Maybe<
    | ProductVariantWantSubscriptionWhereInput[]
    | ProductVariantWantSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductVariantWantSubscriptionWhereInput[]
    | ProductVariantWantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantWantSubscriptionWhereInput[]
    | ProductVariantWantSubscriptionWhereInput
  >;
}

export interface PushNotificationReceiptSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PushNotificationReceiptWhereInput>;
  AND?: Maybe<
    | PushNotificationReceiptSubscriptionWhereInput[]
    | PushNotificationReceiptSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PushNotificationReceiptSubscriptionWhereInput[]
    | PushNotificationReceiptSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PushNotificationReceiptSubscriptionWhereInput[]
    | PushNotificationReceiptSubscriptionWhereInput
  >;
}

export interface RecentlyViewedProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RecentlyViewedProductWhereInput>;
  AND?: Maybe<
    | RecentlyViewedProductSubscriptionWhereInput[]
    | RecentlyViewedProductSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RecentlyViewedProductSubscriptionWhereInput[]
    | RecentlyViewedProductSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RecentlyViewedProductSubscriptionWhereInput[]
    | RecentlyViewedProductSubscriptionWhereInput
  >;
}

export interface ReservationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReservationWhereInput>;
  AND?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
}

export interface ReservationFeedbackSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReservationFeedbackWhereInput>;
  AND?: Maybe<
    | ReservationFeedbackSubscriptionWhereInput[]
    | ReservationFeedbackSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ReservationFeedbackSubscriptionWhereInput[]
    | ReservationFeedbackSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ReservationFeedbackSubscriptionWhereInput[]
    | ReservationFeedbackSubscriptionWhereInput
  >;
}

export interface ReservationReceiptSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReservationReceiptWhereInput>;
  AND?: Maybe<
    | ReservationReceiptSubscriptionWhereInput[]
    | ReservationReceiptSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ReservationReceiptSubscriptionWhereInput[]
    | ReservationReceiptSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ReservationReceiptSubscriptionWhereInput[]
    | ReservationReceiptSubscriptionWhereInput
  >;
}

export interface ReservationReceiptItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReservationReceiptItemWhereInput>;
  AND?: Maybe<
    | ReservationReceiptItemSubscriptionWhereInput[]
    | ReservationReceiptItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ReservationReceiptItemSubscriptionWhereInput[]
    | ReservationReceiptItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ReservationReceiptItemSubscriptionWhereInput[]
    | ReservationReceiptItemSubscriptionWhereInput
  >;
}

export interface SeasonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SeasonWhereInput>;
  AND?: Maybe<SeasonSubscriptionWhereInput[] | SeasonSubscriptionWhereInput>;
  OR?: Maybe<SeasonSubscriptionWhereInput[] | SeasonSubscriptionWhereInput>;
  NOT?: Maybe<SeasonSubscriptionWhereInput[] | SeasonSubscriptionWhereInput>;
}

export interface ShippingMethodSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShippingMethodWhereInput>;
  AND?: Maybe<
    | ShippingMethodSubscriptionWhereInput[]
    | ShippingMethodSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ShippingMethodSubscriptionWhereInput[]
    | ShippingMethodSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ShippingMethodSubscriptionWhereInput[]
    | ShippingMethodSubscriptionWhereInput
  >;
}

export interface ShippingOptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShippingOptionWhereInput>;
  AND?: Maybe<
    | ShippingOptionSubscriptionWhereInput[]
    | ShippingOptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ShippingOptionSubscriptionWhereInput[]
    | ShippingOptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ShippingOptionSubscriptionWhereInput[]
    | ShippingOptionSubscriptionWhereInput
  >;
}

export interface ShopifyProductVariantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShopifyProductVariantWhereInput>;
  AND?: Maybe<
    | ShopifyProductVariantSubscriptionWhereInput[]
    | ShopifyProductVariantSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ShopifyProductVariantSubscriptionWhereInput[]
    | ShopifyProductVariantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ShopifyProductVariantSubscriptionWhereInput[]
    | ShopifyProductVariantSubscriptionWhereInput
  >;
}

export interface SizeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SizeWhereInput>;
  AND?: Maybe<SizeSubscriptionWhereInput[] | SizeSubscriptionWhereInput>;
  OR?: Maybe<SizeSubscriptionWhereInput[] | SizeSubscriptionWhereInput>;
  NOT?: Maybe<SizeSubscriptionWhereInput[] | SizeSubscriptionWhereInput>;
}

export interface SmsReceiptSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SmsReceiptWhereInput>;
  AND?: Maybe<
    SmsReceiptSubscriptionWhereInput[] | SmsReceiptSubscriptionWhereInput
  >;
  OR?: Maybe<
    SmsReceiptSubscriptionWhereInput[] | SmsReceiptSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SmsReceiptSubscriptionWhereInput[] | SmsReceiptSubscriptionWhereInput
  >;
}

export interface StylePreferencesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StylePreferencesWhereInput>;
  AND?: Maybe<
    | StylePreferencesSubscriptionWhereInput[]
    | StylePreferencesSubscriptionWhereInput
  >;
  OR?: Maybe<
    | StylePreferencesSubscriptionWhereInput[]
    | StylePreferencesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | StylePreferencesSubscriptionWhereInput[]
    | StylePreferencesSubscriptionWhereInput
  >;
}

export interface SyncTimingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SyncTimingWhereInput>;
  AND?: Maybe<
    SyncTimingSubscriptionWhereInput[] | SyncTimingSubscriptionWhereInput
  >;
  OR?: Maybe<
    SyncTimingSubscriptionWhereInput[] | SyncTimingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SyncTimingSubscriptionWhereInput[] | SyncTimingSubscriptionWhereInput
  >;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface TopSizeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TopSizeWhereInput>;
  AND?: Maybe<TopSizeSubscriptionWhereInput[] | TopSizeSubscriptionWhereInput>;
  OR?: Maybe<TopSizeSubscriptionWhereInput[] | TopSizeSubscriptionWhereInput>;
  NOT?: Maybe<TopSizeSubscriptionWhereInput[] | TopSizeSubscriptionWhereInput>;
}

export interface UTMDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UTMDataWhereInput>;
  AND?: Maybe<UTMDataSubscriptionWhereInput[] | UTMDataSubscriptionWhereInput>;
  OR?: Maybe<UTMDataSubscriptionWhereInput[] | UTMDataSubscriptionWhereInput>;
  NOT?: Maybe<UTMDataSubscriptionWhereInput[] | UTMDataSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserPushNotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserPushNotificationWhereInput>;
  AND?: Maybe<
    | UserPushNotificationSubscriptionWhereInput[]
    | UserPushNotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserPushNotificationSubscriptionWhereInput[]
    | UserPushNotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserPushNotificationSubscriptionWhereInput[]
    | UserPushNotificationSubscriptionWhereInput
  >;
}

export interface UserPushNotificationInterestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserPushNotificationInterestWhereInput>;
  AND?: Maybe<
    | UserPushNotificationInterestSubscriptionWhereInput[]
    | UserPushNotificationInterestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserPushNotificationInterestSubscriptionWhereInput[]
    | UserPushNotificationInterestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserPushNotificationInterestSubscriptionWhereInput[]
    | UserPushNotificationInterestSubscriptionWhereInput
  >;
}

export interface WarehouseLocationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WarehouseLocationWhereInput>;
  AND?: Maybe<
    | WarehouseLocationSubscriptionWhereInput[]
    | WarehouseLocationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WarehouseLocationSubscriptionWhereInput[]
    | WarehouseLocationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WarehouseLocationSubscriptionWhereInput[]
    | WarehouseLocationSubscriptionWhereInput
  >;
}

export interface WarehouseLocationConstraintSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WarehouseLocationConstraintWhereInput>;
  AND?: Maybe<
    | WarehouseLocationConstraintSubscriptionWhereInput[]
    | WarehouseLocationConstraintSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WarehouseLocationConstraintSubscriptionWhereInput[]
    | WarehouseLocationConstraintSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WarehouseLocationConstraintSubscriptionWhereInput[]
    | WarehouseLocationConstraintSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ActiveAdminUser {
  id: ID_Output;
}

export interface ActiveAdminUserPromise
  extends Promise<ActiveAdminUser>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  admin: <T = UserPromise>() => T;
}

export interface ActiveAdminUserSubscription
  extends Promise<AsyncIterator<ActiveAdminUser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  admin: <T = UserSubscription>() => T;
}

export interface ActiveAdminUserNullablePromise
  extends Promise<ActiveAdminUser | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  admin: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  roles: UserRole[];
  pushNotificationStatus: PushNotificationStatus;
  sendSystemEmails: Boolean;
  verificationStatus: UserVerificationStatus;
  verificationMethod: UserVerificationMethod;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  auth0Id: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
  roles: () => Promise<UserRole[]>;
  pushNotificationStatus: () => Promise<PushNotificationStatus>;
  pushNotifications: <T = FragmentableArray<PushNotificationReceipt>>(args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emails: <T = FragmentableArray<EmailReceipt>>(args?: {
    where?: EmailReceiptWhereInput;
    orderBy?: EmailReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sendSystemEmails: () => Promise<Boolean>;
  pushNotification: <T = UserPushNotificationPromise>() => T;
  verificationStatus: () => Promise<UserVerificationStatus>;
  verificationMethod: () => Promise<UserVerificationMethod>;
  smsReceipts: <T = FragmentableArray<SmsReceipt>>(args?: {
    where?: SmsReceiptWhereInput;
    orderBy?: SmsReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fitPics: <T = FragmentableArray<FitPic>>(args?: {
    where?: FitPicWhereInput;
    orderBy?: FitPicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  auth0Id: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  roles: () => Promise<AsyncIterator<UserRole[]>>;
  pushNotificationStatus: () => Promise<AsyncIterator<PushNotificationStatus>>;
  pushNotifications: <
    T = Promise<AsyncIterator<PushNotificationReceiptSubscription>>
  >(args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emails: <T = Promise<AsyncIterator<EmailReceiptSubscription>>>(args?: {
    where?: EmailReceiptWhereInput;
    orderBy?: EmailReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sendSystemEmails: () => Promise<AsyncIterator<Boolean>>;
  pushNotification: <T = UserPushNotificationSubscription>() => T;
  verificationStatus: () => Promise<AsyncIterator<UserVerificationStatus>>;
  verificationMethod: () => Promise<AsyncIterator<UserVerificationMethod>>;
  smsReceipts: <T = Promise<AsyncIterator<SmsReceiptSubscription>>>(args?: {
    where?: SmsReceiptWhereInput;
    orderBy?: SmsReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fitPics: <T = Promise<AsyncIterator<FitPicSubscription>>>(args?: {
    where?: FitPicWhereInput;
    orderBy?: FitPicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  auth0Id: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
  roles: () => Promise<UserRole[]>;
  pushNotificationStatus: () => Promise<PushNotificationStatus>;
  pushNotifications: <T = FragmentableArray<PushNotificationReceipt>>(args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emails: <T = FragmentableArray<EmailReceipt>>(args?: {
    where?: EmailReceiptWhereInput;
    orderBy?: EmailReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sendSystemEmails: () => Promise<Boolean>;
  pushNotification: <T = UserPushNotificationPromise>() => T;
  verificationStatus: () => Promise<UserVerificationStatus>;
  verificationMethod: () => Promise<UserVerificationMethod>;
  smsReceipts: <T = FragmentableArray<SmsReceipt>>(args?: {
    where?: SmsReceiptWhereInput;
    orderBy?: SmsReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fitPics: <T = FragmentableArray<FitPic>>(args?: {
    where?: FitPicWhereInput;
    orderBy?: FitPicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PushNotificationReceipt {
  id: ID_Output;
  route?: String;
  screen?: String;
  uri?: String;
  interest?: String;
  body: String;
  title?: String;
  recordID?: String;
  recordSlug?: String;
  notificationKey?: String;
  sentAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PushNotificationReceiptPromise
  extends Promise<PushNotificationReceipt>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  route: () => Promise<String>;
  screen: () => Promise<String>;
  uri: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interest: () => Promise<String>;
  body: () => Promise<String>;
  title: () => Promise<String>;
  recordID: () => Promise<String>;
  recordSlug: () => Promise<String>;
  notificationKey: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PushNotificationReceiptSubscription
  extends Promise<AsyncIterator<PushNotificationReceipt>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  route: () => Promise<AsyncIterator<String>>;
  screen: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interest: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  recordID: () => Promise<AsyncIterator<String>>;
  recordSlug: () => Promise<AsyncIterator<String>>;
  notificationKey: () => Promise<AsyncIterator<String>>;
  sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PushNotificationReceiptNullablePromise
  extends Promise<PushNotificationReceipt | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  route: () => Promise<String>;
  screen: () => Promise<String>;
  uri: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interest: () => Promise<String>;
  body: () => Promise<String>;
  title: () => Promise<String>;
  recordID: () => Promise<String>;
  recordSlug: () => Promise<String>;
  notificationKey: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmailReceipt {
  id: ID_Output;
  emailId: EmailId;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmailReceiptPromise
  extends Promise<EmailReceipt>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  emailId: () => Promise<EmailId>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmailReceiptSubscription
  extends Promise<AsyncIterator<EmailReceipt>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  emailId: () => Promise<AsyncIterator<EmailId>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmailReceiptNullablePromise
  extends Promise<EmailReceipt | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  emailId: () => Promise<EmailId>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPushNotification {
  id: ID_Output;
  status: Boolean;
}

export interface UserPushNotificationPromise
  extends Promise<UserPushNotification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  interests: <T = FragmentableArray<UserPushNotificationInterest>>(args?: {
    where?: UserPushNotificationInterestWhereInput;
    orderBy?: UserPushNotificationInterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<Boolean>;
  history: <T = FragmentableArray<PushNotificationReceipt>>(args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserPushNotificationSubscription
  extends Promise<AsyncIterator<UserPushNotification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  interests: <
    T = Promise<AsyncIterator<UserPushNotificationInterestSubscription>>
  >(args?: {
    where?: UserPushNotificationInterestWhereInput;
    orderBy?: UserPushNotificationInterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<Boolean>>;
  history: <
    T = Promise<AsyncIterator<PushNotificationReceiptSubscription>>
  >(args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserPushNotificationNullablePromise
  extends Promise<UserPushNotification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  interests: <T = FragmentableArray<UserPushNotificationInterest>>(args?: {
    where?: UserPushNotificationInterestWhereInput;
    orderBy?: UserPushNotificationInterestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<Boolean>;
  history: <T = FragmentableArray<PushNotificationReceipt>>(args?: {
    where?: PushNotificationReceiptWhereInput;
    orderBy?: PushNotificationReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserPushNotificationInterest {
  id: ID_Output;
  type: UserPushNotificationInterestType;
  value: String;
  status: Boolean;
}

export interface UserPushNotificationInterestPromise
  extends Promise<UserPushNotificationInterest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<UserPushNotificationInterestType>;
  value: () => Promise<String>;
  user: <T = UserPromise>() => T;
  status: () => Promise<Boolean>;
}

export interface UserPushNotificationInterestSubscription
  extends Promise<AsyncIterator<UserPushNotificationInterest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<UserPushNotificationInterestType>>;
  value: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserPushNotificationInterestNullablePromise
  extends Promise<UserPushNotificationInterest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<UserPushNotificationInterestType>;
  value: () => Promise<String>;
  user: <T = UserPromise>() => T;
  status: () => Promise<Boolean>;
}

export interface SmsReceipt {
  id: ID_Output;
  externalId?: String;
  body: String;
  mediaUrls: String[];
  status: SmsStatus;
  smsId?: String;
  sentAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SmsReceiptPromise extends Promise<SmsReceipt>, Fragmentable {
  id: () => Promise<ID_Output>;
  externalId: () => Promise<String>;
  body: () => Promise<String>;
  mediaUrls: () => Promise<String[]>;
  status: () => Promise<SmsStatus>;
  smsId: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SmsReceiptSubscription
  extends Promise<AsyncIterator<SmsReceipt>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  externalId: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  mediaUrls: () => Promise<AsyncIterator<String[]>>;
  status: () => Promise<AsyncIterator<SmsStatus>>;
  smsId: () => Promise<AsyncIterator<String>>;
  sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SmsReceiptNullablePromise
  extends Promise<SmsReceipt | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  externalId: () => Promise<String>;
  body: () => Promise<String>;
  mediaUrls: () => Promise<String[]>;
  status: () => Promise<SmsStatus>;
  smsId: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FitPic {
  id: ID_Output;
  includeInstagramHandle: Boolean;
  status: FitPicStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FitPicPromise extends Promise<FitPic>, Fragmentable {
  id: () => Promise<ID_Output>;
  image: <T = ImagePromise>() => T;
  includeInstagramHandle: () => Promise<Boolean>;
  location: <T = LocationPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<FitPicReport>>(args?: {
    where?: FitPicReportWhereInput;
    orderBy?: FitPicReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<FitPicStatus>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FitPicSubscription
  extends Promise<AsyncIterator<FitPic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: <T = ImageSubscription>() => T;
  includeInstagramHandle: () => Promise<AsyncIterator<Boolean>>;
  location: <T = LocationSubscription>() => T;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = Promise<AsyncIterator<FitPicReportSubscription>>>(args?: {
    where?: FitPicReportWhereInput;
    orderBy?: FitPicReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<FitPicStatus>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FitPicNullablePromise
  extends Promise<FitPic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: <T = ImagePromise>() => T;
  includeInstagramHandle: () => Promise<Boolean>;
  location: <T = LocationPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<FitPicReport>>(args?: {
    where?: FitPicReportWhereInput;
    orderBy?: FitPicReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<FitPicStatus>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Image {
  id: ID_Output;
  caption?: String;
  url: String;
  height?: Int;
  width?: Int;
  title?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  url: () => Promise<String>;
  height: () => Promise<Int>;
  width: () => Promise<Int>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  height: () => Promise<AsyncIterator<Int>>;
  width: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  url: () => Promise<String>;
  height: () => Promise<Int>;
  width: () => Promise<Int>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Location {
  id: ID_Output;
  slug?: String;
  name?: String;
  company?: String;
  description?: String;
  address1?: String;
  address2?: String;
  city?: String;
  country?: String;
  state?: String;
  zipCode: String;
  locationType?: LocationType;
  lat?: Float;
  lng?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  country: () => Promise<String>;
  state: () => Promise<String>;
  zipCode: () => Promise<String>;
  locationType: () => Promise<LocationType>;
  user: <T = UserPromise>() => T;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shippingOptions: <T = FragmentableArray<ShippingOption>>(args?: {
    where?: ShippingOptionWhereInput;
    orderBy?: ShippingOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  locationType: () => Promise<AsyncIterator<LocationType>>;
  user: <T = UserSubscription>() => T;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  physicalProducts: <
    T = Promise<AsyncIterator<PhysicalProductSubscription>>
  >(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shippingOptions: <
    T = Promise<AsyncIterator<ShippingOptionSubscription>>
  >(args?: {
    where?: ShippingOptionWhereInput;
    orderBy?: ShippingOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LocationNullablePromise
  extends Promise<Location | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  country: () => Promise<String>;
  state: () => Promise<String>;
  zipCode: () => Promise<String>;
  locationType: () => Promise<LocationType>;
  user: <T = UserPromise>() => T;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shippingOptions: <T = FragmentableArray<ShippingOption>>(args?: {
    where?: ShippingOptionWhereInput;
    orderBy?: ShippingOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProduct {
  id: ID_Output;
  seasonsUID: String;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  offloadMethod?: PhysicalProductOffloadMethod;
  offloadNotes?: String;
  sequenceNumber: Int;
  barcoded?: Boolean;
  dateOrdered?: DateTimeOutput;
  dateReceived?: DateTimeOutput;
  unitCost?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhysicalProductPromise
  extends Promise<PhysicalProduct>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seasonsUID: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  inventoryStatus: () => Promise<InventoryStatus>;
  productStatus: () => Promise<PhysicalProductStatus>;
  offloadMethod: () => Promise<PhysicalProductOffloadMethod>;
  offloadNotes: () => Promise<String>;
  sequenceNumber: () => Promise<Int>;
  warehouseLocation: <T = WarehouseLocationPromise>() => T;
  barcoded: () => Promise<Boolean>;
  dateOrdered: () => Promise<DateTimeOutput>;
  dateReceived: () => Promise<DateTimeOutput>;
  unitCost: () => Promise<Float>;
  price: <T = PhysicalProductPricePromise>() => T;
  reports: <T = FragmentableArray<PhysicalProductQualityReport>>(args?: {
    where?: PhysicalProductQualityReportWhereInput;
    orderBy?: PhysicalProductQualityReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProductSubscription
  extends Promise<AsyncIterator<PhysicalProduct>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seasonsUID: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  productVariant: <T = ProductVariantSubscription>() => T;
  inventoryStatus: () => Promise<AsyncIterator<InventoryStatus>>;
  productStatus: () => Promise<AsyncIterator<PhysicalProductStatus>>;
  offloadMethod: () => Promise<AsyncIterator<PhysicalProductOffloadMethod>>;
  offloadNotes: () => Promise<AsyncIterator<String>>;
  sequenceNumber: () => Promise<AsyncIterator<Int>>;
  warehouseLocation: <T = WarehouseLocationSubscription>() => T;
  barcoded: () => Promise<AsyncIterator<Boolean>>;
  dateOrdered: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateReceived: () => Promise<AsyncIterator<DateTimeOutput>>;
  unitCost: () => Promise<AsyncIterator<Float>>;
  price: <T = PhysicalProductPriceSubscription>() => T;
  reports: <
    T = Promise<AsyncIterator<PhysicalProductQualityReportSubscription>>
  >(args?: {
    where?: PhysicalProductQualityReportWhereInput;
    orderBy?: PhysicalProductQualityReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PhysicalProductNullablePromise
  extends Promise<PhysicalProduct | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seasonsUID: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  inventoryStatus: () => Promise<InventoryStatus>;
  productStatus: () => Promise<PhysicalProductStatus>;
  offloadMethod: () => Promise<PhysicalProductOffloadMethod>;
  offloadNotes: () => Promise<String>;
  sequenceNumber: () => Promise<Int>;
  warehouseLocation: <T = WarehouseLocationPromise>() => T;
  barcoded: () => Promise<Boolean>;
  dateOrdered: () => Promise<DateTimeOutput>;
  dateReceived: () => Promise<DateTimeOutput>;
  unitCost: () => Promise<Float>;
  price: <T = PhysicalProductPricePromise>() => T;
  reports: <T = FragmentableArray<PhysicalProductQualityReport>>(args?: {
    where?: PhysicalProductQualityReportWhereInput;
    orderBy?: PhysicalProductQualityReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariant {
  id: ID_Output;
  sku?: String;
  displayShort: String;
  weight?: Float;
  height?: Float;
  productID: String;
  retailPrice?: Float;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  offloaded: Int;
  stored: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductVariantPromise
  extends Promise<ProductVariant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sku: () => Promise<String>;
  displayShort: () => Promise<String>;
  color: <T = ColorPromise>() => T;
  internalSize: <T = SizePromise>() => T;
  manufacturerSizes: <T = FragmentableArray<Size>>(args?: {
    where?: SizeWhereInput;
    orderBy?: SizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  productID: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  retailPrice: () => Promise<Float>;
  price: <T = ProductVariantPricePromise>() => T;
  shopifyProductVariant: <T = ShopifyProductVariantPromise>() => T;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Int>;
  reservable: () => Promise<Int>;
  reserved: () => Promise<Int>;
  nonReservable: () => Promise<Int>;
  offloaded: () => Promise<Int>;
  stored: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantSubscription
  extends Promise<AsyncIterator<ProductVariant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sku: () => Promise<AsyncIterator<String>>;
  displayShort: () => Promise<AsyncIterator<String>>;
  color: <T = ColorSubscription>() => T;
  internalSize: <T = SizeSubscription>() => T;
  manufacturerSizes: <T = Promise<AsyncIterator<SizeSubscription>>>(args?: {
    where?: SizeWhereInput;
    orderBy?: SizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weight: () => Promise<AsyncIterator<Float>>;
  height: () => Promise<AsyncIterator<Float>>;
  productID: () => Promise<AsyncIterator<String>>;
  product: <T = ProductSubscription>() => T;
  retailPrice: () => Promise<AsyncIterator<Float>>;
  price: <T = ProductVariantPriceSubscription>() => T;
  shopifyProductVariant: <T = ShopifyProductVariantSubscription>() => T;
  physicalProducts: <
    T = Promise<AsyncIterator<PhysicalProductSubscription>>
  >(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<AsyncIterator<Int>>;
  reservable: () => Promise<AsyncIterator<Int>>;
  reserved: () => Promise<AsyncIterator<Int>>;
  nonReservable: () => Promise<AsyncIterator<Int>>;
  offloaded: () => Promise<AsyncIterator<Int>>;
  stored: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductVariantNullablePromise
  extends Promise<ProductVariant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sku: () => Promise<String>;
  displayShort: () => Promise<String>;
  color: <T = ColorPromise>() => T;
  internalSize: <T = SizePromise>() => T;
  manufacturerSizes: <T = FragmentableArray<Size>>(args?: {
    where?: SizeWhereInput;
    orderBy?: SizeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  productID: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  retailPrice: () => Promise<Float>;
  price: <T = ProductVariantPricePromise>() => T;
  shopifyProductVariant: <T = ShopifyProductVariantPromise>() => T;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Int>;
  reservable: () => Promise<Int>;
  reserved: () => Promise<Int>;
  nonReservable: () => Promise<Int>;
  offloaded: () => Promise<Int>;
  stored: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Color {
  id: ID_Output;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
}

export interface ColorPromise extends Promise<Color>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  colorCode: () => Promise<String>;
  hexCode: () => Promise<String>;
  productVariants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ColorSubscription
  extends Promise<AsyncIterator<Color>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  colorCode: () => Promise<AsyncIterator<String>>;
  hexCode: () => Promise<AsyncIterator<String>>;
  productVariants: <
    T = Promise<AsyncIterator<ProductVariantSubscription>>
  >(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ColorNullablePromise
  extends Promise<Color | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  colorCode: () => Promise<String>;
  hexCode: () => Promise<String>;
  productVariants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Size {
  id: ID_Output;
  slug: String;
  productType?: ProductType;
  display: String;
}

export interface SizePromise extends Promise<Size>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  productType: () => Promise<ProductType>;
  top: <T = TopSizePromise>() => T;
  bottom: <T = BottomSizePromise>() => T;
  display: () => Promise<String>;
}

export interface SizeSubscription
  extends Promise<AsyncIterator<Size>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  productType: () => Promise<AsyncIterator<ProductType>>;
  top: <T = TopSizeSubscription>() => T;
  bottom: <T = BottomSizeSubscription>() => T;
  display: () => Promise<AsyncIterator<String>>;
}

export interface SizeNullablePromise
  extends Promise<Size | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  productType: () => Promise<ProductType>;
  top: <T = TopSizePromise>() => T;
  bottom: <T = BottomSizePromise>() => T;
  display: () => Promise<String>;
}

export interface TopSize {
  id: ID_Output;
  letter?: LetterSize;
  sleeve?: Float;
  shoulder?: Float;
  chest?: Float;
  neck?: Float;
  length?: Float;
}

export interface TopSizePromise extends Promise<TopSize>, Fragmentable {
  id: () => Promise<ID_Output>;
  letter: () => Promise<LetterSize>;
  sleeve: () => Promise<Float>;
  shoulder: () => Promise<Float>;
  chest: () => Promise<Float>;
  neck: () => Promise<Float>;
  length: () => Promise<Float>;
}

export interface TopSizeSubscription
  extends Promise<AsyncIterator<TopSize>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  letter: () => Promise<AsyncIterator<LetterSize>>;
  sleeve: () => Promise<AsyncIterator<Float>>;
  shoulder: () => Promise<AsyncIterator<Float>>;
  chest: () => Promise<AsyncIterator<Float>>;
  neck: () => Promise<AsyncIterator<Float>>;
  length: () => Promise<AsyncIterator<Float>>;
}

export interface TopSizeNullablePromise
  extends Promise<TopSize | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  letter: () => Promise<LetterSize>;
  sleeve: () => Promise<Float>;
  shoulder: () => Promise<Float>;
  chest: () => Promise<Float>;
  neck: () => Promise<Float>;
  length: () => Promise<Float>;
}

export interface BottomSize {
  id: ID_Output;
  type?: BottomSizeType;
  value?: String;
  waist?: Float;
  rise?: Float;
  hem?: Float;
  inseam?: Float;
}

export interface BottomSizePromise extends Promise<BottomSize>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<BottomSizeType>;
  value: () => Promise<String>;
  waist: () => Promise<Float>;
  rise: () => Promise<Float>;
  hem: () => Promise<Float>;
  inseam: () => Promise<Float>;
}

export interface BottomSizeSubscription
  extends Promise<AsyncIterator<BottomSize>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<BottomSizeType>>;
  value: () => Promise<AsyncIterator<String>>;
  waist: () => Promise<AsyncIterator<Float>>;
  rise: () => Promise<AsyncIterator<Float>>;
  hem: () => Promise<AsyncIterator<Float>>;
  inseam: () => Promise<AsyncIterator<Float>>;
}

export interface BottomSizeNullablePromise
  extends Promise<BottomSize | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<BottomSizeType>;
  value: () => Promise<String>;
  waist: () => Promise<Float>;
  rise: () => Promise<Float>;
  hem: () => Promise<Float>;
  inseam: () => Promise<Float>;
}

export interface Product {
  id: ID_Output;
  architecture?: ProductArchitecture;
  description?: String;
  externalURL?: String;
  buyNewEnabled: Boolean;
  innerMaterials: String[];
  modelHeight?: Int;
  name: String;
  outerMaterials: String[];
  photographyStatus?: PhotographyStatus;
  productFit?: ProductFit;
  publishedAt?: DateTimeOutput;
  retailPrice?: Int;
  slug: String;
  status?: ProductStatus;
  type?: ProductType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  architecture: () => Promise<ProductArchitecture>;
  brand: <T = BrandPromise>() => T;
  category: <T = CategoryPromise>() => T;
  color: <T = ColorPromise>() => T;
  description: () => Promise<String>;
  externalURL: () => Promise<String>;
  functions: <T = FragmentableArray<ProductFunction>>(args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  buyNewEnabled: () => Promise<Boolean>;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  innerMaterials: () => Promise<String[]>;
  materialCategory: <T = ProductMaterialCategoryPromise>() => T;
  model: <T = ProductModelPromise>() => T;
  modelHeight: () => Promise<Int>;
  modelSize: <T = SizePromise>() => T;
  name: () => Promise<String>;
  outerMaterials: () => Promise<String[]>;
  photographyStatus: () => Promise<PhotographyStatus>;
  productFit: () => Promise<ProductFit>;
  publishedAt: () => Promise<DateTimeOutput>;
  retailPrice: () => Promise<Int>;
  season: <T = ProductSeasonPromise>() => T;
  secondaryColor: <T = ColorPromise>() => T;
  slug: () => Promise<String>;
  status: () => Promise<ProductStatus>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tier: <T = ProductTierPromise>() => T;
  type: () => Promise<ProductType>;
  variants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  architecture: () => Promise<AsyncIterator<ProductArchitecture>>;
  brand: <T = BrandSubscription>() => T;
  category: <T = CategorySubscription>() => T;
  color: <T = ColorSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  externalURL: () => Promise<AsyncIterator<String>>;
  functions: <T = Promise<AsyncIterator<ProductFunctionSubscription>>>(args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  buyNewEnabled: () => Promise<AsyncIterator<Boolean>>;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  innerMaterials: () => Promise<AsyncIterator<String[]>>;
  materialCategory: <T = ProductMaterialCategorySubscription>() => T;
  model: <T = ProductModelSubscription>() => T;
  modelHeight: () => Promise<AsyncIterator<Int>>;
  modelSize: <T = SizeSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  outerMaterials: () => Promise<AsyncIterator<String[]>>;
  photographyStatus: () => Promise<AsyncIterator<PhotographyStatus>>;
  productFit: () => Promise<AsyncIterator<ProductFit>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  retailPrice: () => Promise<AsyncIterator<Int>>;
  season: <T = ProductSeasonSubscription>() => T;
  secondaryColor: <T = ColorSubscription>() => T;
  slug: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<ProductStatus>>;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tier: <T = ProductTierSubscription>() => T;
  type: () => Promise<AsyncIterator<ProductType>>;
  variants: <T = Promise<AsyncIterator<ProductVariantSubscription>>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  architecture: () => Promise<ProductArchitecture>;
  brand: <T = BrandPromise>() => T;
  category: <T = CategoryPromise>() => T;
  color: <T = ColorPromise>() => T;
  description: () => Promise<String>;
  externalURL: () => Promise<String>;
  functions: <T = FragmentableArray<ProductFunction>>(args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  buyNewEnabled: () => Promise<Boolean>;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  innerMaterials: () => Promise<String[]>;
  materialCategory: <T = ProductMaterialCategoryPromise>() => T;
  model: <T = ProductModelPromise>() => T;
  modelHeight: () => Promise<Int>;
  modelSize: <T = SizePromise>() => T;
  name: () => Promise<String>;
  outerMaterials: () => Promise<String[]>;
  photographyStatus: () => Promise<PhotographyStatus>;
  productFit: () => Promise<ProductFit>;
  publishedAt: () => Promise<DateTimeOutput>;
  retailPrice: () => Promise<Int>;
  season: <T = ProductSeasonPromise>() => T;
  secondaryColor: <T = ColorPromise>() => T;
  slug: () => Promise<String>;
  status: () => Promise<ProductStatus>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tier: <T = ProductTierPromise>() => T;
  type: () => Promise<ProductType>;
  variants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Brand {
  id: ID_Output;
  slug: String;
  brandCode: String;
  description?: String;
  isPrimaryBrand: Boolean;
  logo?: Json;
  name: String;
  designer?: String;
  basedIn?: String;
  since?: DateTimeOutput;
  tier: BrandTier;
  published: Boolean;
  featured: Boolean;
  websiteUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BrandPromise extends Promise<Brand>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  brandCode: () => Promise<String>;
  description: () => Promise<String>;
  isPrimaryBrand: () => Promise<Boolean>;
  logo: () => Promise<Json>;
  name: () => Promise<String>;
  designer: () => Promise<String>;
  basedIn: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  since: () => Promise<DateTimeOutput>;
  tier: () => Promise<BrandTier>;
  published: () => Promise<Boolean>;
  featured: () => Promise<Boolean>;
  websiteUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  externalShopifyIntegration: <T = ExternalShopifyIntegrationPromise>() => T;
}

export interface BrandSubscription
  extends Promise<AsyncIterator<Brand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  brandCode: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isPrimaryBrand: () => Promise<AsyncIterator<Boolean>>;
  logo: () => Promise<AsyncIterator<Json>>;
  name: () => Promise<AsyncIterator<String>>;
  designer: () => Promise<AsyncIterator<String>>;
  basedIn: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  since: () => Promise<AsyncIterator<DateTimeOutput>>;
  tier: () => Promise<AsyncIterator<BrandTier>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  websiteUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  externalShopifyIntegration: <
    T = ExternalShopifyIntegrationSubscription
  >() => T;
}

export interface BrandNullablePromise
  extends Promise<Brand | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  brandCode: () => Promise<String>;
  description: () => Promise<String>;
  isPrimaryBrand: () => Promise<Boolean>;
  logo: () => Promise<Json>;
  name: () => Promise<String>;
  designer: () => Promise<String>;
  basedIn: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  since: () => Promise<DateTimeOutput>;
  tier: () => Promise<BrandTier>;
  published: () => Promise<Boolean>;
  featured: () => Promise<Boolean>;
  websiteUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  externalShopifyIntegration: <T = ExternalShopifyIntegrationPromise>() => T;
}

export interface ExternalShopifyIntegration {
  id: ID_Output;
  shopName: String;
  enabled: Boolean;
  accessToken?: String;
  nonce?: String;
}

export interface ExternalShopifyIntegrationPromise
  extends Promise<ExternalShopifyIntegration>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  shopName: () => Promise<String>;
  enabled: () => Promise<Boolean>;
  accessToken: () => Promise<String>;
  nonce: () => Promise<String>;
}

export interface ExternalShopifyIntegrationSubscription
  extends Promise<AsyncIterator<ExternalShopifyIntegration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  shopName: () => Promise<AsyncIterator<String>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  nonce: () => Promise<AsyncIterator<String>>;
}

export interface ExternalShopifyIntegrationNullablePromise
  extends Promise<ExternalShopifyIntegration | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  shopName: () => Promise<String>;
  enabled: () => Promise<Boolean>;
  accessToken: () => Promise<String>;
  nonce: () => Promise<String>;
}

export interface Category {
  id: ID_Output;
  slug: String;
  name: String;
  image?: Json;
  description?: String;
  visible: Boolean;
  updatedAt?: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<Json>;
  description: () => Promise<String>;
  visible: () => Promise<Boolean>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<Json>>;
  description: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<Json>;
  description: () => Promise<String>;
  visible: () => Promise<Boolean>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductFunction {
  id: ID_Output;
  name?: String;
}

export interface ProductFunctionPromise
  extends Promise<ProductFunction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductFunctionSubscription
  extends Promise<AsyncIterator<ProductFunction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductFunctionNullablePromise
  extends Promise<ProductFunction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductMaterialCategory {
  id: ID_Output;
  slug: String;
  lifeExpectancy: Float;
}

export interface ProductMaterialCategoryPromise
  extends Promise<ProductMaterialCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  lifeExpectancy: () => Promise<Float>;
  category: <T = CategoryPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductMaterialCategorySubscription
  extends Promise<AsyncIterator<ProductMaterialCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  lifeExpectancy: () => Promise<AsyncIterator<Float>>;
  category: <T = CategorySubscription>() => T;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductMaterialCategoryNullablePromise
  extends Promise<ProductMaterialCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  lifeExpectancy: () => Promise<Float>;
  category: <T = CategoryPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductModel {
  id: ID_Output;
  name: String;
  height: Float;
}

export interface ProductModelPromise
  extends Promise<ProductModel>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  height: () => Promise<Float>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductModelSubscription
  extends Promise<AsyncIterator<ProductModel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  height: () => Promise<AsyncIterator<Float>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductModelNullablePromise
  extends Promise<ProductModel | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  height: () => Promise<Float>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductSeason {
  id: ID_Output;
  wearableSeasons: SeasonString[];
}

export interface ProductSeasonPromise
  extends Promise<ProductSeason>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  vendorSeason: <T = SeasonPromise>() => T;
  internalSeason: <T = SeasonPromise>() => T;
  wearableSeasons: () => Promise<SeasonString[]>;
}

export interface ProductSeasonSubscription
  extends Promise<AsyncIterator<ProductSeason>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vendorSeason: <T = SeasonSubscription>() => T;
  internalSeason: <T = SeasonSubscription>() => T;
  wearableSeasons: () => Promise<AsyncIterator<SeasonString[]>>;
}

export interface ProductSeasonNullablePromise
  extends Promise<ProductSeason | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  vendorSeason: <T = SeasonPromise>() => T;
  internalSeason: <T = SeasonPromise>() => T;
  wearableSeasons: () => Promise<SeasonString[]>;
}

export interface Season {
  id: ID_Output;
  year?: Int;
  seasonCode?: SeasonCode;
}

export interface SeasonPromise extends Promise<Season>, Fragmentable {
  id: () => Promise<ID_Output>;
  year: () => Promise<Int>;
  seasonCode: () => Promise<SeasonCode>;
}

export interface SeasonSubscription
  extends Promise<AsyncIterator<Season>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  year: () => Promise<AsyncIterator<Int>>;
  seasonCode: () => Promise<AsyncIterator<SeasonCode>>;
}

export interface SeasonNullablePromise
  extends Promise<Season | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  year: () => Promise<Int>;
  seasonCode: () => Promise<SeasonCode>;
}

export interface Tag {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductTier {
  id: ID_Output;
  tier: ProductTierName;
  price: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductTierPromise extends Promise<ProductTier>, Fragmentable {
  id: () => Promise<ID_Output>;
  tier: () => Promise<ProductTierName>;
  price: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductTierSubscription
  extends Promise<AsyncIterator<ProductTier>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tier: () => Promise<AsyncIterator<ProductTierName>>;
  price: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductTierNullablePromise
  extends Promise<ProductTier | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tier: () => Promise<ProductTierName>;
  price: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantPrice {
  id: ID_Output;
  retailPrice?: Float;
}

export interface ProductVariantPricePromise
  extends Promise<ProductVariantPrice>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  retailPrice: () => Promise<Float>;
}

export interface ProductVariantPriceSubscription
  extends Promise<AsyncIterator<ProductVariantPrice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  retailPrice: () => Promise<AsyncIterator<Float>>;
}

export interface ProductVariantPriceNullablePromise
  extends Promise<ProductVariantPrice | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  retailPrice: () => Promise<Float>;
}

export interface ShopifyProductVariant {
  id: ID_Output;
  externalId?: String;
  cachedPrice?: Float;
  cachedAvailableForSale?: Boolean;
  cacheExpiresAt?: DateTimeOutput;
}

export interface ShopifyProductVariantPromise
  extends Promise<ShopifyProductVariant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  externalId: () => Promise<String>;
  cachedPrice: () => Promise<Float>;
  cachedAvailableForSale: () => Promise<Boolean>;
  cacheExpiresAt: () => Promise<DateTimeOutput>;
}

export interface ShopifyProductVariantSubscription
  extends Promise<AsyncIterator<ShopifyProductVariant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  externalId: () => Promise<AsyncIterator<String>>;
  cachedPrice: () => Promise<AsyncIterator<Float>>;
  cachedAvailableForSale: () => Promise<AsyncIterator<Boolean>>;
  cacheExpiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShopifyProductVariantNullablePromise
  extends Promise<ShopifyProductVariant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  externalId: () => Promise<String>;
  cachedPrice: () => Promise<Float>;
  cachedAvailableForSale: () => Promise<Boolean>;
  cacheExpiresAt: () => Promise<DateTimeOutput>;
}

export interface WarehouseLocation {
  id: ID_Output;
  type: WarehouseLocationType;
  barcode: String;
  locationCode: String;
  itemCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WarehouseLocationPromise
  extends Promise<WarehouseLocation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<WarehouseLocationType>;
  barcode: () => Promise<String>;
  locationCode: () => Promise<String>;
  itemCode: () => Promise<String>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  constraints: <T = FragmentableArray<WarehouseLocationConstraint>>(args?: {
    where?: WarehouseLocationConstraintWhereInput;
    orderBy?: WarehouseLocationConstraintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WarehouseLocationSubscription
  extends Promise<AsyncIterator<WarehouseLocation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<WarehouseLocationType>>;
  barcode: () => Promise<AsyncIterator<String>>;
  locationCode: () => Promise<AsyncIterator<String>>;
  itemCode: () => Promise<AsyncIterator<String>>;
  physicalProducts: <
    T = Promise<AsyncIterator<PhysicalProductSubscription>>
  >(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  constraints: <
    T = Promise<AsyncIterator<WarehouseLocationConstraintSubscription>>
  >(args?: {
    where?: WarehouseLocationConstraintWhereInput;
    orderBy?: WarehouseLocationConstraintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WarehouseLocationNullablePromise
  extends Promise<WarehouseLocation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<WarehouseLocationType>;
  barcode: () => Promise<String>;
  locationCode: () => Promise<String>;
  itemCode: () => Promise<String>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  constraints: <T = FragmentableArray<WarehouseLocationConstraint>>(args?: {
    where?: WarehouseLocationConstraintWhereInput;
    orderBy?: WarehouseLocationConstraintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WarehouseLocationConstraint {
  id: ID_Output;
  limit: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WarehouseLocationConstraintPromise
  extends Promise<WarehouseLocationConstraint>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = CategoryPromise>() => T;
  limit: () => Promise<Int>;
  locations: <T = FragmentableArray<WarehouseLocation>>(args?: {
    where?: WarehouseLocationWhereInput;
    orderBy?: WarehouseLocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WarehouseLocationConstraintSubscription
  extends Promise<AsyncIterator<WarehouseLocationConstraint>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: <T = CategorySubscription>() => T;
  limit: () => Promise<AsyncIterator<Int>>;
  locations: <
    T = Promise<AsyncIterator<WarehouseLocationSubscription>>
  >(args?: {
    where?: WarehouseLocationWhereInput;
    orderBy?: WarehouseLocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WarehouseLocationConstraintNullablePromise
  extends Promise<WarehouseLocationConstraint | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = CategoryPromise>() => T;
  limit: () => Promise<Int>;
  locations: <T = FragmentableArray<WarehouseLocation>>(args?: {
    where?: WarehouseLocationWhereInput;
    orderBy?: WarehouseLocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProductPrice {
  id: ID_Output;
  buyUsedEnabled: Boolean;
  buyUsedPrice?: Float;
}

export interface PhysicalProductPricePromise
  extends Promise<PhysicalProductPrice>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  buyUsedEnabled: () => Promise<Boolean>;
  buyUsedPrice: () => Promise<Float>;
}

export interface PhysicalProductPriceSubscription
  extends Promise<AsyncIterator<PhysicalProductPrice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  buyUsedEnabled: () => Promise<AsyncIterator<Boolean>>;
  buyUsedPrice: () => Promise<AsyncIterator<Float>>;
}

export interface PhysicalProductPriceNullablePromise
  extends Promise<PhysicalProductPrice | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  buyUsedEnabled: () => Promise<Boolean>;
  buyUsedPrice: () => Promise<Float>;
}

export interface PhysicalProductQualityReport {
  id: ID_Output;
  damageType?: PhysicalProductDamageType;
  notes?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhysicalProductQualityReportPromise
  extends Promise<PhysicalProductQualityReport>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  damageType: () => Promise<PhysicalProductDamageType>;
  notes: () => Promise<String>;
  physicalProduct: <T = PhysicalProductPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProductQualityReportSubscription
  extends Promise<AsyncIterator<PhysicalProductQualityReport>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  damageType: () => Promise<AsyncIterator<PhysicalProductDamageType>>;
  notes: () => Promise<AsyncIterator<String>>;
  physicalProduct: <T = PhysicalProductSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PhysicalProductQualityReportNullablePromise
  extends Promise<PhysicalProductQualityReport | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  damageType: () => Promise<PhysicalProductDamageType>;
  notes: () => Promise<String>;
  physicalProduct: <T = PhysicalProductPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShippingOption {
  id: ID_Output;
  externalCost?: Int;
  averageDuration?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShippingOptionPromise
  extends Promise<ShippingOption>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  origin: <T = LocationPromise>() => T;
  destination: <T = LocationPromise>() => T;
  shippingMethod: <T = ShippingMethodPromise>() => T;
  externalCost: () => Promise<Int>;
  averageDuration: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShippingOptionSubscription
  extends Promise<AsyncIterator<ShippingOption>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  origin: <T = LocationSubscription>() => T;
  destination: <T = LocationSubscription>() => T;
  shippingMethod: <T = ShippingMethodSubscription>() => T;
  externalCost: () => Promise<AsyncIterator<Int>>;
  averageDuration: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShippingOptionNullablePromise
  extends Promise<ShippingOption | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  origin: <T = LocationPromise>() => T;
  destination: <T = LocationPromise>() => T;
  shippingMethod: <T = ShippingMethodPromise>() => T;
  externalCost: () => Promise<Int>;
  averageDuration: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShippingMethod {
  id: ID_Output;
  code: ShippingCode;
  displayText: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShippingMethodPromise
  extends Promise<ShippingMethod>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<ShippingCode>;
  displayText: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShippingMethodSubscription
  extends Promise<AsyncIterator<ShippingMethod>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<ShippingCode>>;
  displayText: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShippingMethodNullablePromise
  extends Promise<ShippingMethod | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<ShippingCode>;
  displayText: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FitPicReport {
  id: ID_Output;
  status: FitPicReportStatus;
  reportedAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FitPicReportPromise
  extends Promise<FitPicReport>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reporter: <T = UserPromise>() => T;
  reported: <T = FitPicPromise>() => T;
  status: () => Promise<FitPicReportStatus>;
  reportedAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FitPicReportSubscription
  extends Promise<AsyncIterator<FitPicReport>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reporter: <T = UserSubscription>() => T;
  reported: <T = FitPicSubscription>() => T;
  status: () => Promise<AsyncIterator<FitPicReportStatus>>;
  reportedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FitPicReportNullablePromise
  extends Promise<FitPicReport | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reporter: <T = UserPromise>() => T;
  reported: <T = FitPicPromise>() => T;
  status: () => Promise<FitPicReportStatus>;
  reportedAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActiveAdminUserConnection {
  pageInfo: PageInfo;
  edges: ActiveAdminUserEdge[];
}

export interface ActiveAdminUserConnectionPromise
  extends Promise<ActiveAdminUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActiveAdminUserEdge>>() => T;
  aggregate: <T = AggregateActiveAdminUserPromise>() => T;
}

export interface ActiveAdminUserConnectionSubscription
  extends Promise<AsyncIterator<ActiveAdminUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActiveAdminUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActiveAdminUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActiveAdminUserEdge {
  node: ActiveAdminUser;
  cursor: String;
}

export interface ActiveAdminUserEdgePromise
  extends Promise<ActiveAdminUserEdge>,
    Fragmentable {
  node: <T = ActiveAdminUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActiveAdminUserEdgeSubscription
  extends Promise<AsyncIterator<ActiveAdminUserEdge>>,
    Fragmentable {
  node: <T = ActiveAdminUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActiveAdminUser {
  count: Int;
}

export interface AggregateActiveAdminUserPromise
  extends Promise<AggregateActiveAdminUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActiveAdminUserSubscription
  extends Promise<AsyncIterator<AggregateActiveAdminUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AdminActionLog {
  actionId: Int;
  entityId: String;
  tableName: String;
  triggeredAt: DateTimeOutput;
  action: AdminAction;
  rowData: Json;
  changedFields?: Json;
  statementOnly: Boolean;
}

export interface AdminActionLogPromise
  extends Promise<AdminActionLog>,
    Fragmentable {
  actionId: () => Promise<Int>;
  entityId: () => Promise<String>;
  tableName: () => Promise<String>;
  activeAdminUser: <T = UserPromise>() => T;
  triggeredAt: () => Promise<DateTimeOutput>;
  action: () => Promise<AdminAction>;
  rowData: () => Promise<Json>;
  changedFields: () => Promise<Json>;
  statementOnly: () => Promise<Boolean>;
}

export interface AdminActionLogSubscription
  extends Promise<AsyncIterator<AdminActionLog>>,
    Fragmentable {
  actionId: () => Promise<AsyncIterator<Int>>;
  entityId: () => Promise<AsyncIterator<String>>;
  tableName: () => Promise<AsyncIterator<String>>;
  activeAdminUser: <T = UserSubscription>() => T;
  triggeredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<AdminAction>>;
  rowData: () => Promise<AsyncIterator<Json>>;
  changedFields: () => Promise<AsyncIterator<Json>>;
  statementOnly: () => Promise<AsyncIterator<Boolean>>;
}

export interface AdminActionLogNullablePromise
  extends Promise<AdminActionLog | null>,
    Fragmentable {
  actionId: () => Promise<Int>;
  entityId: () => Promise<String>;
  tableName: () => Promise<String>;
  activeAdminUser: <T = UserPromise>() => T;
  triggeredAt: () => Promise<DateTimeOutput>;
  action: () => Promise<AdminAction>;
  rowData: () => Promise<Json>;
  changedFields: () => Promise<Json>;
  statementOnly: () => Promise<Boolean>;
}

export interface AdminActionLogConnection {
  pageInfo: PageInfo;
  edges: AdminActionLogEdge[];
}

export interface AdminActionLogConnectionPromise
  extends Promise<AdminActionLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdminActionLogEdge>>() => T;
  aggregate: <T = AggregateAdminActionLogPromise>() => T;
}

export interface AdminActionLogConnectionSubscription
  extends Promise<AsyncIterator<AdminActionLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdminActionLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdminActionLogSubscription>() => T;
}

export interface AdminActionLogEdge {
  node: AdminActionLog;
  cursor: String;
}

export interface AdminActionLogEdgePromise
  extends Promise<AdminActionLogEdge>,
    Fragmentable {
  node: <T = AdminActionLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdminActionLogEdgeSubscription
  extends Promise<AsyncIterator<AdminActionLogEdge>>,
    Fragmentable {
  node: <T = AdminActionLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdminActionLog {
  count: Int;
}

export interface AggregateAdminActionLogPromise
  extends Promise<AggregateAdminActionLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdminActionLogSubscription
  extends Promise<AsyncIterator<AggregateAdminActionLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BagItem {
  id: ID_Output;
  position?: Int;
  saved?: Boolean;
  status: BagItemStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BagItemPromise extends Promise<BagItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  position: () => Promise<Int>;
  saved: () => Promise<Boolean>;
  status: () => Promise<BagItemStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BagItemSubscription
  extends Promise<AsyncIterator<BagItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  productVariant: <T = ProductVariantSubscription>() => T;
  position: () => Promise<AsyncIterator<Int>>;
  saved: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<BagItemStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BagItemNullablePromise
  extends Promise<BagItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  position: () => Promise<Int>;
  saved: () => Promise<Boolean>;
  status: () => Promise<BagItemStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Customer {
  id: ID_Output;
  status?: CustomerStatus;
  plan?: Plan;
  referralLink?: String;
  referrerId?: String;
  authorizedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  status: () => Promise<CustomerStatus>;
  detail: <T = CustomerDetailPromise>() => T;
  billingInfo: <T = BillingInfoPromise>() => T;
  plan: () => Promise<Plan>;
  membership: <T = CustomerMembershipPromise>() => T;
  bagItems: <T = FragmentableArray<BagItem>>(args?: {
    where?: BagItemWhereInput;
    orderBy?: BagItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  referralLink: () => Promise<String>;
  referrerId: () => Promise<String>;
  referrer: <T = CustomerPromise>() => T;
  referrees: <T = FragmentableArray<Customer>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailedProducts: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admissions: <T = CustomerAdmissionsDataPromise>() => T;
  authorizedAt: () => Promise<DateTimeOutput>;
  utm: <T = UTMDataPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<CustomerStatus>>;
  detail: <T = CustomerDetailSubscription>() => T;
  billingInfo: <T = BillingInfoSubscription>() => T;
  plan: () => Promise<AsyncIterator<Plan>>;
  membership: <T = CustomerMembershipSubscription>() => T;
  bagItems: <T = Promise<AsyncIterator<BagItemSubscription>>>(args?: {
    where?: BagItemWhereInput;
    orderBy?: BagItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservations: <T = Promise<AsyncIterator<ReservationSubscription>>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  referralLink: () => Promise<AsyncIterator<String>>;
  referrerId: () => Promise<AsyncIterator<String>>;
  referrer: <T = CustomerSubscription>() => T;
  referrees: <T = Promise<AsyncIterator<CustomerSubscription>>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailedProducts: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admissions: <T = CustomerAdmissionsDataSubscription>() => T;
  authorizedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  utm: <T = UTMDataSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  status: () => Promise<CustomerStatus>;
  detail: <T = CustomerDetailPromise>() => T;
  billingInfo: <T = BillingInfoPromise>() => T;
  plan: () => Promise<Plan>;
  membership: <T = CustomerMembershipPromise>() => T;
  bagItems: <T = FragmentableArray<BagItem>>(args?: {
    where?: BagItemWhereInput;
    orderBy?: BagItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  referralLink: () => Promise<String>;
  referrerId: () => Promise<String>;
  referrer: <T = CustomerPromise>() => T;
  referrees: <T = FragmentableArray<Customer>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailedProducts: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admissions: <T = CustomerAdmissionsDataPromise>() => T;
  authorizedAt: () => Promise<DateTimeOutput>;
  utm: <T = UTMDataPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerDetail {
  id: ID_Output;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  height?: Int;
  weight: Int[];
  bodyType?: String;
  averageTopSize?: String;
  topSizes: String[];
  averageWaistSize?: String;
  waistSizes: Int[];
  averagePantLength?: String;
  preferredPronouns?: String;
  profession?: String;
  partyFrequency?: String;
  travelFrequency?: String;
  shoppingFrequency?: String;
  averageSpend?: String;
  style?: String;
  commuteStyle?: String;
  phoneOS?: String;
  insureShipment: Boolean;
  instagramHandle?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerDetailPromise
  extends Promise<CustomerDetail>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  height: () => Promise<Int>;
  weight: () => Promise<Int[]>;
  bodyType: () => Promise<String>;
  averageTopSize: () => Promise<String>;
  topSizes: () => Promise<String[]>;
  averageWaistSize: () => Promise<String>;
  waistSizes: () => Promise<Int[]>;
  averagePantLength: () => Promise<String>;
  preferredPronouns: () => Promise<String>;
  profession: () => Promise<String>;
  partyFrequency: () => Promise<String>;
  travelFrequency: () => Promise<String>;
  shoppingFrequency: () => Promise<String>;
  averageSpend: () => Promise<String>;
  style: () => Promise<String>;
  commuteStyle: () => Promise<String>;
  stylePreferences: <T = StylePreferencesPromise>() => T;
  shippingAddress: <T = LocationPromise>() => T;
  phoneOS: () => Promise<String>;
  insureShipment: () => Promise<Boolean>;
  instagramHandle: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerDetailSubscription
  extends Promise<AsyncIterator<CustomerDetail>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  height: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<Int[]>>;
  bodyType: () => Promise<AsyncIterator<String>>;
  averageTopSize: () => Promise<AsyncIterator<String>>;
  topSizes: () => Promise<AsyncIterator<String[]>>;
  averageWaistSize: () => Promise<AsyncIterator<String>>;
  waistSizes: () => Promise<AsyncIterator<Int[]>>;
  averagePantLength: () => Promise<AsyncIterator<String>>;
  preferredPronouns: () => Promise<AsyncIterator<String>>;
  profession: () => Promise<AsyncIterator<String>>;
  partyFrequency: () => Promise<AsyncIterator<String>>;
  travelFrequency: () => Promise<AsyncIterator<String>>;
  shoppingFrequency: () => Promise<AsyncIterator<String>>;
  averageSpend: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  commuteStyle: () => Promise<AsyncIterator<String>>;
  stylePreferences: <T = StylePreferencesSubscription>() => T;
  shippingAddress: <T = LocationSubscription>() => T;
  phoneOS: () => Promise<AsyncIterator<String>>;
  insureShipment: () => Promise<AsyncIterator<Boolean>>;
  instagramHandle: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerDetailNullablePromise
  extends Promise<CustomerDetail | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  height: () => Promise<Int>;
  weight: () => Promise<Int[]>;
  bodyType: () => Promise<String>;
  averageTopSize: () => Promise<String>;
  topSizes: () => Promise<String[]>;
  averageWaistSize: () => Promise<String>;
  waistSizes: () => Promise<Int[]>;
  averagePantLength: () => Promise<String>;
  preferredPronouns: () => Promise<String>;
  profession: () => Promise<String>;
  partyFrequency: () => Promise<String>;
  travelFrequency: () => Promise<String>;
  shoppingFrequency: () => Promise<String>;
  averageSpend: () => Promise<String>;
  style: () => Promise<String>;
  commuteStyle: () => Promise<String>;
  stylePreferences: <T = StylePreferencesPromise>() => T;
  shippingAddress: <T = LocationPromise>() => T;
  phoneOS: () => Promise<String>;
  insureShipment: () => Promise<Boolean>;
  instagramHandle: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StylePreferences {
  id: ID_Output;
  styles: String[];
  patterns: String[];
  colors: String[];
  brands: String[];
}

export interface StylePreferencesPromise
  extends Promise<StylePreferences>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  styles: () => Promise<String[]>;
  patterns: () => Promise<String[]>;
  colors: () => Promise<String[]>;
  brands: () => Promise<String[]>;
}

export interface StylePreferencesSubscription
  extends Promise<AsyncIterator<StylePreferences>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  styles: () => Promise<AsyncIterator<String[]>>;
  patterns: () => Promise<AsyncIterator<String[]>>;
  colors: () => Promise<AsyncIterator<String[]>>;
  brands: () => Promise<AsyncIterator<String[]>>;
}

export interface StylePreferencesNullablePromise
  extends Promise<StylePreferences | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  styles: () => Promise<String[]>;
  patterns: () => Promise<String[]>;
  colors: () => Promise<String[]>;
  brands: () => Promise<String[]>;
}

export interface BillingInfo {
  id: ID_Output;
  brand: String;
  name?: String;
  last_digits: String;
  expiration_month: Int;
  expiration_year: Int;
  street1?: String;
  street2?: String;
  city?: String;
  state?: String;
  country?: String;
  postal_code?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BillingInfoPromise extends Promise<BillingInfo>, Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  name: () => Promise<String>;
  last_digits: () => Promise<String>;
  expiration_month: () => Promise<Int>;
  expiration_year: () => Promise<Int>;
  street1: () => Promise<String>;
  street2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postal_code: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BillingInfoSubscription
  extends Promise<AsyncIterator<BillingInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  last_digits: () => Promise<AsyncIterator<String>>;
  expiration_month: () => Promise<AsyncIterator<Int>>;
  expiration_year: () => Promise<AsyncIterator<Int>>;
  street1: () => Promise<AsyncIterator<String>>;
  street2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  postal_code: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BillingInfoNullablePromise
  extends Promise<BillingInfo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  name: () => Promise<String>;
  last_digits: () => Promise<String>;
  expiration_month: () => Promise<Int>;
  expiration_year: () => Promise<Int>;
  street1: () => Promise<String>;
  street2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postal_code: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerMembership {
  id: ID_Output;
  subscriptionId: String;
  giftId?: String;
}

export interface CustomerMembershipPromise
  extends Promise<CustomerMembership>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  plan: <T = PaymentPlanPromise>() => T;
  subscriptionId: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
  pauseRequests: <T = FragmentableArray<PauseRequest>>(args?: {
    where?: PauseRequestWhereInput;
    orderBy?: PauseRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  giftId: () => Promise<String>;
}

export interface CustomerMembershipSubscription
  extends Promise<AsyncIterator<CustomerMembership>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  plan: <T = PaymentPlanSubscription>() => T;
  subscriptionId: () => Promise<AsyncIterator<String>>;
  customer: <T = CustomerSubscription>() => T;
  pauseRequests: <T = Promise<AsyncIterator<PauseRequestSubscription>>>(args?: {
    where?: PauseRequestWhereInput;
    orderBy?: PauseRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  giftId: () => Promise<AsyncIterator<String>>;
}

export interface CustomerMembershipNullablePromise
  extends Promise<CustomerMembership | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  plan: <T = PaymentPlanPromise>() => T;
  subscriptionId: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
  pauseRequests: <T = FragmentableArray<PauseRequest>>(args?: {
    where?: PauseRequestWhereInput;
    orderBy?: PauseRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  giftId: () => Promise<String>;
}

export interface PaymentPlan {
  id: ID_Output;
  description?: String;
  planID: String;
  status?: String;
  name?: String;
  price?: Int;
  itemCount?: Int;
  tagline?: String;
  tier?: PaymentPlanTier;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PaymentPlanPromise extends Promise<PaymentPlan>, Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  planID: () => Promise<String>;
  status: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  itemCount: () => Promise<Int>;
  tagline: () => Promise<String>;
  tier: () => Promise<PaymentPlanTier>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PaymentPlanSubscription
  extends Promise<AsyncIterator<PaymentPlan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  planID: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  itemCount: () => Promise<AsyncIterator<Int>>;
  tagline: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<PaymentPlanTier>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaymentPlanNullablePromise
  extends Promise<PaymentPlan | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  planID: () => Promise<String>;
  status: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  itemCount: () => Promise<Int>;
  tagline: () => Promise<String>;
  tier: () => Promise<PaymentPlanTier>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PauseRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  pausePending: Boolean;
  pauseDate?: DateTimeOutput;
  resumeDate?: DateTimeOutput;
  notified: Boolean;
}

export interface PauseRequestPromise
  extends Promise<PauseRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  pausePending: () => Promise<Boolean>;
  pauseDate: () => Promise<DateTimeOutput>;
  resumeDate: () => Promise<DateTimeOutput>;
  notified: () => Promise<Boolean>;
  membership: <T = CustomerMembershipPromise>() => T;
}

export interface PauseRequestSubscription
  extends Promise<AsyncIterator<PauseRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  pausePending: () => Promise<AsyncIterator<Boolean>>;
  pauseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  resumeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  notified: () => Promise<AsyncIterator<Boolean>>;
  membership: <T = CustomerMembershipSubscription>() => T;
}

export interface PauseRequestNullablePromise
  extends Promise<PauseRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  pausePending: () => Promise<Boolean>;
  pauseDate: () => Promise<DateTimeOutput>;
  resumeDate: () => Promise<DateTimeOutput>;
  notified: () => Promise<Boolean>;
  membership: <T = CustomerMembershipPromise>() => T;
}

export interface Reservation {
  id: ID_Output;
  reservationNumber: Int;
  phase: ReservationPhase;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: DateTimeOutput;
  receivedAt?: DateTimeOutput;
  reminderSentAt?: DateTimeOutput;
  statusUpdatedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReservationPromise extends Promise<Reservation>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  sentPackage: <T = PackagePromise>() => T;
  returnedPackage: <T = PackagePromise>() => T;
  products: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  packageEvents: <T = FragmentableArray<PackageTransitEvent>>(args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationNumber: () => Promise<Int>;
  phase: () => Promise<ReservationPhase>;
  shipped: () => Promise<Boolean>;
  status: () => Promise<ReservationStatus>;
  shippedAt: () => Promise<DateTimeOutput>;
  receivedAt: () => Promise<DateTimeOutput>;
  reminderSentAt: () => Promise<DateTimeOutput>;
  statusUpdatedAt: () => Promise<DateTimeOutput>;
  receipt: <T = ReservationReceiptPromise>() => T;
  lastLocation: <T = LocationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  shippingOption: <T = ShippingOptionPromise>() => T;
}

export interface ReservationSubscription
  extends Promise<AsyncIterator<Reservation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  customer: <T = CustomerSubscription>() => T;
  sentPackage: <T = PackageSubscription>() => T;
  returnedPackage: <T = PackageSubscription>() => T;
  products: <T = Promise<AsyncIterator<PhysicalProductSubscription>>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  packageEvents: <
    T = Promise<AsyncIterator<PackageTransitEventSubscription>>
  >(args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationNumber: () => Promise<AsyncIterator<Int>>;
  phase: () => Promise<AsyncIterator<ReservationPhase>>;
  shipped: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<ReservationStatus>>;
  shippedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  receivedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  reminderSentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  statusUpdatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  receipt: <T = ReservationReceiptSubscription>() => T;
  lastLocation: <T = LocationSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  shippingOption: <T = ShippingOptionSubscription>() => T;
}

export interface ReservationNullablePromise
  extends Promise<Reservation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  sentPackage: <T = PackagePromise>() => T;
  returnedPackage: <T = PackagePromise>() => T;
  products: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  packageEvents: <T = FragmentableArray<PackageTransitEvent>>(args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationNumber: () => Promise<Int>;
  phase: () => Promise<ReservationPhase>;
  shipped: () => Promise<Boolean>;
  status: () => Promise<ReservationStatus>;
  shippedAt: () => Promise<DateTimeOutput>;
  receivedAt: () => Promise<DateTimeOutput>;
  reminderSentAt: () => Promise<DateTimeOutput>;
  statusUpdatedAt: () => Promise<DateTimeOutput>;
  receipt: <T = ReservationReceiptPromise>() => T;
  lastLocation: <T = LocationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  shippingOption: <T = ShippingOptionPromise>() => T;
}

export interface Package {
  id: ID_Output;
  transactionID: String;
  weight?: Float;
  cost?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PackagePromise extends Promise<Package>, Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactionID: () => Promise<String>;
  shippingLabel: <T = LabelPromise>() => T;
  fromAddress: <T = LocationPromise>() => T;
  toAddress: <T = LocationPromise>() => T;
  weight: () => Promise<Float>;
  cost: () => Promise<Int>;
  events: <T = FragmentableArray<PackageTransitEvent>>(args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PackageSubscription
  extends Promise<AsyncIterator<Package>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  items: <T = Promise<AsyncIterator<PhysicalProductSubscription>>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactionID: () => Promise<AsyncIterator<String>>;
  shippingLabel: <T = LabelSubscription>() => T;
  fromAddress: <T = LocationSubscription>() => T;
  toAddress: <T = LocationSubscription>() => T;
  weight: () => Promise<AsyncIterator<Float>>;
  cost: () => Promise<AsyncIterator<Int>>;
  events: <T = Promise<AsyncIterator<PackageTransitEventSubscription>>>(args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PackageNullablePromise
  extends Promise<Package | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactionID: () => Promise<String>;
  shippingLabel: <T = LabelPromise>() => T;
  fromAddress: <T = LocationPromise>() => T;
  toAddress: <T = LocationPromise>() => T;
  weight: () => Promise<Float>;
  cost: () => Promise<Int>;
  events: <T = FragmentableArray<PackageTransitEvent>>(args?: {
    where?: PackageTransitEventWhereInput;
    orderBy?: PackageTransitEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Label {
  id: ID_Output;
  name?: String;
  image?: String;
  trackingNumber?: String;
  trackingURL?: String;
}

export interface LabelPromise extends Promise<Label>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  trackingNumber: () => Promise<String>;
  trackingURL: () => Promise<String>;
}

export interface LabelSubscription
  extends Promise<AsyncIterator<Label>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  trackingNumber: () => Promise<AsyncIterator<String>>;
  trackingURL: () => Promise<AsyncIterator<String>>;
}

export interface LabelNullablePromise
  extends Promise<Label | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  trackingNumber: () => Promise<String>;
  trackingURL: () => Promise<String>;
}

export interface PackageTransitEvent {
  id: ID_Output;
  status: PackageTransitEventStatus;
  subStatus: PackageTransitEventSubStatus;
  data: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PackageTransitEventPromise
  extends Promise<PackageTransitEvent>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<PackageTransitEventStatus>;
  subStatus: () => Promise<PackageTransitEventSubStatus>;
  package: <T = PackagePromise>() => T;
  reservation: <T = ReservationPromise>() => T;
  data: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PackageTransitEventSubscription
  extends Promise<AsyncIterator<PackageTransitEvent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<PackageTransitEventStatus>>;
  subStatus: () => Promise<AsyncIterator<PackageTransitEventSubStatus>>;
  package: <T = PackageSubscription>() => T;
  reservation: <T = ReservationSubscription>() => T;
  data: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PackageTransitEventNullablePromise
  extends Promise<PackageTransitEvent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<PackageTransitEventStatus>;
  subStatus: () => Promise<PackageTransitEventSubStatus>;
  package: <T = PackagePromise>() => T;
  reservation: <T = ReservationPromise>() => T;
  data: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationReceipt {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReservationReceiptPromise
  extends Promise<ReservationReceipt>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reservation: <T = ReservationPromise>() => T;
  items: <T = FragmentableArray<ReservationReceiptItem>>(args?: {
    where?: ReservationReceiptItemWhereInput;
    orderBy?: ReservationReceiptItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationReceiptSubscription
  extends Promise<AsyncIterator<ReservationReceipt>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reservation: <T = ReservationSubscription>() => T;
  items: <
    T = Promise<AsyncIterator<ReservationReceiptItemSubscription>>
  >(args?: {
    where?: ReservationReceiptItemWhereInput;
    orderBy?: ReservationReceiptItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationReceiptNullablePromise
  extends Promise<ReservationReceipt | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reservation: <T = ReservationPromise>() => T;
  items: <T = FragmentableArray<ReservationReceiptItem>>(args?: {
    where?: ReservationReceiptItemWhereInput;
    orderBy?: ReservationReceiptItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationReceiptItem {
  id: ID_Output;
  productStatus: PhysicalProductStatus;
  notes?: String;
}

export interface ReservationReceiptItemPromise
  extends Promise<ReservationReceiptItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = PhysicalProductPromise>() => T;
  productStatus: () => Promise<PhysicalProductStatus>;
  notes: () => Promise<String>;
}

export interface ReservationReceiptItemSubscription
  extends Promise<AsyncIterator<ReservationReceiptItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = PhysicalProductSubscription>() => T;
  productStatus: () => Promise<AsyncIterator<PhysicalProductStatus>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ReservationReceiptItemNullablePromise
  extends Promise<ReservationReceiptItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = PhysicalProductPromise>() => T;
  productStatus: () => Promise<PhysicalProductStatus>;
  notes: () => Promise<String>;
}

export interface CustomerAdmissionsData {
  id: ID_Output;
  inServiceableZipcode: Boolean;
  admissable: Boolean;
  inAdmissableReason?: InAdmissableReason;
  allAccessEnabled: Boolean;
  authorizationsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  authorizationWindowClosesAt?: DateTimeOutput;
}

export interface CustomerAdmissionsDataPromise
  extends Promise<CustomerAdmissionsData>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  inServiceableZipcode: () => Promise<Boolean>;
  admissable: () => Promise<Boolean>;
  inAdmissableReason: () => Promise<InAdmissableReason>;
  allAccessEnabled: () => Promise<Boolean>;
  customer: <T = CustomerPromise>() => T;
  authorizationsCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  authorizationWindowClosesAt: () => Promise<DateTimeOutput>;
}

export interface CustomerAdmissionsDataSubscription
  extends Promise<AsyncIterator<CustomerAdmissionsData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  inServiceableZipcode: () => Promise<AsyncIterator<Boolean>>;
  admissable: () => Promise<AsyncIterator<Boolean>>;
  inAdmissableReason: () => Promise<AsyncIterator<InAdmissableReason>>;
  allAccessEnabled: () => Promise<AsyncIterator<Boolean>>;
  customer: <T = CustomerSubscription>() => T;
  authorizationsCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  authorizationWindowClosesAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerAdmissionsDataNullablePromise
  extends Promise<CustomerAdmissionsData | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  inServiceableZipcode: () => Promise<Boolean>;
  admissable: () => Promise<Boolean>;
  inAdmissableReason: () => Promise<InAdmissableReason>;
  allAccessEnabled: () => Promise<Boolean>;
  customer: <T = CustomerPromise>() => T;
  authorizationsCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  authorizationWindowClosesAt: () => Promise<DateTimeOutput>;
}

export interface UTMData {
  id: ID_Output;
  source?: String;
  medium?: String;
  campaign?: String;
  term?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UTMDataPromise extends Promise<UTMData>, Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  source: () => Promise<String>;
  medium: () => Promise<String>;
  campaign: () => Promise<String>;
  term: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UTMDataSubscription
  extends Promise<AsyncIterator<UTMData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  source: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  campaign: () => Promise<AsyncIterator<String>>;
  term: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UTMDataNullablePromise
  extends Promise<UTMData | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  source: () => Promise<String>;
  medium: () => Promise<String>;
  campaign: () => Promise<String>;
  term: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BagItemConnection {
  pageInfo: PageInfo;
  edges: BagItemEdge[];
}

export interface BagItemConnectionPromise
  extends Promise<BagItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BagItemEdge>>() => T;
  aggregate: <T = AggregateBagItemPromise>() => T;
}

export interface BagItemConnectionSubscription
  extends Promise<AsyncIterator<BagItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BagItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBagItemSubscription>() => T;
}

export interface BagItemEdge {
  node: BagItem;
  cursor: String;
}

export interface BagItemEdgePromise extends Promise<BagItemEdge>, Fragmentable {
  node: <T = BagItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BagItemEdgeSubscription
  extends Promise<AsyncIterator<BagItemEdge>>,
    Fragmentable {
  node: <T = BagItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBagItem {
  count: Int;
}

export interface AggregateBagItemPromise
  extends Promise<AggregateBagItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBagItemSubscription
  extends Promise<AsyncIterator<AggregateBagItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BillingInfoConnection {
  pageInfo: PageInfo;
  edges: BillingInfoEdge[];
}

export interface BillingInfoConnectionPromise
  extends Promise<BillingInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BillingInfoEdge>>() => T;
  aggregate: <T = AggregateBillingInfoPromise>() => T;
}

export interface BillingInfoConnectionSubscription
  extends Promise<AsyncIterator<BillingInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BillingInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBillingInfoSubscription>() => T;
}

export interface BillingInfoEdge {
  node: BillingInfo;
  cursor: String;
}

export interface BillingInfoEdgePromise
  extends Promise<BillingInfoEdge>,
    Fragmentable {
  node: <T = BillingInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BillingInfoEdgeSubscription
  extends Promise<AsyncIterator<BillingInfoEdge>>,
    Fragmentable {
  node: <T = BillingInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBillingInfo {
  count: Int;
}

export interface AggregateBillingInfoPromise
  extends Promise<AggregateBillingInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBillingInfoSubscription
  extends Promise<AsyncIterator<AggregateBillingInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BottomSizeConnection {
  pageInfo: PageInfo;
  edges: BottomSizeEdge[];
}

export interface BottomSizeConnectionPromise
  extends Promise<BottomSizeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BottomSizeEdge>>() => T;
  aggregate: <T = AggregateBottomSizePromise>() => T;
}

export interface BottomSizeConnectionSubscription
  extends Promise<AsyncIterator<BottomSizeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BottomSizeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBottomSizeSubscription>() => T;
}

export interface BottomSizeEdge {
  node: BottomSize;
  cursor: String;
}

export interface BottomSizeEdgePromise
  extends Promise<BottomSizeEdge>,
    Fragmentable {
  node: <T = BottomSizePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BottomSizeEdgeSubscription
  extends Promise<AsyncIterator<BottomSizeEdge>>,
    Fragmentable {
  node: <T = BottomSizeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBottomSize {
  count: Int;
}

export interface AggregateBottomSizePromise
  extends Promise<AggregateBottomSize>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBottomSizeSubscription
  extends Promise<AsyncIterator<AggregateBottomSize>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandConnection {
  pageInfo: PageInfo;
  edges: BrandEdge[];
}

export interface BrandConnectionPromise
  extends Promise<BrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandEdge>>() => T;
  aggregate: <T = AggregateBrandPromise>() => T;
}

export interface BrandConnectionSubscription
  extends Promise<AsyncIterator<BrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandSubscription>() => T;
}

export interface BrandEdge {
  node: Brand;
  cursor: String;
}

export interface BrandEdgePromise extends Promise<BrandEdge>, Fragmentable {
  node: <T = BrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandEdgeSubscription
  extends Promise<AsyncIterator<BrandEdge>>,
    Fragmentable {
  node: <T = BrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBrand {
  count: Int;
}

export interface AggregateBrandPromise
  extends Promise<AggregateBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandSubscription
  extends Promise<AsyncIterator<AggregateBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Collection {
  id: ID_Output;
  slug: String;
  title?: String;
  subTitle?: String;
  descriptions: String[];
  published: Boolean;
  placements: CollectionPlacement[];
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface CollectionPromise extends Promise<Collection>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: () => Promise<String>;
  subTitle: () => Promise<String>;
  descriptions: () => Promise<String[]>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  published: () => Promise<Boolean>;
  placements: () => Promise<CollectionPlacement[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CollectionSubscription
  extends Promise<AsyncIterator<Collection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: () => Promise<AsyncIterator<String>>;
  subTitle: () => Promise<AsyncIterator<String>>;
  descriptions: () => Promise<AsyncIterator<String[]>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  published: () => Promise<AsyncIterator<Boolean>>;
  placements: () => Promise<AsyncIterator<CollectionPlacement[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CollectionNullablePromise
  extends Promise<Collection | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  title: () => Promise<String>;
  subTitle: () => Promise<String>;
  descriptions: () => Promise<String[]>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  published: () => Promise<Boolean>;
  placements: () => Promise<CollectionPlacement[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CollectionConnection {
  pageInfo: PageInfo;
  edges: CollectionEdge[];
}

export interface CollectionConnectionPromise
  extends Promise<CollectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionEdge>>() => T;
  aggregate: <T = AggregateCollectionPromise>() => T;
}

export interface CollectionConnectionSubscription
  extends Promise<AsyncIterator<CollectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionSubscription>() => T;
}

export interface CollectionEdge {
  node: Collection;
  cursor: String;
}

export interface CollectionEdgePromise
  extends Promise<CollectionEdge>,
    Fragmentable {
  node: <T = CollectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionEdgeSubscription
  extends Promise<AsyncIterator<CollectionEdge>>,
    Fragmentable {
  node: <T = CollectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCollection {
  count: Int;
}

export interface AggregateCollectionPromise
  extends Promise<AggregateCollection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionSubscription
  extends Promise<AsyncIterator<AggregateCollection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ColorConnection {
  pageInfo: PageInfo;
  edges: ColorEdge[];
}

export interface ColorConnectionPromise
  extends Promise<ColorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ColorEdge>>() => T;
  aggregate: <T = AggregateColorPromise>() => T;
}

export interface ColorConnectionSubscription
  extends Promise<AsyncIterator<ColorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ColorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateColorSubscription>() => T;
}

export interface ColorEdge {
  node: Color;
  cursor: String;
}

export interface ColorEdgePromise extends Promise<ColorEdge>, Fragmentable {
  node: <T = ColorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ColorEdgeSubscription
  extends Promise<AsyncIterator<ColorEdge>>,
    Fragmentable {
  node: <T = ColorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateColor {
  count: Int;
}

export interface AggregateColorPromise
  extends Promise<AggregateColor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateColorSubscription
  extends Promise<AsyncIterator<AggregateColor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerAdmissionsDataConnection {
  pageInfo: PageInfo;
  edges: CustomerAdmissionsDataEdge[];
}

export interface CustomerAdmissionsDataConnectionPromise
  extends Promise<CustomerAdmissionsDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerAdmissionsDataEdge>>() => T;
  aggregate: <T = AggregateCustomerAdmissionsDataPromise>() => T;
}

export interface CustomerAdmissionsDataConnectionSubscription
  extends Promise<AsyncIterator<CustomerAdmissionsDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CustomerAdmissionsDataEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCustomerAdmissionsDataSubscription>() => T;
}

export interface CustomerAdmissionsDataEdge {
  node: CustomerAdmissionsData;
  cursor: String;
}

export interface CustomerAdmissionsDataEdgePromise
  extends Promise<CustomerAdmissionsDataEdge>,
    Fragmentable {
  node: <T = CustomerAdmissionsDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerAdmissionsDataEdgeSubscription
  extends Promise<AsyncIterator<CustomerAdmissionsDataEdge>>,
    Fragmentable {
  node: <T = CustomerAdmissionsDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerAdmissionsData {
  count: Int;
}

export interface AggregateCustomerAdmissionsDataPromise
  extends Promise<AggregateCustomerAdmissionsData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerAdmissionsDataSubscription
  extends Promise<AsyncIterator<AggregateCustomerAdmissionsData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerDetailConnection {
  pageInfo: PageInfo;
  edges: CustomerDetailEdge[];
}

export interface CustomerDetailConnectionPromise
  extends Promise<CustomerDetailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerDetailEdge>>() => T;
  aggregate: <T = AggregateCustomerDetailPromise>() => T;
}

export interface CustomerDetailConnectionSubscription
  extends Promise<AsyncIterator<CustomerDetailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerDetailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerDetailSubscription>() => T;
}

export interface CustomerDetailEdge {
  node: CustomerDetail;
  cursor: String;
}

export interface CustomerDetailEdgePromise
  extends Promise<CustomerDetailEdge>,
    Fragmentable {
  node: <T = CustomerDetailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerDetailEdgeSubscription
  extends Promise<AsyncIterator<CustomerDetailEdge>>,
    Fragmentable {
  node: <T = CustomerDetailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerDetail {
  count: Int;
}

export interface AggregateCustomerDetailPromise
  extends Promise<AggregateCustomerDetail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerDetailSubscription
  extends Promise<AsyncIterator<AggregateCustomerDetail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerMembershipConnection {
  pageInfo: PageInfo;
  edges: CustomerMembershipEdge[];
}

export interface CustomerMembershipConnectionPromise
  extends Promise<CustomerMembershipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerMembershipEdge>>() => T;
  aggregate: <T = AggregateCustomerMembershipPromise>() => T;
}

export interface CustomerMembershipConnectionSubscription
  extends Promise<AsyncIterator<CustomerMembershipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CustomerMembershipEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCustomerMembershipSubscription>() => T;
}

export interface CustomerMembershipEdge {
  node: CustomerMembership;
  cursor: String;
}

export interface CustomerMembershipEdgePromise
  extends Promise<CustomerMembershipEdge>,
    Fragmentable {
  node: <T = CustomerMembershipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerMembershipEdgeSubscription
  extends Promise<AsyncIterator<CustomerMembershipEdge>>,
    Fragmentable {
  node: <T = CustomerMembershipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerMembership {
  count: Int;
}

export interface AggregateCustomerMembershipPromise
  extends Promise<AggregateCustomerMembership>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerMembershipSubscription
  extends Promise<AsyncIterator<AggregateCustomerMembership>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmailReceiptConnection {
  pageInfo: PageInfo;
  edges: EmailReceiptEdge[];
}

export interface EmailReceiptConnectionPromise
  extends Promise<EmailReceiptConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmailReceiptEdge>>() => T;
  aggregate: <T = AggregateEmailReceiptPromise>() => T;
}

export interface EmailReceiptConnectionSubscription
  extends Promise<AsyncIterator<EmailReceiptConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmailReceiptEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmailReceiptSubscription>() => T;
}

export interface EmailReceiptEdge {
  node: EmailReceipt;
  cursor: String;
}

export interface EmailReceiptEdgePromise
  extends Promise<EmailReceiptEdge>,
    Fragmentable {
  node: <T = EmailReceiptPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmailReceiptEdgeSubscription
  extends Promise<AsyncIterator<EmailReceiptEdge>>,
    Fragmentable {
  node: <T = EmailReceiptSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmailReceipt {
  count: Int;
}

export interface AggregateEmailReceiptPromise
  extends Promise<AggregateEmailReceipt>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmailReceiptSubscription
  extends Promise<AsyncIterator<AggregateEmailReceipt>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExternalShopifyIntegrationConnection {
  pageInfo: PageInfo;
  edges: ExternalShopifyIntegrationEdge[];
}

export interface ExternalShopifyIntegrationConnectionPromise
  extends Promise<ExternalShopifyIntegrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExternalShopifyIntegrationEdge>>() => T;
  aggregate: <T = AggregateExternalShopifyIntegrationPromise>() => T;
}

export interface ExternalShopifyIntegrationConnectionSubscription
  extends Promise<AsyncIterator<ExternalShopifyIntegrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExternalShopifyIntegrationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExternalShopifyIntegrationSubscription>() => T;
}

export interface ExternalShopifyIntegrationEdge {
  node: ExternalShopifyIntegration;
  cursor: String;
}

export interface ExternalShopifyIntegrationEdgePromise
  extends Promise<ExternalShopifyIntegrationEdge>,
    Fragmentable {
  node: <T = ExternalShopifyIntegrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExternalShopifyIntegrationEdgeSubscription
  extends Promise<AsyncIterator<ExternalShopifyIntegrationEdge>>,
    Fragmentable {
  node: <T = ExternalShopifyIntegrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExternalShopifyIntegration {
  count: Int;
}

export interface AggregateExternalShopifyIntegrationPromise
  extends Promise<AggregateExternalShopifyIntegration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExternalShopifyIntegrationSubscription
  extends Promise<AsyncIterator<AggregateExternalShopifyIntegration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FitPicConnection {
  pageInfo: PageInfo;
  edges: FitPicEdge[];
}

export interface FitPicConnectionPromise
  extends Promise<FitPicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FitPicEdge>>() => T;
  aggregate: <T = AggregateFitPicPromise>() => T;
}

export interface FitPicConnectionSubscription
  extends Promise<AsyncIterator<FitPicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FitPicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFitPicSubscription>() => T;
}

export interface FitPicEdge {
  node: FitPic;
  cursor: String;
}

export interface FitPicEdgePromise extends Promise<FitPicEdge>, Fragmentable {
  node: <T = FitPicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FitPicEdgeSubscription
  extends Promise<AsyncIterator<FitPicEdge>>,
    Fragmentable {
  node: <T = FitPicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFitPic {
  count: Int;
}

export interface AggregateFitPicPromise
  extends Promise<AggregateFitPic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFitPicSubscription
  extends Promise<AsyncIterator<AggregateFitPic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FitPicReportConnection {
  pageInfo: PageInfo;
  edges: FitPicReportEdge[];
}

export interface FitPicReportConnectionPromise
  extends Promise<FitPicReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FitPicReportEdge>>() => T;
  aggregate: <T = AggregateFitPicReportPromise>() => T;
}

export interface FitPicReportConnectionSubscription
  extends Promise<AsyncIterator<FitPicReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FitPicReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFitPicReportSubscription>() => T;
}

export interface FitPicReportEdge {
  node: FitPicReport;
  cursor: String;
}

export interface FitPicReportEdgePromise
  extends Promise<FitPicReportEdge>,
    Fragmentable {
  node: <T = FitPicReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FitPicReportEdgeSubscription
  extends Promise<AsyncIterator<FitPicReportEdge>>,
    Fragmentable {
  node: <T = FitPicReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFitPicReport {
  count: Int;
}

export interface AggregateFitPicReportPromise
  extends Promise<AggregateFitPicReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFitPicReportSubscription
  extends Promise<AsyncIterator<AggregateFitPicReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InterestedUser {
  id: ID_Output;
  email: String;
  zipcode?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InterestedUserPromise
  extends Promise<InterestedUser>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  zipcode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InterestedUserSubscription
  extends Promise<AsyncIterator<InterestedUser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InterestedUserNullablePromise
  extends Promise<InterestedUser | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  zipcode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InterestedUserConnection {
  pageInfo: PageInfo;
  edges: InterestedUserEdge[];
}

export interface InterestedUserConnectionPromise
  extends Promise<InterestedUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InterestedUserEdge>>() => T;
  aggregate: <T = AggregateInterestedUserPromise>() => T;
}

export interface InterestedUserConnectionSubscription
  extends Promise<AsyncIterator<InterestedUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InterestedUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInterestedUserSubscription>() => T;
}

export interface InterestedUserEdge {
  node: InterestedUser;
  cursor: String;
}

export interface InterestedUserEdgePromise
  extends Promise<InterestedUserEdge>,
    Fragmentable {
  node: <T = InterestedUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InterestedUserEdgeSubscription
  extends Promise<AsyncIterator<InterestedUserEdge>>,
    Fragmentable {
  node: <T = InterestedUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInterestedUser {
  count: Int;
}

export interface AggregateInterestedUserPromise
  extends Promise<AggregateInterestedUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInterestedUserSubscription
  extends Promise<AsyncIterator<AggregateInterestedUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LabelConnection {
  pageInfo: PageInfo;
  edges: LabelEdge[];
}

export interface LabelConnectionPromise
  extends Promise<LabelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LabelEdge>>() => T;
  aggregate: <T = AggregateLabelPromise>() => T;
}

export interface LabelConnectionSubscription
  extends Promise<AsyncIterator<LabelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LabelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLabelSubscription>() => T;
}

export interface LabelEdge {
  node: Label;
  cursor: String;
}

export interface LabelEdgePromise extends Promise<LabelEdge>, Fragmentable {
  node: <T = LabelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LabelEdgeSubscription
  extends Promise<AsyncIterator<LabelEdge>>,
    Fragmentable {
  node: <T = LabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLabel {
  count: Int;
}

export interface AggregateLabelPromise
  extends Promise<AggregateLabel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLabelSubscription
  extends Promise<AsyncIterator<AggregateLabel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PackageConnection {
  pageInfo: PageInfo;
  edges: PackageEdge[];
}

export interface PackageConnectionPromise
  extends Promise<PackageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PackageEdge>>() => T;
  aggregate: <T = AggregatePackagePromise>() => T;
}

export interface PackageConnectionSubscription
  extends Promise<AsyncIterator<PackageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PackageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePackageSubscription>() => T;
}

export interface PackageEdge {
  node: Package;
  cursor: String;
}

export interface PackageEdgePromise extends Promise<PackageEdge>, Fragmentable {
  node: <T = PackagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PackageEdgeSubscription
  extends Promise<AsyncIterator<PackageEdge>>,
    Fragmentable {
  node: <T = PackageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePackage {
  count: Int;
}

export interface AggregatePackagePromise
  extends Promise<AggregatePackage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePackageSubscription
  extends Promise<AsyncIterator<AggregatePackage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PackageTransitEventConnection {
  pageInfo: PageInfo;
  edges: PackageTransitEventEdge[];
}

export interface PackageTransitEventConnectionPromise
  extends Promise<PackageTransitEventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PackageTransitEventEdge>>() => T;
  aggregate: <T = AggregatePackageTransitEventPromise>() => T;
}

export interface PackageTransitEventConnectionSubscription
  extends Promise<AsyncIterator<PackageTransitEventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PackageTransitEventEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePackageTransitEventSubscription>() => T;
}

export interface PackageTransitEventEdge {
  node: PackageTransitEvent;
  cursor: String;
}

export interface PackageTransitEventEdgePromise
  extends Promise<PackageTransitEventEdge>,
    Fragmentable {
  node: <T = PackageTransitEventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PackageTransitEventEdgeSubscription
  extends Promise<AsyncIterator<PackageTransitEventEdge>>,
    Fragmentable {
  node: <T = PackageTransitEventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePackageTransitEvent {
  count: Int;
}

export interface AggregatePackageTransitEventPromise
  extends Promise<AggregatePackageTransitEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePackageTransitEventSubscription
  extends Promise<AsyncIterator<AggregatePackageTransitEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PauseRequestConnection {
  pageInfo: PageInfo;
  edges: PauseRequestEdge[];
}

export interface PauseRequestConnectionPromise
  extends Promise<PauseRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PauseRequestEdge>>() => T;
  aggregate: <T = AggregatePauseRequestPromise>() => T;
}

export interface PauseRequestConnectionSubscription
  extends Promise<AsyncIterator<PauseRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PauseRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePauseRequestSubscription>() => T;
}

export interface PauseRequestEdge {
  node: PauseRequest;
  cursor: String;
}

export interface PauseRequestEdgePromise
  extends Promise<PauseRequestEdge>,
    Fragmentable {
  node: <T = PauseRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PauseRequestEdgeSubscription
  extends Promise<AsyncIterator<PauseRequestEdge>>,
    Fragmentable {
  node: <T = PauseRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePauseRequest {
  count: Int;
}

export interface AggregatePauseRequestPromise
  extends Promise<AggregatePauseRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePauseRequestSubscription
  extends Promise<AsyncIterator<AggregatePauseRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentPlanConnection {
  pageInfo: PageInfo;
  edges: PaymentPlanEdge[];
}

export interface PaymentPlanConnectionPromise
  extends Promise<PaymentPlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentPlanEdge>>() => T;
  aggregate: <T = AggregatePaymentPlanPromise>() => T;
}

export interface PaymentPlanConnectionSubscription
  extends Promise<AsyncIterator<PaymentPlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentPlanEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentPlanSubscription>() => T;
}

export interface PaymentPlanEdge {
  node: PaymentPlan;
  cursor: String;
}

export interface PaymentPlanEdgePromise
  extends Promise<PaymentPlanEdge>,
    Fragmentable {
  node: <T = PaymentPlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentPlanEdgeSubscription
  extends Promise<AsyncIterator<PaymentPlanEdge>>,
    Fragmentable {
  node: <T = PaymentPlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePaymentPlan {
  count: Int;
}

export interface AggregatePaymentPlanPromise
  extends Promise<AggregatePaymentPlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentPlanSubscription
  extends Promise<AsyncIterator<AggregatePaymentPlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhysicalProductConnection {
  pageInfo: PageInfo;
  edges: PhysicalProductEdge[];
}

export interface PhysicalProductConnectionPromise
  extends Promise<PhysicalProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhysicalProductEdge>>() => T;
  aggregate: <T = AggregatePhysicalProductPromise>() => T;
}

export interface PhysicalProductConnectionSubscription
  extends Promise<AsyncIterator<PhysicalProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhysicalProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhysicalProductSubscription>() => T;
}

export interface PhysicalProductEdge {
  node: PhysicalProduct;
  cursor: String;
}

export interface PhysicalProductEdgePromise
  extends Promise<PhysicalProductEdge>,
    Fragmentable {
  node: <T = PhysicalProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhysicalProductEdgeSubscription
  extends Promise<AsyncIterator<PhysicalProductEdge>>,
    Fragmentable {
  node: <T = PhysicalProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhysicalProduct {
  count: Int;
}

export interface AggregatePhysicalProductPromise
  extends Promise<AggregatePhysicalProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhysicalProductSubscription
  extends Promise<AsyncIterator<AggregatePhysicalProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhysicalProductPriceConnection {
  pageInfo: PageInfo;
  edges: PhysicalProductPriceEdge[];
}

export interface PhysicalProductPriceConnectionPromise
  extends Promise<PhysicalProductPriceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhysicalProductPriceEdge>>() => T;
  aggregate: <T = AggregatePhysicalProductPricePromise>() => T;
}

export interface PhysicalProductPriceConnectionSubscription
  extends Promise<AsyncIterator<PhysicalProductPriceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PhysicalProductPriceEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePhysicalProductPriceSubscription>() => T;
}

export interface PhysicalProductPriceEdge {
  node: PhysicalProductPrice;
  cursor: String;
}

export interface PhysicalProductPriceEdgePromise
  extends Promise<PhysicalProductPriceEdge>,
    Fragmentable {
  node: <T = PhysicalProductPricePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhysicalProductPriceEdgeSubscription
  extends Promise<AsyncIterator<PhysicalProductPriceEdge>>,
    Fragmentable {
  node: <T = PhysicalProductPriceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhysicalProductPrice {
  count: Int;
}

export interface AggregatePhysicalProductPricePromise
  extends Promise<AggregatePhysicalProductPrice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhysicalProductPriceSubscription
  extends Promise<AsyncIterator<AggregatePhysicalProductPrice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhysicalProductQualityReportConnection {
  pageInfo: PageInfo;
  edges: PhysicalProductQualityReportEdge[];
}

export interface PhysicalProductQualityReportConnectionPromise
  extends Promise<PhysicalProductQualityReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhysicalProductQualityReportEdge>>() => T;
  aggregate: <T = AggregatePhysicalProductQualityReportPromise>() => T;
}

export interface PhysicalProductQualityReportConnectionSubscription
  extends Promise<AsyncIterator<PhysicalProductQualityReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PhysicalProductQualityReportEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePhysicalProductQualityReportSubscription>() => T;
}

export interface PhysicalProductQualityReportEdge {
  node: PhysicalProductQualityReport;
  cursor: String;
}

export interface PhysicalProductQualityReportEdgePromise
  extends Promise<PhysicalProductQualityReportEdge>,
    Fragmentable {
  node: <T = PhysicalProductQualityReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhysicalProductQualityReportEdgeSubscription
  extends Promise<AsyncIterator<PhysicalProductQualityReportEdge>>,
    Fragmentable {
  node: <T = PhysicalProductQualityReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhysicalProductQualityReport {
  count: Int;
}

export interface AggregatePhysicalProductQualityReportPromise
  extends Promise<AggregatePhysicalProductQualityReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhysicalProductQualityReportSubscription
  extends Promise<AsyncIterator<AggregatePhysicalProductQualityReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductFunctionConnection {
  pageInfo: PageInfo;
  edges: ProductFunctionEdge[];
}

export interface ProductFunctionConnectionPromise
  extends Promise<ProductFunctionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductFunctionEdge>>() => T;
  aggregate: <T = AggregateProductFunctionPromise>() => T;
}

export interface ProductFunctionConnectionSubscription
  extends Promise<AsyncIterator<ProductFunctionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductFunctionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductFunctionSubscription>() => T;
}

export interface ProductFunctionEdge {
  node: ProductFunction;
  cursor: String;
}

export interface ProductFunctionEdgePromise
  extends Promise<ProductFunctionEdge>,
    Fragmentable {
  node: <T = ProductFunctionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductFunctionEdgeSubscription
  extends Promise<AsyncIterator<ProductFunctionEdge>>,
    Fragmentable {
  node: <T = ProductFunctionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductFunction {
  count: Int;
}

export interface AggregateProductFunctionPromise
  extends Promise<AggregateProductFunction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductFunctionSubscription
  extends Promise<AsyncIterator<AggregateProductFunction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductMaterialCategoryConnection {
  pageInfo: PageInfo;
  edges: ProductMaterialCategoryEdge[];
}

export interface ProductMaterialCategoryConnectionPromise
  extends Promise<ProductMaterialCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductMaterialCategoryEdge>>() => T;
  aggregate: <T = AggregateProductMaterialCategoryPromise>() => T;
}

export interface ProductMaterialCategoryConnectionSubscription
  extends Promise<AsyncIterator<ProductMaterialCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductMaterialCategoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductMaterialCategorySubscription>() => T;
}

export interface ProductMaterialCategoryEdge {
  node: ProductMaterialCategory;
  cursor: String;
}

export interface ProductMaterialCategoryEdgePromise
  extends Promise<ProductMaterialCategoryEdge>,
    Fragmentable {
  node: <T = ProductMaterialCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductMaterialCategoryEdgeSubscription
  extends Promise<AsyncIterator<ProductMaterialCategoryEdge>>,
    Fragmentable {
  node: <T = ProductMaterialCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductMaterialCategory {
  count: Int;
}

export interface AggregateProductMaterialCategoryPromise
  extends Promise<AggregateProductMaterialCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductMaterialCategorySubscription
  extends Promise<AsyncIterator<AggregateProductMaterialCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductModelConnection {
  pageInfo: PageInfo;
  edges: ProductModelEdge[];
}

export interface ProductModelConnectionPromise
  extends Promise<ProductModelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductModelEdge>>() => T;
  aggregate: <T = AggregateProductModelPromise>() => T;
}

export interface ProductModelConnectionSubscription
  extends Promise<AsyncIterator<ProductModelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductModelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductModelSubscription>() => T;
}

export interface ProductModelEdge {
  node: ProductModel;
  cursor: String;
}

export interface ProductModelEdgePromise
  extends Promise<ProductModelEdge>,
    Fragmentable {
  node: <T = ProductModelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductModelEdgeSubscription
  extends Promise<AsyncIterator<ProductModelEdge>>,
    Fragmentable {
  node: <T = ProductModelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductModel {
  count: Int;
}

export interface AggregateProductModelPromise
  extends Promise<AggregateProductModel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductModelSubscription
  extends Promise<AsyncIterator<AggregateProductModel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductNotification {
  id: ID_Output;
  type: ProductNotificationType;
  shouldNotify: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductNotificationPromise
  extends Promise<ProductNotification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ProductNotificationType>;
  customer: <T = CustomerPromise>() => T;
  physicalProduct: <T = PhysicalProductPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  shouldNotify: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductNotificationSubscription
  extends Promise<AsyncIterator<ProductNotification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ProductNotificationType>>;
  customer: <T = CustomerSubscription>() => T;
  physicalProduct: <T = PhysicalProductSubscription>() => T;
  productVariant: <T = ProductVariantSubscription>() => T;
  shouldNotify: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductNotificationNullablePromise
  extends Promise<ProductNotification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ProductNotificationType>;
  customer: <T = CustomerPromise>() => T;
  physicalProduct: <T = PhysicalProductPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  shouldNotify: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductNotificationConnection {
  pageInfo: PageInfo;
  edges: ProductNotificationEdge[];
}

export interface ProductNotificationConnectionPromise
  extends Promise<ProductNotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductNotificationEdge>>() => T;
  aggregate: <T = AggregateProductNotificationPromise>() => T;
}

export interface ProductNotificationConnectionSubscription
  extends Promise<AsyncIterator<ProductNotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductNotificationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductNotificationSubscription>() => T;
}

export interface ProductNotificationEdge {
  node: ProductNotification;
  cursor: String;
}

export interface ProductNotificationEdgePromise
  extends Promise<ProductNotificationEdge>,
    Fragmentable {
  node: <T = ProductNotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductNotificationEdgeSubscription
  extends Promise<AsyncIterator<ProductNotificationEdge>>,
    Fragmentable {
  node: <T = ProductNotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductNotification {
  count: Int;
}

export interface AggregateProductNotificationPromise
  extends Promise<AggregateProductNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductNotificationSubscription
  extends Promise<AsyncIterator<AggregateProductNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductRequest {
  id: ID_Output;
  brand?: String;
  description?: String;
  images: String[];
  name?: String;
  price?: Int;
  priceCurrency?: String;
  productID?: String;
  reason: String;
  sku?: String;
  url: String;
}

export interface ProductRequestPromise
  extends Promise<ProductRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  images: () => Promise<String[]>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  priceCurrency: () => Promise<String>;
  productID: () => Promise<String>;
  reason: () => Promise<String>;
  sku: () => Promise<String>;
  url: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface ProductRequestSubscription
  extends Promise<AsyncIterator<ProductRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  priceCurrency: () => Promise<AsyncIterator<String>>;
  productID: () => Promise<AsyncIterator<String>>;
  reason: () => Promise<AsyncIterator<String>>;
  sku: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface ProductRequestNullablePromise
  extends Promise<ProductRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  images: () => Promise<String[]>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  priceCurrency: () => Promise<String>;
  productID: () => Promise<String>;
  reason: () => Promise<String>;
  sku: () => Promise<String>;
  url: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface ProductRequestConnection {
  pageInfo: PageInfo;
  edges: ProductRequestEdge[];
}

export interface ProductRequestConnectionPromise
  extends Promise<ProductRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductRequestEdge>>() => T;
  aggregate: <T = AggregateProductRequestPromise>() => T;
}

export interface ProductRequestConnectionSubscription
  extends Promise<AsyncIterator<ProductRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductRequestSubscription>() => T;
}

export interface ProductRequestEdge {
  node: ProductRequest;
  cursor: String;
}

export interface ProductRequestEdgePromise
  extends Promise<ProductRequestEdge>,
    Fragmentable {
  node: <T = ProductRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductRequestEdgeSubscription
  extends Promise<AsyncIterator<ProductRequestEdge>>,
    Fragmentable {
  node: <T = ProductRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductRequest {
  count: Int;
}

export interface AggregateProductRequestPromise
  extends Promise<AggregateProductRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductRequestSubscription
  extends Promise<AsyncIterator<AggregateProductRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSeasonConnection {
  pageInfo: PageInfo;
  edges: ProductSeasonEdge[];
}

export interface ProductSeasonConnectionPromise
  extends Promise<ProductSeasonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductSeasonEdge>>() => T;
  aggregate: <T = AggregateProductSeasonPromise>() => T;
}

export interface ProductSeasonConnectionSubscription
  extends Promise<AsyncIterator<ProductSeasonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductSeasonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSeasonSubscription>() => T;
}

export interface ProductSeasonEdge {
  node: ProductSeason;
  cursor: String;
}

export interface ProductSeasonEdgePromise
  extends Promise<ProductSeasonEdge>,
    Fragmentable {
  node: <T = ProductSeasonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductSeasonEdgeSubscription
  extends Promise<AsyncIterator<ProductSeasonEdge>>,
    Fragmentable {
  node: <T = ProductSeasonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductSeason {
  count: Int;
}

export interface AggregateProductSeasonPromise
  extends Promise<AggregateProductSeason>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSeasonSubscription
  extends Promise<AsyncIterator<AggregateProductSeason>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductTierConnection {
  pageInfo: PageInfo;
  edges: ProductTierEdge[];
}

export interface ProductTierConnectionPromise
  extends Promise<ProductTierConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductTierEdge>>() => T;
  aggregate: <T = AggregateProductTierPromise>() => T;
}

export interface ProductTierConnectionSubscription
  extends Promise<AsyncIterator<ProductTierConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductTierEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductTierSubscription>() => T;
}

export interface ProductTierEdge {
  node: ProductTier;
  cursor: String;
}

export interface ProductTierEdgePromise
  extends Promise<ProductTierEdge>,
    Fragmentable {
  node: <T = ProductTierPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductTierEdgeSubscription
  extends Promise<AsyncIterator<ProductTierEdge>>,
    Fragmentable {
  node: <T = ProductTierSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductTier {
  count: Int;
}

export interface AggregateProductTierPromise
  extends Promise<AggregateProductTier>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductTierSubscription
  extends Promise<AsyncIterator<AggregateProductTier>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantConnection {
  pageInfo: PageInfo;
  edges: ProductVariantEdge[];
}

export interface ProductVariantConnectionPromise
  extends Promise<ProductVariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantEdge>>() => T;
  aggregate: <T = AggregateProductVariantPromise>() => T;
}

export interface ProductVariantConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductVariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductVariantSubscription>() => T;
}

export interface ProductVariantEdge {
  node: ProductVariant;
  cursor: String;
}

export interface ProductVariantEdgePromise
  extends Promise<ProductVariantEdge>,
    Fragmentable {
  node: <T = ProductVariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantEdge>>,
    Fragmentable {
  node: <T = ProductVariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductVariant {
  count: Int;
}

export interface AggregateProductVariantPromise
  extends Promise<AggregateProductVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantSubscription
  extends Promise<AsyncIterator<AggregateProductVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantFeedback {
  id: ID_Output;
  isCompleted: Boolean;
}

export interface ProductVariantFeedbackPromise
  extends Promise<ProductVariantFeedback>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isCompleted: () => Promise<Boolean>;
  questions: <T = FragmentableArray<ProductVariantFeedbackQuestion>>(args?: {
    where?: ProductVariantFeedbackQuestionWhereInput;
    orderBy?: ProductVariantFeedbackQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationFeedback: <T = ReservationFeedbackPromise>() => T;
  variant: <T = ProductVariantPromise>() => T;
}

export interface ProductVariantFeedbackSubscription
  extends Promise<AsyncIterator<ProductVariantFeedback>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isCompleted: () => Promise<AsyncIterator<Boolean>>;
  questions: <
    T = Promise<AsyncIterator<ProductVariantFeedbackQuestionSubscription>>
  >(args?: {
    where?: ProductVariantFeedbackQuestionWhereInput;
    orderBy?: ProductVariantFeedbackQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationFeedback: <T = ReservationFeedbackSubscription>() => T;
  variant: <T = ProductVariantSubscription>() => T;
}

export interface ProductVariantFeedbackNullablePromise
  extends Promise<ProductVariantFeedback | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isCompleted: () => Promise<Boolean>;
  questions: <T = FragmentableArray<ProductVariantFeedbackQuestion>>(args?: {
    where?: ProductVariantFeedbackQuestionWhereInput;
    orderBy?: ProductVariantFeedbackQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationFeedback: <T = ReservationFeedbackPromise>() => T;
  variant: <T = ProductVariantPromise>() => T;
}

export interface ProductVariantFeedbackQuestion {
  id: ID_Output;
  options: String[];
  question: String;
  responses: String[];
  type: QuestionType;
}

export interface ProductVariantFeedbackQuestionPromise
  extends Promise<ProductVariantFeedbackQuestion>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  options: () => Promise<String[]>;
  question: () => Promise<String>;
  responses: () => Promise<String[]>;
  type: () => Promise<QuestionType>;
  variantFeedback: <T = ProductVariantFeedbackPromise>() => T;
}

export interface ProductVariantFeedbackQuestionSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackQuestion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  options: () => Promise<AsyncIterator<String[]>>;
  question: () => Promise<AsyncIterator<String>>;
  responses: () => Promise<AsyncIterator<String[]>>;
  type: () => Promise<AsyncIterator<QuestionType>>;
  variantFeedback: <T = ProductVariantFeedbackSubscription>() => T;
}

export interface ProductVariantFeedbackQuestionNullablePromise
  extends Promise<ProductVariantFeedbackQuestion | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  options: () => Promise<String[]>;
  question: () => Promise<String>;
  responses: () => Promise<String[]>;
  type: () => Promise<QuestionType>;
  variantFeedback: <T = ProductVariantFeedbackPromise>() => T;
}

export interface ReservationFeedback {
  id: ID_Output;
  comment?: String;
  rating?: Rating;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  respondedAt?: DateTimeOutput;
}

export interface ReservationFeedbackPromise
  extends Promise<ReservationFeedback>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  feedbacks: <T = FragmentableArray<ProductVariantFeedback>>(args?: {
    where?: ProductVariantFeedbackWhereInput;
    orderBy?: ProductVariantFeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rating: () => Promise<Rating>;
  user: <T = UserPromise>() => T;
  reservation: <T = ReservationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  respondedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationFeedbackSubscription
  extends Promise<AsyncIterator<ReservationFeedback>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  comment: () => Promise<AsyncIterator<String>>;
  feedbacks: <
    T = Promise<AsyncIterator<ProductVariantFeedbackSubscription>>
  >(args?: {
    where?: ProductVariantFeedbackWhereInput;
    orderBy?: ProductVariantFeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rating: () => Promise<AsyncIterator<Rating>>;
  user: <T = UserSubscription>() => T;
  reservation: <T = ReservationSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  respondedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationFeedbackNullablePromise
  extends Promise<ReservationFeedback | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  feedbacks: <T = FragmentableArray<ProductVariantFeedback>>(args?: {
    where?: ProductVariantFeedbackWhereInput;
    orderBy?: ProductVariantFeedbackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rating: () => Promise<Rating>;
  user: <T = UserPromise>() => T;
  reservation: <T = ReservationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  respondedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantFeedbackConnection {
  pageInfo: PageInfo;
  edges: ProductVariantFeedbackEdge[];
}

export interface ProductVariantFeedbackConnectionPromise
  extends Promise<ProductVariantFeedbackConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantFeedbackEdge>>() => T;
  aggregate: <T = AggregateProductVariantFeedbackPromise>() => T;
}

export interface ProductVariantFeedbackConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductVariantFeedbackEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductVariantFeedbackSubscription>() => T;
}

export interface ProductVariantFeedbackEdge {
  node: ProductVariantFeedback;
  cursor: String;
}

export interface ProductVariantFeedbackEdgePromise
  extends Promise<ProductVariantFeedbackEdge>,
    Fragmentable {
  node: <T = ProductVariantFeedbackPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantFeedbackEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackEdge>>,
    Fragmentable {
  node: <T = ProductVariantFeedbackSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductVariantFeedback {
  count: Int;
}

export interface AggregateProductVariantFeedbackPromise
  extends Promise<AggregateProductVariantFeedback>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantFeedbackSubscription
  extends Promise<AsyncIterator<AggregateProductVariantFeedback>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantFeedbackQuestionConnection {
  pageInfo: PageInfo;
  edges: ProductVariantFeedbackQuestionEdge[];
}

export interface ProductVariantFeedbackQuestionConnectionPromise
  extends Promise<ProductVariantFeedbackQuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantFeedbackQuestionEdge>>() => T;
  aggregate: <T = AggregateProductVariantFeedbackQuestionPromise>() => T;
}

export interface ProductVariantFeedbackQuestionConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackQuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductVariantFeedbackQuestionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductVariantFeedbackQuestionSubscription>() => T;
}

export interface ProductVariantFeedbackQuestionEdge {
  node: ProductVariantFeedbackQuestion;
  cursor: String;
}

export interface ProductVariantFeedbackQuestionEdgePromise
  extends Promise<ProductVariantFeedbackQuestionEdge>,
    Fragmentable {
  node: <T = ProductVariantFeedbackQuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantFeedbackQuestionEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackQuestionEdge>>,
    Fragmentable {
  node: <T = ProductVariantFeedbackQuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductVariantFeedbackQuestion {
  count: Int;
}

export interface AggregateProductVariantFeedbackQuestionPromise
  extends Promise<AggregateProductVariantFeedbackQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantFeedbackQuestionSubscription
  extends Promise<AsyncIterator<AggregateProductVariantFeedbackQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantPriceConnection {
  pageInfo: PageInfo;
  edges: ProductVariantPriceEdge[];
}

export interface ProductVariantPriceConnectionPromise
  extends Promise<ProductVariantPriceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantPriceEdge>>() => T;
  aggregate: <T = AggregateProductVariantPricePromise>() => T;
}

export interface ProductVariantPriceConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantPriceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductVariantPriceEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductVariantPriceSubscription>() => T;
}

export interface ProductVariantPriceEdge {
  node: ProductVariantPrice;
  cursor: String;
}

export interface ProductVariantPriceEdgePromise
  extends Promise<ProductVariantPriceEdge>,
    Fragmentable {
  node: <T = ProductVariantPricePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantPriceEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantPriceEdge>>,
    Fragmentable {
  node: <T = ProductVariantPriceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductVariantPrice {
  count: Int;
}

export interface AggregateProductVariantPricePromise
  extends Promise<AggregateProductVariantPrice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantPriceSubscription
  extends Promise<AsyncIterator<AggregateProductVariantPrice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantWant {
  id: ID_Output;
  isFulfilled: Boolean;
}

export interface ProductVariantWantPromise
  extends Promise<ProductVariantWant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productVariant: <T = ProductVariantPromise>() => T;
  user: <T = UserPromise>() => T;
  isFulfilled: () => Promise<Boolean>;
}

export interface ProductVariantWantSubscription
  extends Promise<AsyncIterator<ProductVariantWant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productVariant: <T = ProductVariantSubscription>() => T;
  user: <T = UserSubscription>() => T;
  isFulfilled: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductVariantWantNullablePromise
  extends Promise<ProductVariantWant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productVariant: <T = ProductVariantPromise>() => T;
  user: <T = UserPromise>() => T;
  isFulfilled: () => Promise<Boolean>;
}

export interface ProductVariantWantConnection {
  pageInfo: PageInfo;
  edges: ProductVariantWantEdge[];
}

export interface ProductVariantWantConnectionPromise
  extends Promise<ProductVariantWantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantWantEdge>>() => T;
  aggregate: <T = AggregateProductVariantWantPromise>() => T;
}

export interface ProductVariantWantConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantWantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductVariantWantEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductVariantWantSubscription>() => T;
}

export interface ProductVariantWantEdge {
  node: ProductVariantWant;
  cursor: String;
}

export interface ProductVariantWantEdgePromise
  extends Promise<ProductVariantWantEdge>,
    Fragmentable {
  node: <T = ProductVariantWantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantWantEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantWantEdge>>,
    Fragmentable {
  node: <T = ProductVariantWantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductVariantWant {
  count: Int;
}

export interface AggregateProductVariantWantPromise
  extends Promise<AggregateProductVariantWant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantWantSubscription
  extends Promise<AsyncIterator<AggregateProductVariantWant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PushNotificationReceiptConnection {
  pageInfo: PageInfo;
  edges: PushNotificationReceiptEdge[];
}

export interface PushNotificationReceiptConnectionPromise
  extends Promise<PushNotificationReceiptConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PushNotificationReceiptEdge>>() => T;
  aggregate: <T = AggregatePushNotificationReceiptPromise>() => T;
}

export interface PushNotificationReceiptConnectionSubscription
  extends Promise<AsyncIterator<PushNotificationReceiptConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PushNotificationReceiptEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePushNotificationReceiptSubscription>() => T;
}

export interface PushNotificationReceiptEdge {
  node: PushNotificationReceipt;
  cursor: String;
}

export interface PushNotificationReceiptEdgePromise
  extends Promise<PushNotificationReceiptEdge>,
    Fragmentable {
  node: <T = PushNotificationReceiptPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PushNotificationReceiptEdgeSubscription
  extends Promise<AsyncIterator<PushNotificationReceiptEdge>>,
    Fragmentable {
  node: <T = PushNotificationReceiptSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePushNotificationReceipt {
  count: Int;
}

export interface AggregatePushNotificationReceiptPromise
  extends Promise<AggregatePushNotificationReceipt>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePushNotificationReceiptSubscription
  extends Promise<AsyncIterator<AggregatePushNotificationReceipt>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RecentlyViewedProduct {
  id: ID_Output;
  viewCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RecentlyViewedProductPromise
  extends Promise<RecentlyViewedProduct>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  viewCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RecentlyViewedProductSubscription
  extends Promise<AsyncIterator<RecentlyViewedProduct>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  customer: <T = CustomerSubscription>() => T;
  viewCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RecentlyViewedProductNullablePromise
  extends Promise<RecentlyViewedProduct | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  viewCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RecentlyViewedProductConnection {
  pageInfo: PageInfo;
  edges: RecentlyViewedProductEdge[];
}

export interface RecentlyViewedProductConnectionPromise
  extends Promise<RecentlyViewedProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecentlyViewedProductEdge>>() => T;
  aggregate: <T = AggregateRecentlyViewedProductPromise>() => T;
}

export interface RecentlyViewedProductConnectionSubscription
  extends Promise<AsyncIterator<RecentlyViewedProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<RecentlyViewedProductEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateRecentlyViewedProductSubscription>() => T;
}

export interface RecentlyViewedProductEdge {
  node: RecentlyViewedProduct;
  cursor: String;
}

export interface RecentlyViewedProductEdgePromise
  extends Promise<RecentlyViewedProductEdge>,
    Fragmentable {
  node: <T = RecentlyViewedProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecentlyViewedProductEdgeSubscription
  extends Promise<AsyncIterator<RecentlyViewedProductEdge>>,
    Fragmentable {
  node: <T = RecentlyViewedProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRecentlyViewedProduct {
  count: Int;
}

export interface AggregateRecentlyViewedProductPromise
  extends Promise<AggregateRecentlyViewedProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecentlyViewedProductSubscription
  extends Promise<AsyncIterator<AggregateRecentlyViewedProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReservationConnection {
  pageInfo: PageInfo;
  edges: ReservationEdge[];
}

export interface ReservationConnectionPromise
  extends Promise<ReservationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReservationEdge>>() => T;
  aggregate: <T = AggregateReservationPromise>() => T;
}

export interface ReservationConnectionSubscription
  extends Promise<AsyncIterator<ReservationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReservationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReservationSubscription>() => T;
}

export interface ReservationEdge {
  node: Reservation;
  cursor: String;
}

export interface ReservationEdgePromise
  extends Promise<ReservationEdge>,
    Fragmentable {
  node: <T = ReservationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReservationEdgeSubscription
  extends Promise<AsyncIterator<ReservationEdge>>,
    Fragmentable {
  node: <T = ReservationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReservation {
  count: Int;
}

export interface AggregateReservationPromise
  extends Promise<AggregateReservation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReservationSubscription
  extends Promise<AsyncIterator<AggregateReservation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReservationFeedbackConnection {
  pageInfo: PageInfo;
  edges: ReservationFeedbackEdge[];
}

export interface ReservationFeedbackConnectionPromise
  extends Promise<ReservationFeedbackConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReservationFeedbackEdge>>() => T;
  aggregate: <T = AggregateReservationFeedbackPromise>() => T;
}

export interface ReservationFeedbackConnectionSubscription
  extends Promise<AsyncIterator<ReservationFeedbackConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ReservationFeedbackEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateReservationFeedbackSubscription>() => T;
}

export interface ReservationFeedbackEdge {
  node: ReservationFeedback;
  cursor: String;
}

export interface ReservationFeedbackEdgePromise
  extends Promise<ReservationFeedbackEdge>,
    Fragmentable {
  node: <T = ReservationFeedbackPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReservationFeedbackEdgeSubscription
  extends Promise<AsyncIterator<ReservationFeedbackEdge>>,
    Fragmentable {
  node: <T = ReservationFeedbackSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReservationFeedback {
  count: Int;
}

export interface AggregateReservationFeedbackPromise
  extends Promise<AggregateReservationFeedback>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReservationFeedbackSubscription
  extends Promise<AsyncIterator<AggregateReservationFeedback>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReservationReceiptConnection {
  pageInfo: PageInfo;
  edges: ReservationReceiptEdge[];
}

export interface ReservationReceiptConnectionPromise
  extends Promise<ReservationReceiptConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReservationReceiptEdge>>() => T;
  aggregate: <T = AggregateReservationReceiptPromise>() => T;
}

export interface ReservationReceiptConnectionSubscription
  extends Promise<AsyncIterator<ReservationReceiptConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ReservationReceiptEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateReservationReceiptSubscription>() => T;
}

export interface ReservationReceiptEdge {
  node: ReservationReceipt;
  cursor: String;
}

export interface ReservationReceiptEdgePromise
  extends Promise<ReservationReceiptEdge>,
    Fragmentable {
  node: <T = ReservationReceiptPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReservationReceiptEdgeSubscription
  extends Promise<AsyncIterator<ReservationReceiptEdge>>,
    Fragmentable {
  node: <T = ReservationReceiptSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReservationReceipt {
  count: Int;
}

export interface AggregateReservationReceiptPromise
  extends Promise<AggregateReservationReceipt>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReservationReceiptSubscription
  extends Promise<AsyncIterator<AggregateReservationReceipt>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReservationReceiptItemConnection {
  pageInfo: PageInfo;
  edges: ReservationReceiptItemEdge[];
}

export interface ReservationReceiptItemConnectionPromise
  extends Promise<ReservationReceiptItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReservationReceiptItemEdge>>() => T;
  aggregate: <T = AggregateReservationReceiptItemPromise>() => T;
}

export interface ReservationReceiptItemConnectionSubscription
  extends Promise<AsyncIterator<ReservationReceiptItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ReservationReceiptItemEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateReservationReceiptItemSubscription>() => T;
}

export interface ReservationReceiptItemEdge {
  node: ReservationReceiptItem;
  cursor: String;
}

export interface ReservationReceiptItemEdgePromise
  extends Promise<ReservationReceiptItemEdge>,
    Fragmentable {
  node: <T = ReservationReceiptItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReservationReceiptItemEdgeSubscription
  extends Promise<AsyncIterator<ReservationReceiptItemEdge>>,
    Fragmentable {
  node: <T = ReservationReceiptItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReservationReceiptItem {
  count: Int;
}

export interface AggregateReservationReceiptItemPromise
  extends Promise<AggregateReservationReceiptItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReservationReceiptItemSubscription
  extends Promise<AsyncIterator<AggregateReservationReceiptItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SeasonConnection {
  pageInfo: PageInfo;
  edges: SeasonEdge[];
}

export interface SeasonConnectionPromise
  extends Promise<SeasonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeasonEdge>>() => T;
  aggregate: <T = AggregateSeasonPromise>() => T;
}

export interface SeasonConnectionSubscription
  extends Promise<AsyncIterator<SeasonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeasonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeasonSubscription>() => T;
}

export interface SeasonEdge {
  node: Season;
  cursor: String;
}

export interface SeasonEdgePromise extends Promise<SeasonEdge>, Fragmentable {
  node: <T = SeasonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeasonEdgeSubscription
  extends Promise<AsyncIterator<SeasonEdge>>,
    Fragmentable {
  node: <T = SeasonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSeason {
  count: Int;
}

export interface AggregateSeasonPromise
  extends Promise<AggregateSeason>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeasonSubscription
  extends Promise<AsyncIterator<AggregateSeason>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShippingMethodConnection {
  pageInfo: PageInfo;
  edges: ShippingMethodEdge[];
}

export interface ShippingMethodConnectionPromise
  extends Promise<ShippingMethodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShippingMethodEdge>>() => T;
  aggregate: <T = AggregateShippingMethodPromise>() => T;
}

export interface ShippingMethodConnectionSubscription
  extends Promise<AsyncIterator<ShippingMethodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShippingMethodEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShippingMethodSubscription>() => T;
}

export interface ShippingMethodEdge {
  node: ShippingMethod;
  cursor: String;
}

export interface ShippingMethodEdgePromise
  extends Promise<ShippingMethodEdge>,
    Fragmentable {
  node: <T = ShippingMethodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShippingMethodEdgeSubscription
  extends Promise<AsyncIterator<ShippingMethodEdge>>,
    Fragmentable {
  node: <T = ShippingMethodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShippingMethod {
  count: Int;
}

export interface AggregateShippingMethodPromise
  extends Promise<AggregateShippingMethod>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShippingMethodSubscription
  extends Promise<AsyncIterator<AggregateShippingMethod>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShippingOptionConnection {
  pageInfo: PageInfo;
  edges: ShippingOptionEdge[];
}

export interface ShippingOptionConnectionPromise
  extends Promise<ShippingOptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShippingOptionEdge>>() => T;
  aggregate: <T = AggregateShippingOptionPromise>() => T;
}

export interface ShippingOptionConnectionSubscription
  extends Promise<AsyncIterator<ShippingOptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShippingOptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShippingOptionSubscription>() => T;
}

export interface ShippingOptionEdge {
  node: ShippingOption;
  cursor: String;
}

export interface ShippingOptionEdgePromise
  extends Promise<ShippingOptionEdge>,
    Fragmentable {
  node: <T = ShippingOptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShippingOptionEdgeSubscription
  extends Promise<AsyncIterator<ShippingOptionEdge>>,
    Fragmentable {
  node: <T = ShippingOptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShippingOption {
  count: Int;
}

export interface AggregateShippingOptionPromise
  extends Promise<AggregateShippingOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShippingOptionSubscription
  extends Promise<AsyncIterator<AggregateShippingOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShopifyProductVariantConnection {
  pageInfo: PageInfo;
  edges: ShopifyProductVariantEdge[];
}

export interface ShopifyProductVariantConnectionPromise
  extends Promise<ShopifyProductVariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShopifyProductVariantEdge>>() => T;
  aggregate: <T = AggregateShopifyProductVariantPromise>() => T;
}

export interface ShopifyProductVariantConnectionSubscription
  extends Promise<AsyncIterator<ShopifyProductVariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ShopifyProductVariantEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateShopifyProductVariantSubscription>() => T;
}

export interface ShopifyProductVariantEdge {
  node: ShopifyProductVariant;
  cursor: String;
}

export interface ShopifyProductVariantEdgePromise
  extends Promise<ShopifyProductVariantEdge>,
    Fragmentable {
  node: <T = ShopifyProductVariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShopifyProductVariantEdgeSubscription
  extends Promise<AsyncIterator<ShopifyProductVariantEdge>>,
    Fragmentable {
  node: <T = ShopifyProductVariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShopifyProductVariant {
  count: Int;
}

export interface AggregateShopifyProductVariantPromise
  extends Promise<AggregateShopifyProductVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShopifyProductVariantSubscription
  extends Promise<AsyncIterator<AggregateShopifyProductVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SizeConnection {
  pageInfo: PageInfo;
  edges: SizeEdge[];
}

export interface SizeConnectionPromise
  extends Promise<SizeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SizeEdge>>() => T;
  aggregate: <T = AggregateSizePromise>() => T;
}

export interface SizeConnectionSubscription
  extends Promise<AsyncIterator<SizeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SizeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSizeSubscription>() => T;
}

export interface SizeEdge {
  node: Size;
  cursor: String;
}

export interface SizeEdgePromise extends Promise<SizeEdge>, Fragmentable {
  node: <T = SizePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SizeEdgeSubscription
  extends Promise<AsyncIterator<SizeEdge>>,
    Fragmentable {
  node: <T = SizeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSize {
  count: Int;
}

export interface AggregateSizePromise
  extends Promise<AggregateSize>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSizeSubscription
  extends Promise<AsyncIterator<AggregateSize>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SmsReceiptConnection {
  pageInfo: PageInfo;
  edges: SmsReceiptEdge[];
}

export interface SmsReceiptConnectionPromise
  extends Promise<SmsReceiptConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SmsReceiptEdge>>() => T;
  aggregate: <T = AggregateSmsReceiptPromise>() => T;
}

export interface SmsReceiptConnectionSubscription
  extends Promise<AsyncIterator<SmsReceiptConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SmsReceiptEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSmsReceiptSubscription>() => T;
}

export interface SmsReceiptEdge {
  node: SmsReceipt;
  cursor: String;
}

export interface SmsReceiptEdgePromise
  extends Promise<SmsReceiptEdge>,
    Fragmentable {
  node: <T = SmsReceiptPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SmsReceiptEdgeSubscription
  extends Promise<AsyncIterator<SmsReceiptEdge>>,
    Fragmentable {
  node: <T = SmsReceiptSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSmsReceipt {
  count: Int;
}

export interface AggregateSmsReceiptPromise
  extends Promise<AggregateSmsReceipt>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSmsReceiptSubscription
  extends Promise<AsyncIterator<AggregateSmsReceipt>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StylePreferencesConnection {
  pageInfo: PageInfo;
  edges: StylePreferencesEdge[];
}

export interface StylePreferencesConnectionPromise
  extends Promise<StylePreferencesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StylePreferencesEdge>>() => T;
  aggregate: <T = AggregateStylePreferencesPromise>() => T;
}

export interface StylePreferencesConnectionSubscription
  extends Promise<AsyncIterator<StylePreferencesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StylePreferencesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStylePreferencesSubscription>() => T;
}

export interface StylePreferencesEdge {
  node: StylePreferences;
  cursor: String;
}

export interface StylePreferencesEdgePromise
  extends Promise<StylePreferencesEdge>,
    Fragmentable {
  node: <T = StylePreferencesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StylePreferencesEdgeSubscription
  extends Promise<AsyncIterator<StylePreferencesEdge>>,
    Fragmentable {
  node: <T = StylePreferencesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStylePreferences {
  count: Int;
}

export interface AggregateStylePreferencesPromise
  extends Promise<AggregateStylePreferences>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStylePreferencesSubscription
  extends Promise<AsyncIterator<AggregateStylePreferences>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SyncTiming {
  id: ID_Output;
  type: SyncTimingType;
  syncedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SyncTimingPromise extends Promise<SyncTiming>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<SyncTimingType>;
  syncedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SyncTimingSubscription
  extends Promise<AsyncIterator<SyncTiming>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<SyncTimingType>>;
  syncedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SyncTimingNullablePromise
  extends Promise<SyncTiming | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<SyncTimingType>;
  syncedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SyncTimingConnection {
  pageInfo: PageInfo;
  edges: SyncTimingEdge[];
}

export interface SyncTimingConnectionPromise
  extends Promise<SyncTimingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SyncTimingEdge>>() => T;
  aggregate: <T = AggregateSyncTimingPromise>() => T;
}

export interface SyncTimingConnectionSubscription
  extends Promise<AsyncIterator<SyncTimingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SyncTimingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSyncTimingSubscription>() => T;
}

export interface SyncTimingEdge {
  node: SyncTiming;
  cursor: String;
}

export interface SyncTimingEdgePromise
  extends Promise<SyncTimingEdge>,
    Fragmentable {
  node: <T = SyncTimingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SyncTimingEdgeSubscription
  extends Promise<AsyncIterator<SyncTimingEdge>>,
    Fragmentable {
  node: <T = SyncTimingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSyncTiming {
  count: Int;
}

export interface AggregateSyncTimingPromise
  extends Promise<AggregateSyncTiming>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSyncTimingSubscription
  extends Promise<AsyncIterator<AggregateSyncTiming>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopSizeConnection {
  pageInfo: PageInfo;
  edges: TopSizeEdge[];
}

export interface TopSizeConnectionPromise
  extends Promise<TopSizeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopSizeEdge>>() => T;
  aggregate: <T = AggregateTopSizePromise>() => T;
}

export interface TopSizeConnectionSubscription
  extends Promise<AsyncIterator<TopSizeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopSizeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopSizeSubscription>() => T;
}

export interface TopSizeEdge {
  node: TopSize;
  cursor: String;
}

export interface TopSizeEdgePromise extends Promise<TopSizeEdge>, Fragmentable {
  node: <T = TopSizePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopSizeEdgeSubscription
  extends Promise<AsyncIterator<TopSizeEdge>>,
    Fragmentable {
  node: <T = TopSizeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTopSize {
  count: Int;
}

export interface AggregateTopSizePromise
  extends Promise<AggregateTopSize>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopSizeSubscription
  extends Promise<AsyncIterator<AggregateTopSize>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UTMDataConnection {
  pageInfo: PageInfo;
  edges: UTMDataEdge[];
}

export interface UTMDataConnectionPromise
  extends Promise<UTMDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UTMDataEdge>>() => T;
  aggregate: <T = AggregateUTMDataPromise>() => T;
}

export interface UTMDataConnectionSubscription
  extends Promise<AsyncIterator<UTMDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UTMDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUTMDataSubscription>() => T;
}

export interface UTMDataEdge {
  node: UTMData;
  cursor: String;
}

export interface UTMDataEdgePromise extends Promise<UTMDataEdge>, Fragmentable {
  node: <T = UTMDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UTMDataEdgeSubscription
  extends Promise<AsyncIterator<UTMDataEdge>>,
    Fragmentable {
  node: <T = UTMDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUTMData {
  count: Int;
}

export interface AggregateUTMDataPromise
  extends Promise<AggregateUTMData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUTMDataSubscription
  extends Promise<AsyncIterator<AggregateUTMData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPushNotificationConnection {
  pageInfo: PageInfo;
  edges: UserPushNotificationEdge[];
}

export interface UserPushNotificationConnectionPromise
  extends Promise<UserPushNotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserPushNotificationEdge>>() => T;
  aggregate: <T = AggregateUserPushNotificationPromise>() => T;
}

export interface UserPushNotificationConnectionSubscription
  extends Promise<AsyncIterator<UserPushNotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserPushNotificationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserPushNotificationSubscription>() => T;
}

export interface UserPushNotificationEdge {
  node: UserPushNotification;
  cursor: String;
}

export interface UserPushNotificationEdgePromise
  extends Promise<UserPushNotificationEdge>,
    Fragmentable {
  node: <T = UserPushNotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserPushNotificationEdgeSubscription
  extends Promise<AsyncIterator<UserPushNotificationEdge>>,
    Fragmentable {
  node: <T = UserPushNotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserPushNotification {
  count: Int;
}

export interface AggregateUserPushNotificationPromise
  extends Promise<AggregateUserPushNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserPushNotificationSubscription
  extends Promise<AsyncIterator<AggregateUserPushNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPushNotificationInterestConnection {
  pageInfo: PageInfo;
  edges: UserPushNotificationInterestEdge[];
}

export interface UserPushNotificationInterestConnectionPromise
  extends Promise<UserPushNotificationInterestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserPushNotificationInterestEdge>>() => T;
  aggregate: <T = AggregateUserPushNotificationInterestPromise>() => T;
}

export interface UserPushNotificationInterestConnectionSubscription
  extends Promise<AsyncIterator<UserPushNotificationInterestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserPushNotificationInterestEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserPushNotificationInterestSubscription>() => T;
}

export interface UserPushNotificationInterestEdge {
  node: UserPushNotificationInterest;
  cursor: String;
}

export interface UserPushNotificationInterestEdgePromise
  extends Promise<UserPushNotificationInterestEdge>,
    Fragmentable {
  node: <T = UserPushNotificationInterestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserPushNotificationInterestEdgeSubscription
  extends Promise<AsyncIterator<UserPushNotificationInterestEdge>>,
    Fragmentable {
  node: <T = UserPushNotificationInterestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserPushNotificationInterest {
  count: Int;
}

export interface AggregateUserPushNotificationInterestPromise
  extends Promise<AggregateUserPushNotificationInterest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserPushNotificationInterestSubscription
  extends Promise<AsyncIterator<AggregateUserPushNotificationInterest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WarehouseLocationConnection {
  pageInfo: PageInfo;
  edges: WarehouseLocationEdge[];
}

export interface WarehouseLocationConnectionPromise
  extends Promise<WarehouseLocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WarehouseLocationEdge>>() => T;
  aggregate: <T = AggregateWarehouseLocationPromise>() => T;
}

export interface WarehouseLocationConnectionSubscription
  extends Promise<AsyncIterator<WarehouseLocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WarehouseLocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWarehouseLocationSubscription>() => T;
}

export interface WarehouseLocationEdge {
  node: WarehouseLocation;
  cursor: String;
}

export interface WarehouseLocationEdgePromise
  extends Promise<WarehouseLocationEdge>,
    Fragmentable {
  node: <T = WarehouseLocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WarehouseLocationEdgeSubscription
  extends Promise<AsyncIterator<WarehouseLocationEdge>>,
    Fragmentable {
  node: <T = WarehouseLocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWarehouseLocation {
  count: Int;
}

export interface AggregateWarehouseLocationPromise
  extends Promise<AggregateWarehouseLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWarehouseLocationSubscription
  extends Promise<AsyncIterator<AggregateWarehouseLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WarehouseLocationConstraintConnection {
  pageInfo: PageInfo;
  edges: WarehouseLocationConstraintEdge[];
}

export interface WarehouseLocationConstraintConnectionPromise
  extends Promise<WarehouseLocationConstraintConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WarehouseLocationConstraintEdge>>() => T;
  aggregate: <T = AggregateWarehouseLocationConstraintPromise>() => T;
}

export interface WarehouseLocationConstraintConnectionSubscription
  extends Promise<AsyncIterator<WarehouseLocationConstraintConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<WarehouseLocationConstraintEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateWarehouseLocationConstraintSubscription>() => T;
}

export interface WarehouseLocationConstraintEdge {
  node: WarehouseLocationConstraint;
  cursor: String;
}

export interface WarehouseLocationConstraintEdgePromise
  extends Promise<WarehouseLocationConstraintEdge>,
    Fragmentable {
  node: <T = WarehouseLocationConstraintPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WarehouseLocationConstraintEdgeSubscription
  extends Promise<AsyncIterator<WarehouseLocationConstraintEdge>>,
    Fragmentable {
  node: <T = WarehouseLocationConstraintSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWarehouseLocationConstraint {
  count: Int;
}

export interface AggregateWarehouseLocationConstraintPromise
  extends Promise<AggregateWarehouseLocationConstraint>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWarehouseLocationConstraintSubscription
  extends Promise<AsyncIterator<AggregateWarehouseLocationConstraint>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActiveAdminUserSubscriptionPayload {
  mutation: MutationType;
  node: ActiveAdminUser;
  updatedFields: String[];
  previousValues: ActiveAdminUserPreviousValues;
}

export interface ActiveAdminUserSubscriptionPayloadPromise
  extends Promise<ActiveAdminUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActiveAdminUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActiveAdminUserPreviousValuesPromise>() => T;
}

export interface ActiveAdminUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActiveAdminUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActiveAdminUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActiveAdminUserPreviousValuesSubscription>() => T;
}

export interface ActiveAdminUserPreviousValues {
  id: ID_Output;
}

export interface ActiveAdminUserPreviousValuesPromise
  extends Promise<ActiveAdminUserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ActiveAdminUserPreviousValuesSubscription
  extends Promise<AsyncIterator<ActiveAdminUserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AdminActionLogSubscriptionPayload {
  mutation: MutationType;
  node: AdminActionLog;
  updatedFields: String[];
  previousValues: AdminActionLogPreviousValues;
}

export interface AdminActionLogSubscriptionPayloadPromise
  extends Promise<AdminActionLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdminActionLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdminActionLogPreviousValuesPromise>() => T;
}

export interface AdminActionLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdminActionLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdminActionLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdminActionLogPreviousValuesSubscription>() => T;
}

export interface AdminActionLogPreviousValues {
  actionId: Int;
  entityId: String;
  tableName: String;
  triggeredAt: DateTimeOutput;
  action: AdminAction;
  rowData: Json;
  changedFields?: Json;
  statementOnly: Boolean;
}

export interface AdminActionLogPreviousValuesPromise
  extends Promise<AdminActionLogPreviousValues>,
    Fragmentable {
  actionId: () => Promise<Int>;
  entityId: () => Promise<String>;
  tableName: () => Promise<String>;
  triggeredAt: () => Promise<DateTimeOutput>;
  action: () => Promise<AdminAction>;
  rowData: () => Promise<Json>;
  changedFields: () => Promise<Json>;
  statementOnly: () => Promise<Boolean>;
}

export interface AdminActionLogPreviousValuesSubscription
  extends Promise<AsyncIterator<AdminActionLogPreviousValues>>,
    Fragmentable {
  actionId: () => Promise<AsyncIterator<Int>>;
  entityId: () => Promise<AsyncIterator<String>>;
  tableName: () => Promise<AsyncIterator<String>>;
  triggeredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<AdminAction>>;
  rowData: () => Promise<AsyncIterator<Json>>;
  changedFields: () => Promise<AsyncIterator<Json>>;
  statementOnly: () => Promise<AsyncIterator<Boolean>>;
}

export interface BagItemSubscriptionPayload {
  mutation: MutationType;
  node: BagItem;
  updatedFields: String[];
  previousValues: BagItemPreviousValues;
}

export interface BagItemSubscriptionPayloadPromise
  extends Promise<BagItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BagItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BagItemPreviousValuesPromise>() => T;
}

export interface BagItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BagItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BagItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BagItemPreviousValuesSubscription>() => T;
}

export interface BagItemPreviousValues {
  id: ID_Output;
  position?: Int;
  saved?: Boolean;
  status: BagItemStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BagItemPreviousValuesPromise
  extends Promise<BagItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  position: () => Promise<Int>;
  saved: () => Promise<Boolean>;
  status: () => Promise<BagItemStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BagItemPreviousValuesSubscription
  extends Promise<AsyncIterator<BagItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  position: () => Promise<AsyncIterator<Int>>;
  saved: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<BagItemStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BillingInfoSubscriptionPayload {
  mutation: MutationType;
  node: BillingInfo;
  updatedFields: String[];
  previousValues: BillingInfoPreviousValues;
}

export interface BillingInfoSubscriptionPayloadPromise
  extends Promise<BillingInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BillingInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BillingInfoPreviousValuesPromise>() => T;
}

export interface BillingInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BillingInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BillingInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BillingInfoPreviousValuesSubscription>() => T;
}

export interface BillingInfoPreviousValues {
  id: ID_Output;
  brand: String;
  name?: String;
  last_digits: String;
  expiration_month: Int;
  expiration_year: Int;
  street1?: String;
  street2?: String;
  city?: String;
  state?: String;
  country?: String;
  postal_code?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BillingInfoPreviousValuesPromise
  extends Promise<BillingInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  name: () => Promise<String>;
  last_digits: () => Promise<String>;
  expiration_month: () => Promise<Int>;
  expiration_year: () => Promise<Int>;
  street1: () => Promise<String>;
  street2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postal_code: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BillingInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<BillingInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  last_digits: () => Promise<AsyncIterator<String>>;
  expiration_month: () => Promise<AsyncIterator<Int>>;
  expiration_year: () => Promise<AsyncIterator<Int>>;
  street1: () => Promise<AsyncIterator<String>>;
  street2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  postal_code: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BottomSizeSubscriptionPayload {
  mutation: MutationType;
  node: BottomSize;
  updatedFields: String[];
  previousValues: BottomSizePreviousValues;
}

export interface BottomSizeSubscriptionPayloadPromise
  extends Promise<BottomSizeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BottomSizePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BottomSizePreviousValuesPromise>() => T;
}

export interface BottomSizeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BottomSizeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BottomSizeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BottomSizePreviousValuesSubscription>() => T;
}

export interface BottomSizePreviousValues {
  id: ID_Output;
  type?: BottomSizeType;
  value?: String;
  waist?: Float;
  rise?: Float;
  hem?: Float;
  inseam?: Float;
}

export interface BottomSizePreviousValuesPromise
  extends Promise<BottomSizePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<BottomSizeType>;
  value: () => Promise<String>;
  waist: () => Promise<Float>;
  rise: () => Promise<Float>;
  hem: () => Promise<Float>;
  inseam: () => Promise<Float>;
}

export interface BottomSizePreviousValuesSubscription
  extends Promise<AsyncIterator<BottomSizePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<BottomSizeType>>;
  value: () => Promise<AsyncIterator<String>>;
  waist: () => Promise<AsyncIterator<Float>>;
  rise: () => Promise<AsyncIterator<Float>>;
  hem: () => Promise<AsyncIterator<Float>>;
  inseam: () => Promise<AsyncIterator<Float>>;
}

export interface BrandSubscriptionPayload {
  mutation: MutationType;
  node: Brand;
  updatedFields: String[];
  previousValues: BrandPreviousValues;
}

export interface BrandSubscriptionPayloadPromise
  extends Promise<BrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandPreviousValuesPromise>() => T;
}

export interface BrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandPreviousValuesSubscription>() => T;
}

export interface BrandPreviousValues {
  id: ID_Output;
  slug: String;
  brandCode: String;
  description?: String;
  isPrimaryBrand: Boolean;
  logo?: Json;
  name: String;
  designer?: String;
  basedIn?: String;
  since?: DateTimeOutput;
  tier: BrandTier;
  published: Boolean;
  featured: Boolean;
  websiteUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BrandPreviousValuesPromise
  extends Promise<BrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  brandCode: () => Promise<String>;
  description: () => Promise<String>;
  isPrimaryBrand: () => Promise<Boolean>;
  logo: () => Promise<Json>;
  name: () => Promise<String>;
  designer: () => Promise<String>;
  basedIn: () => Promise<String>;
  since: () => Promise<DateTimeOutput>;
  tier: () => Promise<BrandTier>;
  published: () => Promise<Boolean>;
  featured: () => Promise<Boolean>;
  websiteUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BrandPreviousValuesSubscription
  extends Promise<AsyncIterator<BrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  brandCode: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isPrimaryBrand: () => Promise<AsyncIterator<Boolean>>;
  logo: () => Promise<AsyncIterator<Json>>;
  name: () => Promise<AsyncIterator<String>>;
  designer: () => Promise<AsyncIterator<String>>;
  basedIn: () => Promise<AsyncIterator<String>>;
  since: () => Promise<AsyncIterator<DateTimeOutput>>;
  tier: () => Promise<AsyncIterator<BrandTier>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  websiteUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  image?: Json;
  description?: String;
  visible: Boolean;
  updatedAt?: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<Json>;
  description: () => Promise<String>;
  visible: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<Json>>;
  description: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CollectionSubscriptionPayload {
  mutation: MutationType;
  node: Collection;
  updatedFields: String[];
  previousValues: CollectionPreviousValues;
}

export interface CollectionSubscriptionPayloadPromise
  extends Promise<CollectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionPreviousValuesPromise>() => T;
}

export interface CollectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionPreviousValuesSubscription>() => T;
}

export interface CollectionPreviousValues {
  id: ID_Output;
  slug: String;
  title?: String;
  subTitle?: String;
  descriptions: String[];
  published: Boolean;
  placements: CollectionPlacement[];
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface CollectionPreviousValuesPromise
  extends Promise<CollectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  title: () => Promise<String>;
  subTitle: () => Promise<String>;
  descriptions: () => Promise<String[]>;
  published: () => Promise<Boolean>;
  placements: () => Promise<CollectionPlacement[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CollectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  subTitle: () => Promise<AsyncIterator<String>>;
  descriptions: () => Promise<AsyncIterator<String[]>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  placements: () => Promise<AsyncIterator<CollectionPlacement[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ColorSubscriptionPayload {
  mutation: MutationType;
  node: Color;
  updatedFields: String[];
  previousValues: ColorPreviousValues;
}

export interface ColorSubscriptionPayloadPromise
  extends Promise<ColorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ColorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ColorPreviousValuesPromise>() => T;
}

export interface ColorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ColorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ColorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ColorPreviousValuesSubscription>() => T;
}

export interface ColorPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
}

export interface ColorPreviousValuesPromise
  extends Promise<ColorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  colorCode: () => Promise<String>;
  hexCode: () => Promise<String>;
}

export interface ColorPreviousValuesSubscription
  extends Promise<AsyncIterator<ColorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  colorCode: () => Promise<AsyncIterator<String>>;
  hexCode: () => Promise<AsyncIterator<String>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  status?: CustomerStatus;
  plan?: Plan;
  referralLink?: String;
  referrerId?: String;
  authorizedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<CustomerStatus>;
  plan: () => Promise<Plan>;
  referralLink: () => Promise<String>;
  referrerId: () => Promise<String>;
  authorizedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<CustomerStatus>>;
  plan: () => Promise<AsyncIterator<Plan>>;
  referralLink: () => Promise<AsyncIterator<String>>;
  referrerId: () => Promise<AsyncIterator<String>>;
  authorizedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerAdmissionsDataSubscriptionPayload {
  mutation: MutationType;
  node: CustomerAdmissionsData;
  updatedFields: String[];
  previousValues: CustomerAdmissionsDataPreviousValues;
}

export interface CustomerAdmissionsDataSubscriptionPayloadPromise
  extends Promise<CustomerAdmissionsDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerAdmissionsDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerAdmissionsDataPreviousValuesPromise>() => T;
}

export interface CustomerAdmissionsDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerAdmissionsDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerAdmissionsDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerAdmissionsDataPreviousValuesSubscription>() => T;
}

export interface CustomerAdmissionsDataPreviousValues {
  id: ID_Output;
  inServiceableZipcode: Boolean;
  admissable: Boolean;
  inAdmissableReason?: InAdmissableReason;
  allAccessEnabled: Boolean;
  authorizationsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  authorizationWindowClosesAt?: DateTimeOutput;
}

export interface CustomerAdmissionsDataPreviousValuesPromise
  extends Promise<CustomerAdmissionsDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  inServiceableZipcode: () => Promise<Boolean>;
  admissable: () => Promise<Boolean>;
  inAdmissableReason: () => Promise<InAdmissableReason>;
  allAccessEnabled: () => Promise<Boolean>;
  authorizationsCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  authorizationWindowClosesAt: () => Promise<DateTimeOutput>;
}

export interface CustomerAdmissionsDataPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerAdmissionsDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  inServiceableZipcode: () => Promise<AsyncIterator<Boolean>>;
  admissable: () => Promise<AsyncIterator<Boolean>>;
  inAdmissableReason: () => Promise<AsyncIterator<InAdmissableReason>>;
  allAccessEnabled: () => Promise<AsyncIterator<Boolean>>;
  authorizationsCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  authorizationWindowClosesAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerDetailSubscriptionPayload {
  mutation: MutationType;
  node: CustomerDetail;
  updatedFields: String[];
  previousValues: CustomerDetailPreviousValues;
}

export interface CustomerDetailSubscriptionPayloadPromise
  extends Promise<CustomerDetailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerDetailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerDetailPreviousValuesPromise>() => T;
}

export interface CustomerDetailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerDetailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerDetailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerDetailPreviousValuesSubscription>() => T;
}

export interface CustomerDetailPreviousValues {
  id: ID_Output;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  height?: Int;
  weight: Int[];
  bodyType?: String;
  averageTopSize?: String;
  topSizes: String[];
  averageWaistSize?: String;
  waistSizes: Int[];
  averagePantLength?: String;
  preferredPronouns?: String;
  profession?: String;
  partyFrequency?: String;
  travelFrequency?: String;
  shoppingFrequency?: String;
  averageSpend?: String;
  style?: String;
  commuteStyle?: String;
  phoneOS?: String;
  insureShipment: Boolean;
  instagramHandle?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerDetailPreviousValuesPromise
  extends Promise<CustomerDetailPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  height: () => Promise<Int>;
  weight: () => Promise<Int[]>;
  bodyType: () => Promise<String>;
  averageTopSize: () => Promise<String>;
  topSizes: () => Promise<String[]>;
  averageWaistSize: () => Promise<String>;
  waistSizes: () => Promise<Int[]>;
  averagePantLength: () => Promise<String>;
  preferredPronouns: () => Promise<String>;
  profession: () => Promise<String>;
  partyFrequency: () => Promise<String>;
  travelFrequency: () => Promise<String>;
  shoppingFrequency: () => Promise<String>;
  averageSpend: () => Promise<String>;
  style: () => Promise<String>;
  commuteStyle: () => Promise<String>;
  phoneOS: () => Promise<String>;
  insureShipment: () => Promise<Boolean>;
  instagramHandle: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerDetailPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerDetailPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  height: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<Int[]>>;
  bodyType: () => Promise<AsyncIterator<String>>;
  averageTopSize: () => Promise<AsyncIterator<String>>;
  topSizes: () => Promise<AsyncIterator<String[]>>;
  averageWaistSize: () => Promise<AsyncIterator<String>>;
  waistSizes: () => Promise<AsyncIterator<Int[]>>;
  averagePantLength: () => Promise<AsyncIterator<String>>;
  preferredPronouns: () => Promise<AsyncIterator<String>>;
  profession: () => Promise<AsyncIterator<String>>;
  partyFrequency: () => Promise<AsyncIterator<String>>;
  travelFrequency: () => Promise<AsyncIterator<String>>;
  shoppingFrequency: () => Promise<AsyncIterator<String>>;
  averageSpend: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  commuteStyle: () => Promise<AsyncIterator<String>>;
  phoneOS: () => Promise<AsyncIterator<String>>;
  insureShipment: () => Promise<AsyncIterator<Boolean>>;
  instagramHandle: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerMembershipSubscriptionPayload {
  mutation: MutationType;
  node: CustomerMembership;
  updatedFields: String[];
  previousValues: CustomerMembershipPreviousValues;
}

export interface CustomerMembershipSubscriptionPayloadPromise
  extends Promise<CustomerMembershipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerMembershipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerMembershipPreviousValuesPromise>() => T;
}

export interface CustomerMembershipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerMembershipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerMembershipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerMembershipPreviousValuesSubscription>() => T;
}

export interface CustomerMembershipPreviousValues {
  id: ID_Output;
  subscriptionId: String;
  giftId?: String;
}

export interface CustomerMembershipPreviousValuesPromise
  extends Promise<CustomerMembershipPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subscriptionId: () => Promise<String>;
  giftId: () => Promise<String>;
}

export interface CustomerMembershipPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerMembershipPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subscriptionId: () => Promise<AsyncIterator<String>>;
  giftId: () => Promise<AsyncIterator<String>>;
}

export interface EmailReceiptSubscriptionPayload {
  mutation: MutationType;
  node: EmailReceipt;
  updatedFields: String[];
  previousValues: EmailReceiptPreviousValues;
}

export interface EmailReceiptSubscriptionPayloadPromise
  extends Promise<EmailReceiptSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmailReceiptPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmailReceiptPreviousValuesPromise>() => T;
}

export interface EmailReceiptSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmailReceiptSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmailReceiptSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmailReceiptPreviousValuesSubscription>() => T;
}

export interface EmailReceiptPreviousValues {
  id: ID_Output;
  emailId: EmailId;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmailReceiptPreviousValuesPromise
  extends Promise<EmailReceiptPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  emailId: () => Promise<EmailId>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmailReceiptPreviousValuesSubscription
  extends Promise<AsyncIterator<EmailReceiptPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  emailId: () => Promise<AsyncIterator<EmailId>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExternalShopifyIntegrationSubscriptionPayload {
  mutation: MutationType;
  node: ExternalShopifyIntegration;
  updatedFields: String[];
  previousValues: ExternalShopifyIntegrationPreviousValues;
}

export interface ExternalShopifyIntegrationSubscriptionPayloadPromise
  extends Promise<ExternalShopifyIntegrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExternalShopifyIntegrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExternalShopifyIntegrationPreviousValuesPromise>() => T;
}

export interface ExternalShopifyIntegrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExternalShopifyIntegrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExternalShopifyIntegrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ExternalShopifyIntegrationPreviousValuesSubscription
  >() => T;
}

export interface ExternalShopifyIntegrationPreviousValues {
  id: ID_Output;
  shopName: String;
  enabled: Boolean;
  accessToken?: String;
  nonce?: String;
}

export interface ExternalShopifyIntegrationPreviousValuesPromise
  extends Promise<ExternalShopifyIntegrationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  shopName: () => Promise<String>;
  enabled: () => Promise<Boolean>;
  accessToken: () => Promise<String>;
  nonce: () => Promise<String>;
}

export interface ExternalShopifyIntegrationPreviousValuesSubscription
  extends Promise<AsyncIterator<ExternalShopifyIntegrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  shopName: () => Promise<AsyncIterator<String>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  nonce: () => Promise<AsyncIterator<String>>;
}

export interface FitPicSubscriptionPayload {
  mutation: MutationType;
  node: FitPic;
  updatedFields: String[];
  previousValues: FitPicPreviousValues;
}

export interface FitPicSubscriptionPayloadPromise
  extends Promise<FitPicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FitPicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FitPicPreviousValuesPromise>() => T;
}

export interface FitPicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FitPicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FitPicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FitPicPreviousValuesSubscription>() => T;
}

export interface FitPicPreviousValues {
  id: ID_Output;
  includeInstagramHandle: Boolean;
  status: FitPicStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FitPicPreviousValuesPromise
  extends Promise<FitPicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  includeInstagramHandle: () => Promise<Boolean>;
  status: () => Promise<FitPicStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FitPicPreviousValuesSubscription
  extends Promise<AsyncIterator<FitPicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  includeInstagramHandle: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<FitPicStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FitPicReportSubscriptionPayload {
  mutation: MutationType;
  node: FitPicReport;
  updatedFields: String[];
  previousValues: FitPicReportPreviousValues;
}

export interface FitPicReportSubscriptionPayloadPromise
  extends Promise<FitPicReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FitPicReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FitPicReportPreviousValuesPromise>() => T;
}

export interface FitPicReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FitPicReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FitPicReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FitPicReportPreviousValuesSubscription>() => T;
}

export interface FitPicReportPreviousValues {
  id: ID_Output;
  status: FitPicReportStatus;
  reportedAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FitPicReportPreviousValuesPromise
  extends Promise<FitPicReportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<FitPicReportStatus>;
  reportedAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FitPicReportPreviousValuesSubscription
  extends Promise<AsyncIterator<FitPicReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<FitPicReportStatus>>;
  reportedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  caption?: String;
  url: String;
  height?: Int;
  width?: Int;
  title?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  url: () => Promise<String>;
  height: () => Promise<Int>;
  width: () => Promise<Int>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  height: () => Promise<AsyncIterator<Int>>;
  width: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InterestedUserSubscriptionPayload {
  mutation: MutationType;
  node: InterestedUser;
  updatedFields: String[];
  previousValues: InterestedUserPreviousValues;
}

export interface InterestedUserSubscriptionPayloadPromise
  extends Promise<InterestedUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InterestedUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InterestedUserPreviousValuesPromise>() => T;
}

export interface InterestedUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InterestedUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InterestedUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InterestedUserPreviousValuesSubscription>() => T;
}

export interface InterestedUserPreviousValues {
  id: ID_Output;
  email: String;
  zipcode?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InterestedUserPreviousValuesPromise
  extends Promise<InterestedUserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  zipcode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InterestedUserPreviousValuesSubscription
  extends Promise<AsyncIterator<InterestedUserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LabelSubscriptionPayload {
  mutation: MutationType;
  node: Label;
  updatedFields: String[];
  previousValues: LabelPreviousValues;
}

export interface LabelSubscriptionPayloadPromise
  extends Promise<LabelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LabelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LabelPreviousValuesPromise>() => T;
}

export interface LabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LabelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LabelPreviousValuesSubscription>() => T;
}

export interface LabelPreviousValues {
  id: ID_Output;
  name?: String;
  image?: String;
  trackingNumber?: String;
  trackingURL?: String;
}

export interface LabelPreviousValuesPromise
  extends Promise<LabelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  trackingNumber: () => Promise<String>;
  trackingURL: () => Promise<String>;
}

export interface LabelPreviousValuesSubscription
  extends Promise<AsyncIterator<LabelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  trackingNumber: () => Promise<AsyncIterator<String>>;
  trackingURL: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  company?: String;
  description?: String;
  address1?: String;
  address2?: String;
  city?: String;
  country?: String;
  state?: String;
  zipCode: String;
  locationType?: LocationType;
  lat?: Float;
  lng?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  country: () => Promise<String>;
  state: () => Promise<String>;
  zipCode: () => Promise<String>;
  locationType: () => Promise<LocationType>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  locationType: () => Promise<AsyncIterator<LocationType>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PackageSubscriptionPayload {
  mutation: MutationType;
  node: Package;
  updatedFields: String[];
  previousValues: PackagePreviousValues;
}

export interface PackageSubscriptionPayloadPromise
  extends Promise<PackageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PackagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PackagePreviousValuesPromise>() => T;
}

export interface PackageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PackageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PackageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PackagePreviousValuesSubscription>() => T;
}

export interface PackagePreviousValues {
  id: ID_Output;
  transactionID: String;
  weight?: Float;
  cost?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PackagePreviousValuesPromise
  extends Promise<PackagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transactionID: () => Promise<String>;
  weight: () => Promise<Float>;
  cost: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PackagePreviousValuesSubscription
  extends Promise<AsyncIterator<PackagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  transactionID: () => Promise<AsyncIterator<String>>;
  weight: () => Promise<AsyncIterator<Float>>;
  cost: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PackageTransitEventSubscriptionPayload {
  mutation: MutationType;
  node: PackageTransitEvent;
  updatedFields: String[];
  previousValues: PackageTransitEventPreviousValues;
}

export interface PackageTransitEventSubscriptionPayloadPromise
  extends Promise<PackageTransitEventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PackageTransitEventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PackageTransitEventPreviousValuesPromise>() => T;
}

export interface PackageTransitEventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PackageTransitEventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PackageTransitEventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PackageTransitEventPreviousValuesSubscription>() => T;
}

export interface PackageTransitEventPreviousValues {
  id: ID_Output;
  status: PackageTransitEventStatus;
  subStatus: PackageTransitEventSubStatus;
  data: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PackageTransitEventPreviousValuesPromise
  extends Promise<PackageTransitEventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<PackageTransitEventStatus>;
  subStatus: () => Promise<PackageTransitEventSubStatus>;
  data: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PackageTransitEventPreviousValuesSubscription
  extends Promise<AsyncIterator<PackageTransitEventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<PackageTransitEventStatus>>;
  subStatus: () => Promise<AsyncIterator<PackageTransitEventSubStatus>>;
  data: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PauseRequestSubscriptionPayload {
  mutation: MutationType;
  node: PauseRequest;
  updatedFields: String[];
  previousValues: PauseRequestPreviousValues;
}

export interface PauseRequestSubscriptionPayloadPromise
  extends Promise<PauseRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PauseRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PauseRequestPreviousValuesPromise>() => T;
}

export interface PauseRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PauseRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PauseRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PauseRequestPreviousValuesSubscription>() => T;
}

export interface PauseRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  pausePending: Boolean;
  pauseDate?: DateTimeOutput;
  resumeDate?: DateTimeOutput;
  notified: Boolean;
}

export interface PauseRequestPreviousValuesPromise
  extends Promise<PauseRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  pausePending: () => Promise<Boolean>;
  pauseDate: () => Promise<DateTimeOutput>;
  resumeDate: () => Promise<DateTimeOutput>;
  notified: () => Promise<Boolean>;
}

export interface PauseRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<PauseRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  pausePending: () => Promise<AsyncIterator<Boolean>>;
  pauseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  resumeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  notified: () => Promise<AsyncIterator<Boolean>>;
}

export interface PaymentPlanSubscriptionPayload {
  mutation: MutationType;
  node: PaymentPlan;
  updatedFields: String[];
  previousValues: PaymentPlanPreviousValues;
}

export interface PaymentPlanSubscriptionPayloadPromise
  extends Promise<PaymentPlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPlanPreviousValuesPromise>() => T;
}

export interface PaymentPlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentPlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentPlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPlanPreviousValuesSubscription>() => T;
}

export interface PaymentPlanPreviousValues {
  id: ID_Output;
  description?: String;
  planID: String;
  status?: String;
  name?: String;
  price?: Int;
  itemCount?: Int;
  tagline?: String;
  tier?: PaymentPlanTier;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PaymentPlanPreviousValuesPromise
  extends Promise<PaymentPlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  planID: () => Promise<String>;
  status: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  itemCount: () => Promise<Int>;
  tagline: () => Promise<String>;
  tier: () => Promise<PaymentPlanTier>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PaymentPlanPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  planID: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  itemCount: () => Promise<AsyncIterator<Int>>;
  tagline: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<PaymentPlanTier>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PhysicalProductSubscriptionPayload {
  mutation: MutationType;
  node: PhysicalProduct;
  updatedFields: String[];
  previousValues: PhysicalProductPreviousValues;
}

export interface PhysicalProductSubscriptionPayloadPromise
  extends Promise<PhysicalProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhysicalProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhysicalProductPreviousValuesPromise>() => T;
}

export interface PhysicalProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhysicalProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhysicalProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhysicalProductPreviousValuesSubscription>() => T;
}

export interface PhysicalProductPreviousValues {
  id: ID_Output;
  seasonsUID: String;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  offloadMethod?: PhysicalProductOffloadMethod;
  offloadNotes?: String;
  sequenceNumber: Int;
  barcoded?: Boolean;
  dateOrdered?: DateTimeOutput;
  dateReceived?: DateTimeOutput;
  unitCost?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhysicalProductPreviousValuesPromise
  extends Promise<PhysicalProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seasonsUID: () => Promise<String>;
  inventoryStatus: () => Promise<InventoryStatus>;
  productStatus: () => Promise<PhysicalProductStatus>;
  offloadMethod: () => Promise<PhysicalProductOffloadMethod>;
  offloadNotes: () => Promise<String>;
  sequenceNumber: () => Promise<Int>;
  barcoded: () => Promise<Boolean>;
  dateOrdered: () => Promise<DateTimeOutput>;
  dateReceived: () => Promise<DateTimeOutput>;
  unitCost: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProductPreviousValuesSubscription
  extends Promise<AsyncIterator<PhysicalProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seasonsUID: () => Promise<AsyncIterator<String>>;
  inventoryStatus: () => Promise<AsyncIterator<InventoryStatus>>;
  productStatus: () => Promise<AsyncIterator<PhysicalProductStatus>>;
  offloadMethod: () => Promise<AsyncIterator<PhysicalProductOffloadMethod>>;
  offloadNotes: () => Promise<AsyncIterator<String>>;
  sequenceNumber: () => Promise<AsyncIterator<Int>>;
  barcoded: () => Promise<AsyncIterator<Boolean>>;
  dateOrdered: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateReceived: () => Promise<AsyncIterator<DateTimeOutput>>;
  unitCost: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PhysicalProductPriceSubscriptionPayload {
  mutation: MutationType;
  node: PhysicalProductPrice;
  updatedFields: String[];
  previousValues: PhysicalProductPricePreviousValues;
}

export interface PhysicalProductPriceSubscriptionPayloadPromise
  extends Promise<PhysicalProductPriceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhysicalProductPricePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhysicalProductPricePreviousValuesPromise>() => T;
}

export interface PhysicalProductPriceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhysicalProductPriceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhysicalProductPriceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhysicalProductPricePreviousValuesSubscription>() => T;
}

export interface PhysicalProductPricePreviousValues {
  id: ID_Output;
  buyUsedEnabled: Boolean;
  buyUsedPrice?: Float;
}

export interface PhysicalProductPricePreviousValuesPromise
  extends Promise<PhysicalProductPricePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  buyUsedEnabled: () => Promise<Boolean>;
  buyUsedPrice: () => Promise<Float>;
}

export interface PhysicalProductPricePreviousValuesSubscription
  extends Promise<AsyncIterator<PhysicalProductPricePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  buyUsedEnabled: () => Promise<AsyncIterator<Boolean>>;
  buyUsedPrice: () => Promise<AsyncIterator<Float>>;
}

export interface PhysicalProductQualityReportSubscriptionPayload {
  mutation: MutationType;
  node: PhysicalProductQualityReport;
  updatedFields: String[];
  previousValues: PhysicalProductQualityReportPreviousValues;
}

export interface PhysicalProductQualityReportSubscriptionPayloadPromise
  extends Promise<PhysicalProductQualityReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhysicalProductQualityReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = PhysicalProductQualityReportPreviousValuesPromise
  >() => T;
}

export interface PhysicalProductQualityReportSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<PhysicalProductQualityReportSubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhysicalProductQualityReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = PhysicalProductQualityReportPreviousValuesSubscription
  >() => T;
}

export interface PhysicalProductQualityReportPreviousValues {
  id: ID_Output;
  damageType?: PhysicalProductDamageType;
  notes?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhysicalProductQualityReportPreviousValuesPromise
  extends Promise<PhysicalProductQualityReportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  damageType: () => Promise<PhysicalProductDamageType>;
  notes: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProductQualityReportPreviousValuesSubscription
  extends Promise<AsyncIterator<PhysicalProductQualityReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  damageType: () => Promise<AsyncIterator<PhysicalProductDamageType>>;
  notes: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  architecture?: ProductArchitecture;
  description?: String;
  externalURL?: String;
  buyNewEnabled: Boolean;
  innerMaterials: String[];
  modelHeight?: Int;
  name: String;
  outerMaterials: String[];
  photographyStatus?: PhotographyStatus;
  productFit?: ProductFit;
  publishedAt?: DateTimeOutput;
  retailPrice?: Int;
  slug: String;
  status?: ProductStatus;
  type?: ProductType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  architecture: () => Promise<ProductArchitecture>;
  description: () => Promise<String>;
  externalURL: () => Promise<String>;
  buyNewEnabled: () => Promise<Boolean>;
  innerMaterials: () => Promise<String[]>;
  modelHeight: () => Promise<Int>;
  name: () => Promise<String>;
  outerMaterials: () => Promise<String[]>;
  photographyStatus: () => Promise<PhotographyStatus>;
  productFit: () => Promise<ProductFit>;
  publishedAt: () => Promise<DateTimeOutput>;
  retailPrice: () => Promise<Int>;
  slug: () => Promise<String>;
  status: () => Promise<ProductStatus>;
  type: () => Promise<ProductType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  architecture: () => Promise<AsyncIterator<ProductArchitecture>>;
  description: () => Promise<AsyncIterator<String>>;
  externalURL: () => Promise<AsyncIterator<String>>;
  buyNewEnabled: () => Promise<AsyncIterator<Boolean>>;
  innerMaterials: () => Promise<AsyncIterator<String[]>>;
  modelHeight: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  outerMaterials: () => Promise<AsyncIterator<String[]>>;
  photographyStatus: () => Promise<AsyncIterator<PhotographyStatus>>;
  productFit: () => Promise<AsyncIterator<ProductFit>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  retailPrice: () => Promise<AsyncIterator<Int>>;
  slug: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<ProductStatus>>;
  type: () => Promise<AsyncIterator<ProductType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductFunctionSubscriptionPayload {
  mutation: MutationType;
  node: ProductFunction;
  updatedFields: String[];
  previousValues: ProductFunctionPreviousValues;
}

export interface ProductFunctionSubscriptionPayloadPromise
  extends Promise<ProductFunctionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductFunctionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductFunctionPreviousValuesPromise>() => T;
}

export interface ProductFunctionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductFunctionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductFunctionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductFunctionPreviousValuesSubscription>() => T;
}

export interface ProductFunctionPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface ProductFunctionPreviousValuesPromise
  extends Promise<ProductFunctionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductFunctionPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductFunctionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductMaterialCategorySubscriptionPayload {
  mutation: MutationType;
  node: ProductMaterialCategory;
  updatedFields: String[];
  previousValues: ProductMaterialCategoryPreviousValues;
}

export interface ProductMaterialCategorySubscriptionPayloadPromise
  extends Promise<ProductMaterialCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductMaterialCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductMaterialCategoryPreviousValuesPromise>() => T;
}

export interface ProductMaterialCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductMaterialCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductMaterialCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ProductMaterialCategoryPreviousValuesSubscription
  >() => T;
}

export interface ProductMaterialCategoryPreviousValues {
  id: ID_Output;
  slug: String;
  lifeExpectancy: Float;
}

export interface ProductMaterialCategoryPreviousValuesPromise
  extends Promise<ProductMaterialCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  lifeExpectancy: () => Promise<Float>;
}

export interface ProductMaterialCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductMaterialCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  lifeExpectancy: () => Promise<AsyncIterator<Float>>;
}

export interface ProductModelSubscriptionPayload {
  mutation: MutationType;
  node: ProductModel;
  updatedFields: String[];
  previousValues: ProductModelPreviousValues;
}

export interface ProductModelSubscriptionPayloadPromise
  extends Promise<ProductModelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductModelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductModelPreviousValuesPromise>() => T;
}

export interface ProductModelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductModelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductModelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductModelPreviousValuesSubscription>() => T;
}

export interface ProductModelPreviousValues {
  id: ID_Output;
  name: String;
  height: Float;
}

export interface ProductModelPreviousValuesPromise
  extends Promise<ProductModelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  height: () => Promise<Float>;
}

export interface ProductModelPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductModelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  height: () => Promise<AsyncIterator<Float>>;
}

export interface ProductNotificationSubscriptionPayload {
  mutation: MutationType;
  node: ProductNotification;
  updatedFields: String[];
  previousValues: ProductNotificationPreviousValues;
}

export interface ProductNotificationSubscriptionPayloadPromise
  extends Promise<ProductNotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductNotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductNotificationPreviousValuesPromise>() => T;
}

export interface ProductNotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductNotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductNotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductNotificationPreviousValuesSubscription>() => T;
}

export interface ProductNotificationPreviousValues {
  id: ID_Output;
  type: ProductNotificationType;
  shouldNotify: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductNotificationPreviousValuesPromise
  extends Promise<ProductNotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ProductNotificationType>;
  shouldNotify: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductNotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductNotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ProductNotificationType>>;
  shouldNotify: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductRequestSubscriptionPayload {
  mutation: MutationType;
  node: ProductRequest;
  updatedFields: String[];
  previousValues: ProductRequestPreviousValues;
}

export interface ProductRequestSubscriptionPayloadPromise
  extends Promise<ProductRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductRequestPreviousValuesPromise>() => T;
}

export interface ProductRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductRequestPreviousValuesSubscription>() => T;
}

export interface ProductRequestPreviousValues {
  id: ID_Output;
  brand?: String;
  description?: String;
  images: String[];
  name?: String;
  price?: Int;
  priceCurrency?: String;
  productID?: String;
  reason: String;
  sku?: String;
  url: String;
}

export interface ProductRequestPreviousValuesPromise
  extends Promise<ProductRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  images: () => Promise<String[]>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  priceCurrency: () => Promise<String>;
  productID: () => Promise<String>;
  reason: () => Promise<String>;
  sku: () => Promise<String>;
  url: () => Promise<String>;
}

export interface ProductRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  priceCurrency: () => Promise<AsyncIterator<String>>;
  productID: () => Promise<AsyncIterator<String>>;
  reason: () => Promise<AsyncIterator<String>>;
  sku: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ProductSeasonSubscriptionPayload {
  mutation: MutationType;
  node: ProductSeason;
  updatedFields: String[];
  previousValues: ProductSeasonPreviousValues;
}

export interface ProductSeasonSubscriptionPayloadPromise
  extends Promise<ProductSeasonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductSeasonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductSeasonPreviousValuesPromise>() => T;
}

export interface ProductSeasonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSeasonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSeasonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductSeasonPreviousValuesSubscription>() => T;
}

export interface ProductSeasonPreviousValues {
  id: ID_Output;
  wearableSeasons: SeasonString[];
}

export interface ProductSeasonPreviousValuesPromise
  extends Promise<ProductSeasonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  wearableSeasons: () => Promise<SeasonString[]>;
}

export interface ProductSeasonPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductSeasonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  wearableSeasons: () => Promise<AsyncIterator<SeasonString[]>>;
}

export interface ProductTierSubscriptionPayload {
  mutation: MutationType;
  node: ProductTier;
  updatedFields: String[];
  previousValues: ProductTierPreviousValues;
}

export interface ProductTierSubscriptionPayloadPromise
  extends Promise<ProductTierSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductTierPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductTierPreviousValuesPromise>() => T;
}

export interface ProductTierSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductTierSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductTierSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductTierPreviousValuesSubscription>() => T;
}

export interface ProductTierPreviousValues {
  id: ID_Output;
  tier: ProductTierName;
  price: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductTierPreviousValuesPromise
  extends Promise<ProductTierPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tier: () => Promise<ProductTierName>;
  price: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductTierPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductTierPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tier: () => Promise<AsyncIterator<ProductTierName>>;
  price: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductVariantSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariant;
  updatedFields: String[];
  previousValues: ProductVariantPreviousValues;
}

export interface ProductVariantSubscriptionPayloadPromise
  extends Promise<ProductVariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantPreviousValuesPromise>() => T;
}

export interface ProductVariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantPreviousValuesSubscription>() => T;
}

export interface ProductVariantPreviousValues {
  id: ID_Output;
  sku?: String;
  displayShort: String;
  weight?: Float;
  height?: Float;
  productID: String;
  retailPrice?: Float;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  offloaded: Int;
  stored: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductVariantPreviousValuesPromise
  extends Promise<ProductVariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sku: () => Promise<String>;
  displayShort: () => Promise<String>;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  productID: () => Promise<String>;
  retailPrice: () => Promise<Float>;
  total: () => Promise<Int>;
  reservable: () => Promise<Int>;
  reserved: () => Promise<Int>;
  nonReservable: () => Promise<Int>;
  offloaded: () => Promise<Int>;
  stored: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sku: () => Promise<AsyncIterator<String>>;
  displayShort: () => Promise<AsyncIterator<String>>;
  weight: () => Promise<AsyncIterator<Float>>;
  height: () => Promise<AsyncIterator<Float>>;
  productID: () => Promise<AsyncIterator<String>>;
  retailPrice: () => Promise<AsyncIterator<Float>>;
  total: () => Promise<AsyncIterator<Int>>;
  reservable: () => Promise<AsyncIterator<Int>>;
  reserved: () => Promise<AsyncIterator<Int>>;
  nonReservable: () => Promise<AsyncIterator<Int>>;
  offloaded: () => Promise<AsyncIterator<Int>>;
  stored: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductVariantFeedbackSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariantFeedback;
  updatedFields: String[];
  previousValues: ProductVariantFeedbackPreviousValues;
}

export interface ProductVariantFeedbackSubscriptionPayloadPromise
  extends Promise<ProductVariantFeedbackSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantFeedbackPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantFeedbackPreviousValuesPromise>() => T;
}

export interface ProductVariantFeedbackSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantFeedbackSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantFeedbackPreviousValuesSubscription>() => T;
}

export interface ProductVariantFeedbackPreviousValues {
  id: ID_Output;
  isCompleted: Boolean;
}

export interface ProductVariantFeedbackPreviousValuesPromise
  extends Promise<ProductVariantFeedbackPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isCompleted: () => Promise<Boolean>;
}

export interface ProductVariantFeedbackPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isCompleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductVariantFeedbackQuestionSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariantFeedbackQuestion;
  updatedFields: String[];
  previousValues: ProductVariantFeedbackQuestionPreviousValues;
}

export interface ProductVariantFeedbackQuestionSubscriptionPayloadPromise
  extends Promise<ProductVariantFeedbackQuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantFeedbackQuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = ProductVariantFeedbackQuestionPreviousValuesPromise
  >() => T;
}

export interface ProductVariantFeedbackQuestionSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<ProductVariantFeedbackQuestionSubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantFeedbackQuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ProductVariantFeedbackQuestionPreviousValuesSubscription
  >() => T;
}

export interface ProductVariantFeedbackQuestionPreviousValues {
  id: ID_Output;
  options: String[];
  question: String;
  responses: String[];
  type: QuestionType;
}

export interface ProductVariantFeedbackQuestionPreviousValuesPromise
  extends Promise<ProductVariantFeedbackQuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  options: () => Promise<String[]>;
  question: () => Promise<String>;
  responses: () => Promise<String[]>;
  type: () => Promise<QuestionType>;
}

export interface ProductVariantFeedbackQuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantFeedbackQuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  options: () => Promise<AsyncIterator<String[]>>;
  question: () => Promise<AsyncIterator<String>>;
  responses: () => Promise<AsyncIterator<String[]>>;
  type: () => Promise<AsyncIterator<QuestionType>>;
}

export interface ProductVariantPriceSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariantPrice;
  updatedFields: String[];
  previousValues: ProductVariantPricePreviousValues;
}

export interface ProductVariantPriceSubscriptionPayloadPromise
  extends Promise<ProductVariantPriceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantPricePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantPricePreviousValuesPromise>() => T;
}

export interface ProductVariantPriceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantPriceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantPriceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantPricePreviousValuesSubscription>() => T;
}

export interface ProductVariantPricePreviousValues {
  id: ID_Output;
  retailPrice?: Float;
}

export interface ProductVariantPricePreviousValuesPromise
  extends Promise<ProductVariantPricePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  retailPrice: () => Promise<Float>;
}

export interface ProductVariantPricePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantPricePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  retailPrice: () => Promise<AsyncIterator<Float>>;
}

export interface ProductVariantWantSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariantWant;
  updatedFields: String[];
  previousValues: ProductVariantWantPreviousValues;
}

export interface ProductVariantWantSubscriptionPayloadPromise
  extends Promise<ProductVariantWantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantWantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantWantPreviousValuesPromise>() => T;
}

export interface ProductVariantWantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantWantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantWantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantWantPreviousValuesSubscription>() => T;
}

export interface ProductVariantWantPreviousValues {
  id: ID_Output;
  isFulfilled: Boolean;
}

export interface ProductVariantWantPreviousValuesPromise
  extends Promise<ProductVariantWantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isFulfilled: () => Promise<Boolean>;
}

export interface ProductVariantWantPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantWantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isFulfilled: () => Promise<AsyncIterator<Boolean>>;
}

export interface PushNotificationReceiptSubscriptionPayload {
  mutation: MutationType;
  node: PushNotificationReceipt;
  updatedFields: String[];
  previousValues: PushNotificationReceiptPreviousValues;
}

export interface PushNotificationReceiptSubscriptionPayloadPromise
  extends Promise<PushNotificationReceiptSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PushNotificationReceiptPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PushNotificationReceiptPreviousValuesPromise>() => T;
}

export interface PushNotificationReceiptSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PushNotificationReceiptSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PushNotificationReceiptSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = PushNotificationReceiptPreviousValuesSubscription
  >() => T;
}

export interface PushNotificationReceiptPreviousValues {
  id: ID_Output;
  route?: String;
  screen?: String;
  uri?: String;
  interest?: String;
  body: String;
  title?: String;
  recordID?: String;
  recordSlug?: String;
  notificationKey?: String;
  sentAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PushNotificationReceiptPreviousValuesPromise
  extends Promise<PushNotificationReceiptPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  route: () => Promise<String>;
  screen: () => Promise<String>;
  uri: () => Promise<String>;
  interest: () => Promise<String>;
  body: () => Promise<String>;
  title: () => Promise<String>;
  recordID: () => Promise<String>;
  recordSlug: () => Promise<String>;
  notificationKey: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PushNotificationReceiptPreviousValuesSubscription
  extends Promise<AsyncIterator<PushNotificationReceiptPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  route: () => Promise<AsyncIterator<String>>;
  screen: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  interest: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  recordID: () => Promise<AsyncIterator<String>>;
  recordSlug: () => Promise<AsyncIterator<String>>;
  notificationKey: () => Promise<AsyncIterator<String>>;
  sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RecentlyViewedProductSubscriptionPayload {
  mutation: MutationType;
  node: RecentlyViewedProduct;
  updatedFields: String[];
  previousValues: RecentlyViewedProductPreviousValues;
}

export interface RecentlyViewedProductSubscriptionPayloadPromise
  extends Promise<RecentlyViewedProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecentlyViewedProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecentlyViewedProductPreviousValuesPromise>() => T;
}

export interface RecentlyViewedProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecentlyViewedProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecentlyViewedProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecentlyViewedProductPreviousValuesSubscription>() => T;
}

export interface RecentlyViewedProductPreviousValues {
  id: ID_Output;
  viewCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RecentlyViewedProductPreviousValuesPromise
  extends Promise<RecentlyViewedProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  viewCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RecentlyViewedProductPreviousValuesSubscription
  extends Promise<AsyncIterator<RecentlyViewedProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  viewCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationSubscriptionPayload {
  mutation: MutationType;
  node: Reservation;
  updatedFields: String[];
  previousValues: ReservationPreviousValues;
}

export interface ReservationSubscriptionPayloadPromise
  extends Promise<ReservationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReservationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReservationPreviousValuesPromise>() => T;
}

export interface ReservationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReservationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReservationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReservationPreviousValuesSubscription>() => T;
}

export interface ReservationPreviousValues {
  id: ID_Output;
  reservationNumber: Int;
  phase: ReservationPhase;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: DateTimeOutput;
  receivedAt?: DateTimeOutput;
  reminderSentAt?: DateTimeOutput;
  statusUpdatedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReservationPreviousValuesPromise
  extends Promise<ReservationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reservationNumber: () => Promise<Int>;
  phase: () => Promise<ReservationPhase>;
  shipped: () => Promise<Boolean>;
  status: () => Promise<ReservationStatus>;
  shippedAt: () => Promise<DateTimeOutput>;
  receivedAt: () => Promise<DateTimeOutput>;
  reminderSentAt: () => Promise<DateTimeOutput>;
  statusUpdatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationPreviousValuesSubscription
  extends Promise<AsyncIterator<ReservationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reservationNumber: () => Promise<AsyncIterator<Int>>;
  phase: () => Promise<AsyncIterator<ReservationPhase>>;
  shipped: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<ReservationStatus>>;
  shippedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  receivedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  reminderSentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  statusUpdatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationFeedbackSubscriptionPayload {
  mutation: MutationType;
  node: ReservationFeedback;
  updatedFields: String[];
  previousValues: ReservationFeedbackPreviousValues;
}

export interface ReservationFeedbackSubscriptionPayloadPromise
  extends Promise<ReservationFeedbackSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReservationFeedbackPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReservationFeedbackPreviousValuesPromise>() => T;
}

export interface ReservationFeedbackSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReservationFeedbackSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReservationFeedbackSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReservationFeedbackPreviousValuesSubscription>() => T;
}

export interface ReservationFeedbackPreviousValues {
  id: ID_Output;
  comment?: String;
  rating?: Rating;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  respondedAt?: DateTimeOutput;
}

export interface ReservationFeedbackPreviousValuesPromise
  extends Promise<ReservationFeedbackPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  rating: () => Promise<Rating>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  respondedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationFeedbackPreviousValuesSubscription
  extends Promise<AsyncIterator<ReservationFeedbackPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  comment: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Rating>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  respondedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationReceiptSubscriptionPayload {
  mutation: MutationType;
  node: ReservationReceipt;
  updatedFields: String[];
  previousValues: ReservationReceiptPreviousValues;
}

export interface ReservationReceiptSubscriptionPayloadPromise
  extends Promise<ReservationReceiptSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReservationReceiptPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReservationReceiptPreviousValuesPromise>() => T;
}

export interface ReservationReceiptSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReservationReceiptSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReservationReceiptSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReservationReceiptPreviousValuesSubscription>() => T;
}

export interface ReservationReceiptPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReservationReceiptPreviousValuesPromise
  extends Promise<ReservationReceiptPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationReceiptPreviousValuesSubscription
  extends Promise<AsyncIterator<ReservationReceiptPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationReceiptItemSubscriptionPayload {
  mutation: MutationType;
  node: ReservationReceiptItem;
  updatedFields: String[];
  previousValues: ReservationReceiptItemPreviousValues;
}

export interface ReservationReceiptItemSubscriptionPayloadPromise
  extends Promise<ReservationReceiptItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReservationReceiptItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReservationReceiptItemPreviousValuesPromise>() => T;
}

export interface ReservationReceiptItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReservationReceiptItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReservationReceiptItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReservationReceiptItemPreviousValuesSubscription>() => T;
}

export interface ReservationReceiptItemPreviousValues {
  id: ID_Output;
  productStatus: PhysicalProductStatus;
  notes?: String;
}

export interface ReservationReceiptItemPreviousValuesPromise
  extends Promise<ReservationReceiptItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productStatus: () => Promise<PhysicalProductStatus>;
  notes: () => Promise<String>;
}

export interface ReservationReceiptItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ReservationReceiptItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productStatus: () => Promise<AsyncIterator<PhysicalProductStatus>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface SeasonSubscriptionPayload {
  mutation: MutationType;
  node: Season;
  updatedFields: String[];
  previousValues: SeasonPreviousValues;
}

export interface SeasonSubscriptionPayloadPromise
  extends Promise<SeasonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeasonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeasonPreviousValuesPromise>() => T;
}

export interface SeasonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeasonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeasonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeasonPreviousValuesSubscription>() => T;
}

export interface SeasonPreviousValues {
  id: ID_Output;
  year?: Int;
  seasonCode?: SeasonCode;
}

export interface SeasonPreviousValuesPromise
  extends Promise<SeasonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  year: () => Promise<Int>;
  seasonCode: () => Promise<SeasonCode>;
}

export interface SeasonPreviousValuesSubscription
  extends Promise<AsyncIterator<SeasonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  year: () => Promise<AsyncIterator<Int>>;
  seasonCode: () => Promise<AsyncIterator<SeasonCode>>;
}

export interface ShippingMethodSubscriptionPayload {
  mutation: MutationType;
  node: ShippingMethod;
  updatedFields: String[];
  previousValues: ShippingMethodPreviousValues;
}

export interface ShippingMethodSubscriptionPayloadPromise
  extends Promise<ShippingMethodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShippingMethodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShippingMethodPreviousValuesPromise>() => T;
}

export interface ShippingMethodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShippingMethodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShippingMethodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShippingMethodPreviousValuesSubscription>() => T;
}

export interface ShippingMethodPreviousValues {
  id: ID_Output;
  code: ShippingCode;
  displayText: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShippingMethodPreviousValuesPromise
  extends Promise<ShippingMethodPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<ShippingCode>;
  displayText: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShippingMethodPreviousValuesSubscription
  extends Promise<AsyncIterator<ShippingMethodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<ShippingCode>>;
  displayText: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShippingOptionSubscriptionPayload {
  mutation: MutationType;
  node: ShippingOption;
  updatedFields: String[];
  previousValues: ShippingOptionPreviousValues;
}

export interface ShippingOptionSubscriptionPayloadPromise
  extends Promise<ShippingOptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShippingOptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShippingOptionPreviousValuesPromise>() => T;
}

export interface ShippingOptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShippingOptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShippingOptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShippingOptionPreviousValuesSubscription>() => T;
}

export interface ShippingOptionPreviousValues {
  id: ID_Output;
  externalCost?: Int;
  averageDuration?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShippingOptionPreviousValuesPromise
  extends Promise<ShippingOptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  externalCost: () => Promise<Int>;
  averageDuration: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShippingOptionPreviousValuesSubscription
  extends Promise<AsyncIterator<ShippingOptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  externalCost: () => Promise<AsyncIterator<Int>>;
  averageDuration: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShopifyProductVariantSubscriptionPayload {
  mutation: MutationType;
  node: ShopifyProductVariant;
  updatedFields: String[];
  previousValues: ShopifyProductVariantPreviousValues;
}

export interface ShopifyProductVariantSubscriptionPayloadPromise
  extends Promise<ShopifyProductVariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShopifyProductVariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShopifyProductVariantPreviousValuesPromise>() => T;
}

export interface ShopifyProductVariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShopifyProductVariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShopifyProductVariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShopifyProductVariantPreviousValuesSubscription>() => T;
}

export interface ShopifyProductVariantPreviousValues {
  id: ID_Output;
  externalId?: String;
  cachedPrice?: Float;
  cachedAvailableForSale?: Boolean;
  cacheExpiresAt?: DateTimeOutput;
}

export interface ShopifyProductVariantPreviousValuesPromise
  extends Promise<ShopifyProductVariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  externalId: () => Promise<String>;
  cachedPrice: () => Promise<Float>;
  cachedAvailableForSale: () => Promise<Boolean>;
  cacheExpiresAt: () => Promise<DateTimeOutput>;
}

export interface ShopifyProductVariantPreviousValuesSubscription
  extends Promise<AsyncIterator<ShopifyProductVariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  externalId: () => Promise<AsyncIterator<String>>;
  cachedPrice: () => Promise<AsyncIterator<Float>>;
  cachedAvailableForSale: () => Promise<AsyncIterator<Boolean>>;
  cacheExpiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SizeSubscriptionPayload {
  mutation: MutationType;
  node: Size;
  updatedFields: String[];
  previousValues: SizePreviousValues;
}

export interface SizeSubscriptionPayloadPromise
  extends Promise<SizeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SizePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SizePreviousValuesPromise>() => T;
}

export interface SizeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SizeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SizeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SizePreviousValuesSubscription>() => T;
}

export interface SizePreviousValues {
  id: ID_Output;
  slug: String;
  productType?: ProductType;
  display: String;
}

export interface SizePreviousValuesPromise
  extends Promise<SizePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  productType: () => Promise<ProductType>;
  display: () => Promise<String>;
}

export interface SizePreviousValuesSubscription
  extends Promise<AsyncIterator<SizePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  productType: () => Promise<AsyncIterator<ProductType>>;
  display: () => Promise<AsyncIterator<String>>;
}

export interface SmsReceiptSubscriptionPayload {
  mutation: MutationType;
  node: SmsReceipt;
  updatedFields: String[];
  previousValues: SmsReceiptPreviousValues;
}

export interface SmsReceiptSubscriptionPayloadPromise
  extends Promise<SmsReceiptSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SmsReceiptPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SmsReceiptPreviousValuesPromise>() => T;
}

export interface SmsReceiptSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SmsReceiptSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SmsReceiptSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SmsReceiptPreviousValuesSubscription>() => T;
}

export interface SmsReceiptPreviousValues {
  id: ID_Output;
  externalId?: String;
  body: String;
  mediaUrls: String[];
  status: SmsStatus;
  smsId?: String;
  sentAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SmsReceiptPreviousValuesPromise
  extends Promise<SmsReceiptPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  externalId: () => Promise<String>;
  body: () => Promise<String>;
  mediaUrls: () => Promise<String[]>;
  status: () => Promise<SmsStatus>;
  smsId: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SmsReceiptPreviousValuesSubscription
  extends Promise<AsyncIterator<SmsReceiptPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  externalId: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  mediaUrls: () => Promise<AsyncIterator<String[]>>;
  status: () => Promise<AsyncIterator<SmsStatus>>;
  smsId: () => Promise<AsyncIterator<String>>;
  sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StylePreferencesSubscriptionPayload {
  mutation: MutationType;
  node: StylePreferences;
  updatedFields: String[];
  previousValues: StylePreferencesPreviousValues;
}

export interface StylePreferencesSubscriptionPayloadPromise
  extends Promise<StylePreferencesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StylePreferencesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StylePreferencesPreviousValuesPromise>() => T;
}

export interface StylePreferencesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StylePreferencesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StylePreferencesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StylePreferencesPreviousValuesSubscription>() => T;
}

export interface StylePreferencesPreviousValues {
  id: ID_Output;
  styles: String[];
  patterns: String[];
  colors: String[];
  brands: String[];
}

export interface StylePreferencesPreviousValuesPromise
  extends Promise<StylePreferencesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  styles: () => Promise<String[]>;
  patterns: () => Promise<String[]>;
  colors: () => Promise<String[]>;
  brands: () => Promise<String[]>;
}

export interface StylePreferencesPreviousValuesSubscription
  extends Promise<AsyncIterator<StylePreferencesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  styles: () => Promise<AsyncIterator<String[]>>;
  patterns: () => Promise<AsyncIterator<String[]>>;
  colors: () => Promise<AsyncIterator<String[]>>;
  brands: () => Promise<AsyncIterator<String[]>>;
}

export interface SyncTimingSubscriptionPayload {
  mutation: MutationType;
  node: SyncTiming;
  updatedFields: String[];
  previousValues: SyncTimingPreviousValues;
}

export interface SyncTimingSubscriptionPayloadPromise
  extends Promise<SyncTimingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SyncTimingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SyncTimingPreviousValuesPromise>() => T;
}

export interface SyncTimingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SyncTimingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SyncTimingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SyncTimingPreviousValuesSubscription>() => T;
}

export interface SyncTimingPreviousValues {
  id: ID_Output;
  type: SyncTimingType;
  syncedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SyncTimingPreviousValuesPromise
  extends Promise<SyncTimingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<SyncTimingType>;
  syncedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SyncTimingPreviousValuesSubscription
  extends Promise<AsyncIterator<SyncTimingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<SyncTimingType>>;
  syncedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TopSizeSubscriptionPayload {
  mutation: MutationType;
  node: TopSize;
  updatedFields: String[];
  previousValues: TopSizePreviousValues;
}

export interface TopSizeSubscriptionPayloadPromise
  extends Promise<TopSizeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopSizePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopSizePreviousValuesPromise>() => T;
}

export interface TopSizeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopSizeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopSizeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopSizePreviousValuesSubscription>() => T;
}

export interface TopSizePreviousValues {
  id: ID_Output;
  letter?: LetterSize;
  sleeve?: Float;
  shoulder?: Float;
  chest?: Float;
  neck?: Float;
  length?: Float;
}

export interface TopSizePreviousValuesPromise
  extends Promise<TopSizePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  letter: () => Promise<LetterSize>;
  sleeve: () => Promise<Float>;
  shoulder: () => Promise<Float>;
  chest: () => Promise<Float>;
  neck: () => Promise<Float>;
  length: () => Promise<Float>;
}

export interface TopSizePreviousValuesSubscription
  extends Promise<AsyncIterator<TopSizePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  letter: () => Promise<AsyncIterator<LetterSize>>;
  sleeve: () => Promise<AsyncIterator<Float>>;
  shoulder: () => Promise<AsyncIterator<Float>>;
  chest: () => Promise<AsyncIterator<Float>>;
  neck: () => Promise<AsyncIterator<Float>>;
  length: () => Promise<AsyncIterator<Float>>;
}

export interface UTMDataSubscriptionPayload {
  mutation: MutationType;
  node: UTMData;
  updatedFields: String[];
  previousValues: UTMDataPreviousValues;
}

export interface UTMDataSubscriptionPayloadPromise
  extends Promise<UTMDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UTMDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UTMDataPreviousValuesPromise>() => T;
}

export interface UTMDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UTMDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UTMDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UTMDataPreviousValuesSubscription>() => T;
}

export interface UTMDataPreviousValues {
  id: ID_Output;
  source?: String;
  medium?: String;
  campaign?: String;
  term?: String;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UTMDataPreviousValuesPromise
  extends Promise<UTMDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  source: () => Promise<String>;
  medium: () => Promise<String>;
  campaign: () => Promise<String>;
  term: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UTMDataPreviousValuesSubscription
  extends Promise<AsyncIterator<UTMDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  source: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  campaign: () => Promise<AsyncIterator<String>>;
  term: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  roles: UserRole[];
  pushNotificationStatus: PushNotificationStatus;
  sendSystemEmails: Boolean;
  verificationStatus: UserVerificationStatus;
  verificationMethod: UserVerificationMethod;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  auth0Id: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
  roles: () => Promise<UserRole[]>;
  pushNotificationStatus: () => Promise<PushNotificationStatus>;
  sendSystemEmails: () => Promise<Boolean>;
  verificationStatus: () => Promise<UserVerificationStatus>;
  verificationMethod: () => Promise<UserVerificationMethod>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  auth0Id: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  roles: () => Promise<AsyncIterator<UserRole[]>>;
  pushNotificationStatus: () => Promise<AsyncIterator<PushNotificationStatus>>;
  sendSystemEmails: () => Promise<AsyncIterator<Boolean>>;
  verificationStatus: () => Promise<AsyncIterator<UserVerificationStatus>>;
  verificationMethod: () => Promise<AsyncIterator<UserVerificationMethod>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserPushNotificationSubscriptionPayload {
  mutation: MutationType;
  node: UserPushNotification;
  updatedFields: String[];
  previousValues: UserPushNotificationPreviousValues;
}

export interface UserPushNotificationSubscriptionPayloadPromise
  extends Promise<UserPushNotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPushNotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPushNotificationPreviousValuesPromise>() => T;
}

export interface UserPushNotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserPushNotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserPushNotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPushNotificationPreviousValuesSubscription>() => T;
}

export interface UserPushNotificationPreviousValues {
  id: ID_Output;
  status: Boolean;
}

export interface UserPushNotificationPreviousValuesPromise
  extends Promise<UserPushNotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Boolean>;
}

export interface UserPushNotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPushNotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserPushNotificationInterestSubscriptionPayload {
  mutation: MutationType;
  node: UserPushNotificationInterest;
  updatedFields: String[];
  previousValues: UserPushNotificationInterestPreviousValues;
}

export interface UserPushNotificationInterestSubscriptionPayloadPromise
  extends Promise<UserPushNotificationInterestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPushNotificationInterestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = UserPushNotificationInterestPreviousValuesPromise
  >() => T;
}

export interface UserPushNotificationInterestSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<UserPushNotificationInterestSubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserPushNotificationInterestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = UserPushNotificationInterestPreviousValuesSubscription
  >() => T;
}

export interface UserPushNotificationInterestPreviousValues {
  id: ID_Output;
  type: UserPushNotificationInterestType;
  value: String;
  status: Boolean;
}

export interface UserPushNotificationInterestPreviousValuesPromise
  extends Promise<UserPushNotificationInterestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<UserPushNotificationInterestType>;
  value: () => Promise<String>;
  status: () => Promise<Boolean>;
}

export interface UserPushNotificationInterestPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPushNotificationInterestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<UserPushNotificationInterestType>>;
  value: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Boolean>>;
}

export interface WarehouseLocationSubscriptionPayload {
  mutation: MutationType;
  node: WarehouseLocation;
  updatedFields: String[];
  previousValues: WarehouseLocationPreviousValues;
}

export interface WarehouseLocationSubscriptionPayloadPromise
  extends Promise<WarehouseLocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WarehouseLocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WarehouseLocationPreviousValuesPromise>() => T;
}

export interface WarehouseLocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WarehouseLocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WarehouseLocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WarehouseLocationPreviousValuesSubscription>() => T;
}

export interface WarehouseLocationPreviousValues {
  id: ID_Output;
  type: WarehouseLocationType;
  barcode: String;
  locationCode: String;
  itemCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WarehouseLocationPreviousValuesPromise
  extends Promise<WarehouseLocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<WarehouseLocationType>;
  barcode: () => Promise<String>;
  locationCode: () => Promise<String>;
  itemCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WarehouseLocationPreviousValuesSubscription
  extends Promise<AsyncIterator<WarehouseLocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<WarehouseLocationType>>;
  barcode: () => Promise<AsyncIterator<String>>;
  locationCode: () => Promise<AsyncIterator<String>>;
  itemCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WarehouseLocationConstraintSubscriptionPayload {
  mutation: MutationType;
  node: WarehouseLocationConstraint;
  updatedFields: String[];
  previousValues: WarehouseLocationConstraintPreviousValues;
}

export interface WarehouseLocationConstraintSubscriptionPayloadPromise
  extends Promise<WarehouseLocationConstraintSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WarehouseLocationConstraintPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WarehouseLocationConstraintPreviousValuesPromise>() => T;
}

export interface WarehouseLocationConstraintSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<WarehouseLocationConstraintSubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WarehouseLocationConstraintSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = WarehouseLocationConstraintPreviousValuesSubscription
  >() => T;
}

export interface WarehouseLocationConstraintPreviousValues {
  id: ID_Output;
  limit: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WarehouseLocationConstraintPreviousValuesPromise
  extends Promise<WarehouseLocationConstraintPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  limit: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WarehouseLocationConstraintPreviousValuesSubscription
  extends Promise<AsyncIterator<WarehouseLocationConstraintPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  limit: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ProductTierName",
    embedded: false
  },
  {
    name: "BrandTier",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "LocationType",
    embedded: false
  },
  {
    name: "CustomerStatus",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "InventoryStatus",
    embedded: false
  },
  {
    name: "PhysicalProductStatus",
    embedded: false
  },
  {
    name: "PhysicalProductOffloadMethod",
    embedded: false
  },
  {
    name: "ProductStatus",
    embedded: false
  },
  {
    name: "ReservationStatus",
    embedded: false
  },
  {
    name: "BagItemStatus",
    embedded: false
  },
  {
    name: "Plan",
    embedded: false
  },
  {
    name: "ProductType",
    embedded: false
  },
  {
    name: "BottomSizeType",
    embedded: false
  },
  {
    name: "QuestionType",
    embedded: false
  },
  {
    name: "Rating",
    embedded: false
  },
  {
    name: "LetterSize",
    embedded: false
  },
  {
    name: "ProductArchitecture",
    embedded: false
  },
  {
    name: "WarehouseLocationType",
    embedded: false
  },
  {
    name: "PhotographyStatus",
    embedded: false
  },
  {
    name: "EmailId",
    embedded: false
  },
  {
    name: "PackageTransitEventStatus",
    embedded: false
  },
  {
    name: "PackageTransitEventSubStatus",
    embedded: false
  },
  {
    name: "ReservationPhase",
    embedded: false
  },
  {
    name: "UserPushNotificationInterestType",
    embedded: false
  },
  {
    name: "InAdmissableReason",
    embedded: false
  },
  {
    name: "ShippingCode",
    embedded: false
  },
  {
    name: "ExternalShopifyIntegration",
    embedded: false
  },
  {
    name: "Brand",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Color",
    embedded: false
  },
  {
    name: "Collection",
    embedded: false
  },
  {
    name: "CollectionPlacement",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductTier",
    embedded: false
  },
  {
    name: "Season",
    embedded: false
  },
  {
    name: "ProductSeason",
    embedded: false
  },
  {
    name: "ProductMaterialCategory",
    embedded: false
  },
  {
    name: "ProductModel",
    embedded: false
  },
  {
    name: "ProductFunction",
    embedded: false
  },
  {
    name: "ProductVariantPrice",
    embedded: false
  },
  {
    name: "ShopifyProductVariant",
    embedded: false
  },
  {
    name: "ProductVariant",
    embedded: false
  },
  {
    name: "PhysicalProductPrice",
    embedded: false
  },
  {
    name: "PhysicalProductDamageType",
    embedded: false
  },
  {
    name: "PhysicalProductQualityReport",
    embedded: false
  },
  {
    name: "PhysicalProduct",
    embedded: false
  },
  {
    name: "ProductNotification",
    embedded: false
  },
  {
    name: "ProductFit",
    embedded: false
  },
  {
    name: "ProductNotificationType",
    embedded: false
  },
  {
    name: "WarehouseLocationConstraint",
    embedded: false
  },
  {
    name: "WarehouseLocation",
    embedded: false
  },
  {
    name: "PaymentPlan",
    embedded: false
  },
  {
    name: "PaymentPlanTier",
    embedded: false
  },
  {
    name: "EmailReceipt",
    embedded: false
  },
  {
    name: "SmsStatus",
    embedded: false
  },
  {
    name: "SmsReceipt",
    embedded: false
  },
  {
    name: "PushNotificationReceipt",
    embedded: false
  },
  {
    name: "SeasonCode",
    embedded: false
  },
  {
    name: "SeasonString",
    embedded: false
  },
  {
    name: "UserVerificationMethod",
    embedded: false
  },
  {
    name: "UserVerificationStatus",
    embedded: false
  },
  {
    name: "PushNotificationStatus",
    embedded: false
  },
  {
    name: "FitPicStatus",
    embedded: false
  },
  {
    name: "FitPic",
    embedded: false
  },
  {
    name: "FitPicReportStatus",
    embedded: false
  },
  {
    name: "FitPicReport",
    embedded: false
  },
  {
    name: "InterestedUser",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "StylePreferences",
    embedded: false
  },
  {
    name: "CustomerDetail",
    embedded: false
  },
  {
    name: "BagItem",
    embedded: false
  },
  {
    name: "CustomerAdmissionsData",
    embedded: false
  },
  {
    name: "UTMData",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "CustomerMembership",
    embedded: false
  },
  {
    name: "PauseRequest",
    embedded: false
  },
  {
    name: "RecentlyViewedProduct",
    embedded: false
  },
  {
    name: "Reservation",
    embedded: false
  },
  {
    name: "ReservationFeedback",
    embedded: false
  },
  {
    name: "ProductVariantFeedback",
    embedded: false
  },
  {
    name: "ProductVariantFeedbackQuestion",
    embedded: false
  },
  {
    name: "ReservationReceipt",
    embedded: false
  },
  {
    name: "ReservationReceiptItem",
    embedded: false
  },
  {
    name: "UserPushNotificationInterest",
    embedded: false
  },
  {
    name: "UserPushNotification",
    embedded: false
  },
  {
    name: "Package",
    embedded: false
  },
  {
    name: "PackageTransitEvent",
    embedded: false
  },
  {
    name: "ShippingMethod",
    embedded: false
  },
  {
    name: "ShippingOption",
    embedded: false
  },
  {
    name: "Label",
    embedded: false
  },
  {
    name: "BillingInfo",
    embedded: false
  },
  {
    name: "ProductRequest",
    embedded: false
  },
  {
    name: "ProductVariantWant",
    embedded: false
  },
  {
    name: "TopSize",
    embedded: false
  },
  {
    name: "BottomSize",
    embedded: false
  },
  {
    name: "Size",
    embedded: false
  },
  {
    name: "ActiveAdminUser",
    embedded: false
  },
  {
    name: "AdminAction",
    embedded: false
  },
  {
    name: "AdminActionLog",
    embedded: false
  },
  {
    name: "SyncTimingType",
    embedded: false
  },
  {
    name: "SyncTiming",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
