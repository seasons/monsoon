// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  bagItem: (where?: BagItemWhereInput) => Promise<boolean>;
  billingInfo: (where?: BillingInfoWhereInput) => Promise<boolean>;
  brand: (where?: BrandWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  collection: (where?: CollectionWhereInput) => Promise<boolean>;
  collectionGroup: (where?: CollectionGroupWhereInput) => Promise<boolean>;
  color: (where?: ColorWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  customerDetail: (where?: CustomerDetailWhereInput) => Promise<boolean>;
  homepageProductRail: (
    where?: HomepageProductRailWhereInput
  ) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  label: (where?: LabelWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  package: (where?: PackageWhereInput) => Promise<boolean>;
  physicalProduct: (where?: PhysicalProductWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productFunction: (where?: ProductFunctionWhereInput) => Promise<boolean>;
  productRequest: (where?: ProductRequestWhereInput) => Promise<boolean>;
  productVariant: (where?: ProductVariantWhereInput) => Promise<boolean>;
  reservation: (where?: ReservationWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bagItem: (where: BagItemWhereUniqueInput) => BagItemNullablePromise;
  bagItems: (args?: {
    where?: BagItemWhereInput;
    orderBy?: BagItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BagItem>;
  bagItemsConnection: (args?: {
    where?: BagItemWhereInput;
    orderBy?: BagItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BagItemConnectionPromise;
  billingInfo: (
    where: BillingInfoWhereUniqueInput
  ) => BillingInfoNullablePromise;
  billingInfoes: (args?: {
    where?: BillingInfoWhereInput;
    orderBy?: BillingInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BillingInfo>;
  billingInfoesConnection: (args?: {
    where?: BillingInfoWhereInput;
    orderBy?: BillingInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BillingInfoConnectionPromise;
  brand: (where: BrandWhereUniqueInput) => BrandNullablePromise;
  brands: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Brand>;
  brandsConnection: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BrandConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  collection: (where: CollectionWhereUniqueInput) => CollectionNullablePromise;
  collections: (args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Collection>;
  collectionsConnection: (args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CollectionConnectionPromise;
  collectionGroup: (
    where: CollectionGroupWhereUniqueInput
  ) => CollectionGroupNullablePromise;
  collectionGroups: (args?: {
    where?: CollectionGroupWhereInput;
    orderBy?: CollectionGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CollectionGroup>;
  collectionGroupsConnection: (args?: {
    where?: CollectionGroupWhereInput;
    orderBy?: CollectionGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CollectionGroupConnectionPromise;
  color: (where: ColorWhereUniqueInput) => ColorNullablePromise;
  colors: (args?: {
    where?: ColorWhereInput;
    orderBy?: ColorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Color>;
  colorsConnection: (args?: {
    where?: ColorWhereInput;
    orderBy?: ColorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ColorConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  customerDetail: (
    where: CustomerDetailWhereUniqueInput
  ) => CustomerDetailNullablePromise;
  customerDetails: (args?: {
    where?: CustomerDetailWhereInput;
    orderBy?: CustomerDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerDetail>;
  customerDetailsConnection: (args?: {
    where?: CustomerDetailWhereInput;
    orderBy?: CustomerDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerDetailConnectionPromise;
  homepageProductRail: (
    where: HomepageProductRailWhereUniqueInput
  ) => HomepageProductRailNullablePromise;
  homepageProductRails: (args?: {
    where?: HomepageProductRailWhereInput;
    orderBy?: HomepageProductRailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HomepageProductRail>;
  homepageProductRailsConnection: (args?: {
    where?: HomepageProductRailWhereInput;
    orderBy?: HomepageProductRailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HomepageProductRailConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  label: (where: LabelWhereUniqueInput) => LabelNullablePromise;
  labels: (args?: {
    where?: LabelWhereInput;
    orderBy?: LabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Label>;
  labelsConnection: (args?: {
    where?: LabelWhereInput;
    orderBy?: LabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LabelConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationNullablePromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  package: (where: PackageWhereUniqueInput) => PackageNullablePromise;
  packages: (args?: {
    where?: PackageWhereInput;
    orderBy?: PackageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Package>;
  packagesConnection: (args?: {
    where?: PackageWhereInput;
    orderBy?: PackageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PackageConnectionPromise;
  physicalProduct: (
    where: PhysicalProductWhereUniqueInput
  ) => PhysicalProductNullablePromise;
  physicalProducts: (args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PhysicalProduct>;
  physicalProductsConnection: (args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhysicalProductConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productFunction: (
    where: ProductFunctionWhereUniqueInput
  ) => ProductFunctionNullablePromise;
  productFunctions: (args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductFunction>;
  productFunctionsConnection: (args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductFunctionConnectionPromise;
  productRequest: (
    where: ProductRequestWhereUniqueInput
  ) => ProductRequestNullablePromise;
  productRequests: (args?: {
    where?: ProductRequestWhereInput;
    orderBy?: ProductRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductRequest>;
  productRequestsConnection: (args?: {
    where?: ProductRequestWhereInput;
    orderBy?: ProductRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductRequestConnectionPromise;
  productVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantNullablePromise;
  productVariants: (args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductVariant>;
  productVariantsConnection: (args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductVariantConnectionPromise;
  reservation: (
    where: ReservationWhereUniqueInput
  ) => ReservationNullablePromise;
  reservations: (args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reservation>;
  reservationsConnection: (args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReservationConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBagItem: (data: BagItemCreateInput) => BagItemPromise;
  updateBagItem: (args: {
    data: BagItemUpdateInput;
    where: BagItemWhereUniqueInput;
  }) => BagItemPromise;
  updateManyBagItems: (args: {
    data: BagItemUpdateManyMutationInput;
    where?: BagItemWhereInput;
  }) => BatchPayloadPromise;
  upsertBagItem: (args: {
    where: BagItemWhereUniqueInput;
    create: BagItemCreateInput;
    update: BagItemUpdateInput;
  }) => BagItemPromise;
  deleteBagItem: (where: BagItemWhereUniqueInput) => BagItemPromise;
  deleteManyBagItems: (where?: BagItemWhereInput) => BatchPayloadPromise;
  createBillingInfo: (data: BillingInfoCreateInput) => BillingInfoPromise;
  updateBillingInfo: (args: {
    data: BillingInfoUpdateInput;
    where: BillingInfoWhereUniqueInput;
  }) => BillingInfoPromise;
  updateManyBillingInfoes: (args: {
    data: BillingInfoUpdateManyMutationInput;
    where?: BillingInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertBillingInfo: (args: {
    where: BillingInfoWhereUniqueInput;
    create: BillingInfoCreateInput;
    update: BillingInfoUpdateInput;
  }) => BillingInfoPromise;
  deleteBillingInfo: (where: BillingInfoWhereUniqueInput) => BillingInfoPromise;
  deleteManyBillingInfoes: (
    where?: BillingInfoWhereInput
  ) => BatchPayloadPromise;
  createBrand: (data: BrandCreateInput) => BrandPromise;
  updateBrand: (args: {
    data: BrandUpdateInput;
    where: BrandWhereUniqueInput;
  }) => BrandPromise;
  updateManyBrands: (args: {
    data: BrandUpdateManyMutationInput;
    where?: BrandWhereInput;
  }) => BatchPayloadPromise;
  upsertBrand: (args: {
    where: BrandWhereUniqueInput;
    create: BrandCreateInput;
    update: BrandUpdateInput;
  }) => BrandPromise;
  deleteBrand: (where: BrandWhereUniqueInput) => BrandPromise;
  deleteManyBrands: (where?: BrandWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createCollection: (data: CollectionCreateInput) => CollectionPromise;
  updateCollection: (args: {
    data: CollectionUpdateInput;
    where: CollectionWhereUniqueInput;
  }) => CollectionPromise;
  updateManyCollections: (args: {
    data: CollectionUpdateManyMutationInput;
    where?: CollectionWhereInput;
  }) => BatchPayloadPromise;
  upsertCollection: (args: {
    where: CollectionWhereUniqueInput;
    create: CollectionCreateInput;
    update: CollectionUpdateInput;
  }) => CollectionPromise;
  deleteCollection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  deleteManyCollections: (where?: CollectionWhereInput) => BatchPayloadPromise;
  createCollectionGroup: (
    data: CollectionGroupCreateInput
  ) => CollectionGroupPromise;
  updateCollectionGroup: (args: {
    data: CollectionGroupUpdateInput;
    where: CollectionGroupWhereUniqueInput;
  }) => CollectionGroupPromise;
  updateManyCollectionGroups: (args: {
    data: CollectionGroupUpdateManyMutationInput;
    where?: CollectionGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertCollectionGroup: (args: {
    where: CollectionGroupWhereUniqueInput;
    create: CollectionGroupCreateInput;
    update: CollectionGroupUpdateInput;
  }) => CollectionGroupPromise;
  deleteCollectionGroup: (
    where: CollectionGroupWhereUniqueInput
  ) => CollectionGroupPromise;
  deleteManyCollectionGroups: (
    where?: CollectionGroupWhereInput
  ) => BatchPayloadPromise;
  createColor: (data: ColorCreateInput) => ColorPromise;
  updateColor: (args: {
    data: ColorUpdateInput;
    where: ColorWhereUniqueInput;
  }) => ColorPromise;
  updateManyColors: (args: {
    data: ColorUpdateManyMutationInput;
    where?: ColorWhereInput;
  }) => BatchPayloadPromise;
  upsertColor: (args: {
    where: ColorWhereUniqueInput;
    create: ColorCreateInput;
    update: ColorUpdateInput;
  }) => ColorPromise;
  deleteColor: (where: ColorWhereUniqueInput) => ColorPromise;
  deleteManyColors: (where?: ColorWhereInput) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createCustomerDetail: (
    data: CustomerDetailCreateInput
  ) => CustomerDetailPromise;
  updateCustomerDetail: (args: {
    data: CustomerDetailUpdateInput;
    where: CustomerDetailWhereUniqueInput;
  }) => CustomerDetailPromise;
  updateManyCustomerDetails: (args: {
    data: CustomerDetailUpdateManyMutationInput;
    where?: CustomerDetailWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerDetail: (args: {
    where: CustomerDetailWhereUniqueInput;
    create: CustomerDetailCreateInput;
    update: CustomerDetailUpdateInput;
  }) => CustomerDetailPromise;
  deleteCustomerDetail: (
    where: CustomerDetailWhereUniqueInput
  ) => CustomerDetailPromise;
  deleteManyCustomerDetails: (
    where?: CustomerDetailWhereInput
  ) => BatchPayloadPromise;
  createHomepageProductRail: (
    data: HomepageProductRailCreateInput
  ) => HomepageProductRailPromise;
  updateHomepageProductRail: (args: {
    data: HomepageProductRailUpdateInput;
    where: HomepageProductRailWhereUniqueInput;
  }) => HomepageProductRailPromise;
  updateManyHomepageProductRails: (args: {
    data: HomepageProductRailUpdateManyMutationInput;
    where?: HomepageProductRailWhereInput;
  }) => BatchPayloadPromise;
  upsertHomepageProductRail: (args: {
    where: HomepageProductRailWhereUniqueInput;
    create: HomepageProductRailCreateInput;
    update: HomepageProductRailUpdateInput;
  }) => HomepageProductRailPromise;
  deleteHomepageProductRail: (
    where: HomepageProductRailWhereUniqueInput
  ) => HomepageProductRailPromise;
  deleteManyHomepageProductRails: (
    where?: HomepageProductRailWhereInput
  ) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createLabel: (data: LabelCreateInput) => LabelPromise;
  updateLabel: (args: {
    data: LabelUpdateInput;
    where: LabelWhereUniqueInput;
  }) => LabelPromise;
  updateManyLabels: (args: {
    data: LabelUpdateManyMutationInput;
    where?: LabelWhereInput;
  }) => BatchPayloadPromise;
  upsertLabel: (args: {
    where: LabelWhereUniqueInput;
    create: LabelCreateInput;
    update: LabelUpdateInput;
  }) => LabelPromise;
  deleteLabel: (where: LabelWhereUniqueInput) => LabelPromise;
  deleteManyLabels: (where?: LabelWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createPackage: (data: PackageCreateInput) => PackagePromise;
  updatePackage: (args: {
    data: PackageUpdateInput;
    where: PackageWhereUniqueInput;
  }) => PackagePromise;
  updateManyPackages: (args: {
    data: PackageUpdateManyMutationInput;
    where?: PackageWhereInput;
  }) => BatchPayloadPromise;
  upsertPackage: (args: {
    where: PackageWhereUniqueInput;
    create: PackageCreateInput;
    update: PackageUpdateInput;
  }) => PackagePromise;
  deletePackage: (where: PackageWhereUniqueInput) => PackagePromise;
  deleteManyPackages: (where?: PackageWhereInput) => BatchPayloadPromise;
  createPhysicalProduct: (
    data: PhysicalProductCreateInput
  ) => PhysicalProductPromise;
  updatePhysicalProduct: (args: {
    data: PhysicalProductUpdateInput;
    where: PhysicalProductWhereUniqueInput;
  }) => PhysicalProductPromise;
  updateManyPhysicalProducts: (args: {
    data: PhysicalProductUpdateManyMutationInput;
    where?: PhysicalProductWhereInput;
  }) => BatchPayloadPromise;
  upsertPhysicalProduct: (args: {
    where: PhysicalProductWhereUniqueInput;
    create: PhysicalProductCreateInput;
    update: PhysicalProductUpdateInput;
  }) => PhysicalProductPromise;
  deletePhysicalProduct: (
    where: PhysicalProductWhereUniqueInput
  ) => PhysicalProductPromise;
  deleteManyPhysicalProducts: (
    where?: PhysicalProductWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductFunction: (
    data: ProductFunctionCreateInput
  ) => ProductFunctionPromise;
  updateProductFunction: (args: {
    data: ProductFunctionUpdateInput;
    where: ProductFunctionWhereUniqueInput;
  }) => ProductFunctionPromise;
  updateManyProductFunctions: (args: {
    data: ProductFunctionUpdateManyMutationInput;
    where?: ProductFunctionWhereInput;
  }) => BatchPayloadPromise;
  upsertProductFunction: (args: {
    where: ProductFunctionWhereUniqueInput;
    create: ProductFunctionCreateInput;
    update: ProductFunctionUpdateInput;
  }) => ProductFunctionPromise;
  deleteProductFunction: (
    where: ProductFunctionWhereUniqueInput
  ) => ProductFunctionPromise;
  deleteManyProductFunctions: (
    where?: ProductFunctionWhereInput
  ) => BatchPayloadPromise;
  createProductRequest: (
    data: ProductRequestCreateInput
  ) => ProductRequestPromise;
  updateProductRequest: (args: {
    data: ProductRequestUpdateInput;
    where: ProductRequestWhereUniqueInput;
  }) => ProductRequestPromise;
  updateManyProductRequests: (args: {
    data: ProductRequestUpdateManyMutationInput;
    where?: ProductRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertProductRequest: (args: {
    where: ProductRequestWhereUniqueInput;
    create: ProductRequestCreateInput;
    update: ProductRequestUpdateInput;
  }) => ProductRequestPromise;
  deleteProductRequest: (
    where: ProductRequestWhereUniqueInput
  ) => ProductRequestPromise;
  deleteManyProductRequests: (
    where?: ProductRequestWhereInput
  ) => BatchPayloadPromise;
  createProductVariant: (
    data: ProductVariantCreateInput
  ) => ProductVariantPromise;
  updateProductVariant: (args: {
    data: ProductVariantUpdateInput;
    where: ProductVariantWhereUniqueInput;
  }) => ProductVariantPromise;
  updateManyProductVariants: (args: {
    data: ProductVariantUpdateManyMutationInput;
    where?: ProductVariantWhereInput;
  }) => BatchPayloadPromise;
  upsertProductVariant: (args: {
    where: ProductVariantWhereUniqueInput;
    create: ProductVariantCreateInput;
    update: ProductVariantUpdateInput;
  }) => ProductVariantPromise;
  deleteProductVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantPromise;
  deleteManyProductVariants: (
    where?: ProductVariantWhereInput
  ) => BatchPayloadPromise;
  createReservation: (data: ReservationCreateInput) => ReservationPromise;
  updateReservation: (args: {
    data: ReservationUpdateInput;
    where: ReservationWhereUniqueInput;
  }) => ReservationPromise;
  updateManyReservations: (args: {
    data: ReservationUpdateManyMutationInput;
    where?: ReservationWhereInput;
  }) => BatchPayloadPromise;
  upsertReservation: (args: {
    where: ReservationWhereUniqueInput;
    create: ReservationCreateInput;
    update: ReservationUpdateInput;
  }) => ReservationPromise;
  deleteReservation: (where: ReservationWhereUniqueInput) => ReservationPromise;
  deleteManyReservations: (
    where?: ReservationWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bagItem: (
    where?: BagItemSubscriptionWhereInput
  ) => BagItemSubscriptionPayloadSubscription;
  billingInfo: (
    where?: BillingInfoSubscriptionWhereInput
  ) => BillingInfoSubscriptionPayloadSubscription;
  brand: (
    where?: BrandSubscriptionWhereInput
  ) => BrandSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  collection: (
    where?: CollectionSubscriptionWhereInput
  ) => CollectionSubscriptionPayloadSubscription;
  collectionGroup: (
    where?: CollectionGroupSubscriptionWhereInput
  ) => CollectionGroupSubscriptionPayloadSubscription;
  color: (
    where?: ColorSubscriptionWhereInput
  ) => ColorSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  customerDetail: (
    where?: CustomerDetailSubscriptionWhereInput
  ) => CustomerDetailSubscriptionPayloadSubscription;
  homepageProductRail: (
    where?: HomepageProductRailSubscriptionWhereInput
  ) => HomepageProductRailSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  label: (
    where?: LabelSubscriptionWhereInput
  ) => LabelSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  package: (
    where?: PackageSubscriptionWhereInput
  ) => PackageSubscriptionPayloadSubscription;
  physicalProduct: (
    where?: PhysicalProductSubscriptionWhereInput
  ) => PhysicalProductSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productFunction: (
    where?: ProductFunctionSubscriptionWhereInput
  ) => ProductFunctionSubscriptionPayloadSubscription;
  productRequest: (
    where?: ProductRequestSubscriptionWhereInput
  ) => ProductRequestSubscriptionPayloadSubscription;
  productVariant: (
    where?: ProductVariantSubscriptionWhereInput
  ) => ProductVariantSubscriptionPayloadSubscription;
  reservation: (
    where?: ReservationSubscriptionWhereInput
  ) => ReservationSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Size = "XS" | "S" | "M" | "L" | "XL" | "XXL";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "externalURL_ASC"
  | "externalURL_DESC"
  | "images_ASC"
  | "images_DESC"
  | "modelHeight_ASC"
  | "modelHeight_DESC"
  | "modelSize_ASC"
  | "modelSize_DESC"
  | "retailPrice_ASC"
  | "retailPrice_DESC"
  | "tags_ASC"
  | "tags_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BrandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "brandCode_ASC"
  | "brandCode_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isPrimaryBrand_ASC"
  | "isPrimaryBrand_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "name_ASC"
  | "name_DESC"
  | "basedIn_ASC"
  | "basedIn_DESC"
  | "since_ASC"
  | "since_DESC"
  | "tier_ASC"
  | "tier_DESC"
  | "websiteUrl_ASC"
  | "websiteUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "auth0Id_ASC"
  | "auth0Id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BillingInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "name_ASC"
  | "name_DESC"
  | "last_digits_ASC"
  | "last_digits_DESC"
  | "expiration_month_ASC"
  | "expiration_month_DESC"
  | "expiration_year_ASC"
  | "expiration_year_DESC"
  | "street1_ASC"
  | "street1_DESC"
  | "street2_ASC"
  | "street2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "country_ASC"
  | "country_DESC"
  | "postal_code_ASC"
  | "postal_code_DESC";

export type PackageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BagItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "position_ASC"
  | "position_DESC"
  | "saved_ASC"
  | "saved_DESC"
  | "status_ASC"
  | "status_DESC";

export type OrderOrderByInput = "id_ASC" | "id_DESC";

export type BrandTier =
  | "Tier0"
  | "Tier1"
  | "Tier2"
  | "Niche"
  | "Upcoming"
  | "Retro"
  | "Boutique"
  | "Local"
  | "Discovery";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "company_ASC"
  | "company_DESC"
  | "description_ASC"
  | "description_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zipCode_ASC"
  | "zipCode_DESC"
  | "locationType_ASC"
  | "locationType_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BagItemStatus = "Added" | "Reserved" | "Received";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "originalHeight_ASC"
  | "originalHeight_DESC"
  | "originalUrl_ASC"
  | "originalUrl_DESC"
  | "originalWidth_ASC"
  | "originalWidth_DESC"
  | "resizedUrl_ASC"
  | "resizedUrl_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReservationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reservationNumber_ASC"
  | "reservationNumber_DESC"
  | "shipped_ASC"
  | "shipped_DESC"
  | "status_ASC"
  | "status_DESC"
  | "shippedAt_ASC"
  | "shippedAt_DESC"
  | "receivedAt_ASC"
  | "receivedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HomepageProductRailOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC";

export type ProductStatus = "Available" | "NotAvailable";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "plan_ASC"
  | "plan_DESC";

export type InventoryStatus = "NonReservable" | "Reservable" | "Reserved";

export type CollectionGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "title_ASC"
  | "title_DESC"
  | "collectionCount_ASC"
  | "collectionCount_DESC";

export type PhysicalProductStatus =
  | "New"
  | "Used"
  | "Damaged"
  | "Clean"
  | "Lost";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PhysicalProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "seasonsUID_ASC"
  | "seasonsUID_DESC"
  | "inventoryStatus_ASC"
  | "inventoryStatus_DESC"
  | "productStatus_ASC"
  | "productStatus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRole = "Admin" | "Customer" | "Partner";

export type ReservationStatus =
  | "New"
  | "OnHold"
  | "Packed"
  | "Shipped"
  | "InTransit"
  | "Received"
  | "Cancelled"
  | "Completed";

export type LabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "image_ASC"
  | "image_DESC"
  | "trackingNumber_ASC"
  | "trackingNumber_DESC"
  | "trackingURL_ASC"
  | "trackingURL_DESC";

export type Plan = "AllAccess" | "Essential";

export type CustomerDetailOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "height_ASC"
  | "height_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "bodyType_ASC"
  | "bodyType_DESC"
  | "averageTopSize_ASC"
  | "averageTopSize_DESC"
  | "averageWaistSize_ASC"
  | "averageWaistSize_DESC"
  | "averagePantLength_ASC"
  | "averagePantLength_DESC"
  | "preferredPronouns_ASC"
  | "preferredPronouns_DESC"
  | "profession_ASC"
  | "profession_DESC"
  | "partyFrequency_ASC"
  | "partyFrequency_DESC"
  | "travelFrequency_ASC"
  | "travelFrequency_DESC"
  | "shoppingFrequency_ASC"
  | "shoppingFrequency_DESC"
  | "averageSpend_ASC"
  | "averageSpend_DESC"
  | "style_ASC"
  | "style_DESC"
  | "commuteStyle_ASC"
  | "commuteStyle_DESC"
  | "phoneOS_ASC"
  | "phoneOS_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "image_ASC"
  | "image_DESC"
  | "description_ASC"
  | "description_DESC"
  | "visible_ASC"
  | "visible_DESC";

export type ProductFunctionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ProductVariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "size_ASC"
  | "size_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "height_ASC"
  | "height_DESC"
  | "productID_ASC"
  | "productID_DESC"
  | "retailPrice_ASC"
  | "retailPrice_DESC"
  | "total_ASC"
  | "total_DESC"
  | "reservable_ASC"
  | "reservable_DESC"
  | "reserved_ASC"
  | "reserved_DESC"
  | "nonReservable_ASC"
  | "nonReservable_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Material =
  | "Acetate"
  | "Acrylic"
  | "Alpaca"
  | "CalfLeather"
  | "CamelHair"
  | "Camel"
  | "Cashmere"
  | "Cotton"
  | "CowLeather"
  | "Cupro"
  | "DuckFeathers"
  | "Elastane"
  | "Esterlane"
  | "Feather"
  | "FeatherDown"
  | "GooseDown"
  | "LambLeather"
  | "LambSkin"
  | "Leather"
  | "Lyocell"
  | "MerinoWool"
  | "Modacrylic"
  | "Mohair"
  | "Nylon"
  | "OrganicCotton"
  | "Polyamide"
  | "Polyester"
  | "Polyethylene"
  | "Polyurethane"
  | "PolyurethanicResin"
  | "PVC"
  | "Rayon"
  | "RecycledPolyester"
  | "RecycledWool"
  | "Silk"
  | "Suede"
  | "SheepLeather"
  | "Spandex"
  | "Taffeta"
  | "Tartan"
  | "VirginWool"
  | "Viscose"
  | "Velcro"
  | "WaxCoating"
  | "WhiteDuckDown"
  | "WhiteGooseDown"
  | "Wool"
  | "Mesh"
  | "Denim";

export type ColorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "colorCode_ASC"
  | "colorCode_DESC"
  | "hexCode_ASC"
  | "hexCode_DESC";

export type LocationType = "Office" | "Warehouse" | "Cleaner" | "Customer";

export type CustomerStatus =
  | "Invited"
  | "Created"
  | "Waitlisted"
  | "Authorized"
  | "Active"
  | "Suspended"
  | "Paused"
  | "Deactivated";

export type ProductRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "priceCurrency_ASC"
  | "priceCurrency_DESC"
  | "productID_ASC"
  | "productID_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "url_ASC"
  | "url_DESC";

export type CollectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "images_ASC"
  | "images_DESC"
  | "title_ASC"
  | "title_DESC"
  | "subTitle_ASC"
  | "subTitle_DESC"
  | "descriptionTop_ASC"
  | "descriptionTop_DESC"
  | "descriptionBottom_ASC"
  | "descriptionBottom_DESC";

export interface PhysicalProductUpdateWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput;
  data: PhysicalProductUpdateWithoutLocationDataInput;
}

export type BagItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ColorCreateOneWithoutProductVariantsInput {
  create?: Maybe<ColorCreateWithoutProductVariantsInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface BillingInfoUpdateManyMutationInput {
  brand?: Maybe<String>;
  name?: Maybe<String>;
  last_digits?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface ColorCreateWithoutProductVariantsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
}

export interface ProductUpdateWithoutCategoryDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images?: Maybe<Json>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  availableSizes?: Maybe<ProductUpdateavailableSizesInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
  status?: Maybe<ProductStatus>;
}

export interface ProductCreateOneWithoutVariantsInput {
  create?: Maybe<ProductCreateWithoutVariantsInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ReservationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReservationWhereInput>;
  AND?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ReservationSubscriptionWhereInput[] | ReservationSubscriptionWhereInput
  >;
}

export interface ProductCreateWithoutVariantsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  category: CategoryCreateOneWithoutProductsInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images: Json;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color: ColorCreateOneInput;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  availableSizes?: Maybe<ProductCreateavailableSizesInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  status?: Maybe<ProductStatus>;
}

export interface ProductRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductRequestWhereInput>;
  AND?: Maybe<
    | ProductRequestSubscriptionWhereInput[]
    | ProductRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductRequestSubscriptionWhereInput[]
    | ProductRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductRequestSubscriptionWhereInput[]
    | ProductRequestSubscriptionWhereInput
  >;
}

export interface BrandCreateOneWithoutProductsInput {
  create?: Maybe<BrandCreateWithoutProductsInput>;
  connect?: Maybe<BrandWhereUniqueInput>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface BrandCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  brandCode: String;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name: String;
  basedIn?: Maybe<String>;
  since?: Maybe<DateTimeInput>;
  tier: BrandTier;
  websiteUrl?: Maybe<String>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  status?: Maybe<CustomerStatus>;
  status_not?: Maybe<CustomerStatus>;
  status_in?: Maybe<CustomerStatus[] | CustomerStatus>;
  status_not_in?: Maybe<CustomerStatus[] | CustomerStatus>;
  detail?: Maybe<CustomerDetailWhereInput>;
  billingInfo?: Maybe<BillingInfoWhereInput>;
  plan?: Maybe<Plan>;
  plan_not?: Maybe<Plan>;
  plan_in?: Maybe<Plan[] | Plan>;
  plan_not_in?: Maybe<Plan[] | Plan>;
  reservations_every?: Maybe<ReservationWhereInput>;
  reservations_some?: Maybe<ReservationWhereInput>;
  reservations_none?: Maybe<ReservationWhereInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface CategoryCreateOneWithoutProductsInput {
  create?: Maybe<CategoryCreateWithoutProductsInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface BillingInfoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  last_digits?: Maybe<String>;
  last_digits_not?: Maybe<String>;
  last_digits_in?: Maybe<String[] | String>;
  last_digits_not_in?: Maybe<String[] | String>;
  last_digits_lt?: Maybe<String>;
  last_digits_lte?: Maybe<String>;
  last_digits_gt?: Maybe<String>;
  last_digits_gte?: Maybe<String>;
  last_digits_contains?: Maybe<String>;
  last_digits_not_contains?: Maybe<String>;
  last_digits_starts_with?: Maybe<String>;
  last_digits_not_starts_with?: Maybe<String>;
  last_digits_ends_with?: Maybe<String>;
  last_digits_not_ends_with?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_month_not?: Maybe<Int>;
  expiration_month_in?: Maybe<Int[] | Int>;
  expiration_month_not_in?: Maybe<Int[] | Int>;
  expiration_month_lt?: Maybe<Int>;
  expiration_month_lte?: Maybe<Int>;
  expiration_month_gt?: Maybe<Int>;
  expiration_month_gte?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  expiration_year_not?: Maybe<Int>;
  expiration_year_in?: Maybe<Int[] | Int>;
  expiration_year_not_in?: Maybe<Int[] | Int>;
  expiration_year_lt?: Maybe<Int>;
  expiration_year_lte?: Maybe<Int>;
  expiration_year_gt?: Maybe<Int>;
  expiration_year_gte?: Maybe<Int>;
  street1?: Maybe<String>;
  street1_not?: Maybe<String>;
  street1_in?: Maybe<String[] | String>;
  street1_not_in?: Maybe<String[] | String>;
  street1_lt?: Maybe<String>;
  street1_lte?: Maybe<String>;
  street1_gt?: Maybe<String>;
  street1_gte?: Maybe<String>;
  street1_contains?: Maybe<String>;
  street1_not_contains?: Maybe<String>;
  street1_starts_with?: Maybe<String>;
  street1_not_starts_with?: Maybe<String>;
  street1_ends_with?: Maybe<String>;
  street1_not_ends_with?: Maybe<String>;
  street2?: Maybe<String>;
  street2_not?: Maybe<String>;
  street2_in?: Maybe<String[] | String>;
  street2_not_in?: Maybe<String[] | String>;
  street2_lt?: Maybe<String>;
  street2_lte?: Maybe<String>;
  street2_gt?: Maybe<String>;
  street2_gte?: Maybe<String>;
  street2_contains?: Maybe<String>;
  street2_not_contains?: Maybe<String>;
  street2_starts_with?: Maybe<String>;
  street2_not_starts_with?: Maybe<String>;
  street2_ends_with?: Maybe<String>;
  street2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  postal_code?: Maybe<String>;
  postal_code_not?: Maybe<String>;
  postal_code_in?: Maybe<String[] | String>;
  postal_code_not_in?: Maybe<String[] | String>;
  postal_code_lt?: Maybe<String>;
  postal_code_lte?: Maybe<String>;
  postal_code_gt?: Maybe<String>;
  postal_code_gte?: Maybe<String>;
  postal_code_contains?: Maybe<String>;
  postal_code_not_contains?: Maybe<String>;
  postal_code_starts_with?: Maybe<String>;
  postal_code_not_starts_with?: Maybe<String>;
  postal_code_ends_with?: Maybe<String>;
  postal_code_not_ends_with?: Maybe<String>;
  AND?: Maybe<BillingInfoWhereInput[] | BillingInfoWhereInput>;
  OR?: Maybe<BillingInfoWhereInput[] | BillingInfoWhereInput>;
  NOT?: Maybe<BillingInfoWhereInput[] | BillingInfoWhereInput>;
}

export interface CategoryCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  children?: Maybe<CategoryCreateManyWithoutChildrenInput>;
}

export interface LabelWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingNumber_not?: Maybe<String>;
  trackingNumber_in?: Maybe<String[] | String>;
  trackingNumber_not_in?: Maybe<String[] | String>;
  trackingNumber_lt?: Maybe<String>;
  trackingNumber_lte?: Maybe<String>;
  trackingNumber_gt?: Maybe<String>;
  trackingNumber_gte?: Maybe<String>;
  trackingNumber_contains?: Maybe<String>;
  trackingNumber_not_contains?: Maybe<String>;
  trackingNumber_starts_with?: Maybe<String>;
  trackingNumber_not_starts_with?: Maybe<String>;
  trackingNumber_ends_with?: Maybe<String>;
  trackingNumber_not_ends_with?: Maybe<String>;
  trackingURL?: Maybe<String>;
  trackingURL_not?: Maybe<String>;
  trackingURL_in?: Maybe<String[] | String>;
  trackingURL_not_in?: Maybe<String[] | String>;
  trackingURL_lt?: Maybe<String>;
  trackingURL_lte?: Maybe<String>;
  trackingURL_gt?: Maybe<String>;
  trackingURL_gte?: Maybe<String>;
  trackingURL_contains?: Maybe<String>;
  trackingURL_not_contains?: Maybe<String>;
  trackingURL_starts_with?: Maybe<String>;
  trackingURL_not_starts_with?: Maybe<String>;
  trackingURL_ends_with?: Maybe<String>;
  trackingURL_not_ends_with?: Maybe<String>;
  AND?: Maybe<LabelWhereInput[] | LabelWhereInput>;
  OR?: Maybe<LabelWhereInput[] | LabelWhereInput>;
  NOT?: Maybe<LabelWhereInput[] | LabelWhereInput>;
}

export interface CategoryCreateManyWithoutChildrenInput {
  create?: Maybe<
    CategoryCreateWithoutChildrenInput[] | CategoryCreateWithoutChildrenInput
  >;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
}

export interface ProductFunctionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductFunctionWhereInput[] | ProductFunctionWhereInput>;
  OR?: Maybe<ProductFunctionWhereInput[] | ProductFunctionWhereInput>;
  NOT?: Maybe<ProductFunctionWhereInput[] | ProductFunctionWhereInput>;
}

export interface CategoryCreateWithoutChildrenInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductCreateManyWithoutCategoryInput>;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface ProductCreateManyWithoutCategoryInput {
  create?: Maybe<
    ProductCreateWithoutCategoryInput[] | ProductCreateWithoutCategoryInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  children_every?: Maybe<CategoryWhereInput>;
  children_some?: Maybe<CategoryWhereInput>;
  children_none?: Maybe<CategoryWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface ProductCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images: Json;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color: ColorCreateOneInput;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  availableSizes?: Maybe<ProductCreateavailableSizesInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
  status?: Maybe<ProductStatus>;
}

export interface LabelSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LabelWhereInput>;
  AND?: Maybe<LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput>;
  OR?: Maybe<LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput>;
  NOT?: Maybe<LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput>;
}

export interface ColorCreateOneInput {
  create?: Maybe<ColorCreateInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface HomepageProductRailSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HomepageProductRailWhereInput>;
  AND?: Maybe<
    | HomepageProductRailSubscriptionWhereInput[]
    | HomepageProductRailSubscriptionWhereInput
  >;
  OR?: Maybe<
    | HomepageProductRailSubscriptionWhereInput[]
    | HomepageProductRailSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | HomepageProductRailSubscriptionWhereInput[]
    | HomepageProductRailSubscriptionWhereInput
  >;
}

export interface ColorCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
  productVariants?: Maybe<ProductVariantCreateManyWithoutColorInput>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface ProductVariantCreateManyWithoutColorInput {
  create?: Maybe<
    | ProductVariantCreateWithoutColorInput[]
    | ProductVariantCreateWithoutColorInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
}

export interface BrandWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  brandCode?: Maybe<String>;
  brandCode_not?: Maybe<String>;
  brandCode_in?: Maybe<String[] | String>;
  brandCode_not_in?: Maybe<String[] | String>;
  brandCode_lt?: Maybe<String>;
  brandCode_lte?: Maybe<String>;
  brandCode_gt?: Maybe<String>;
  brandCode_gte?: Maybe<String>;
  brandCode_contains?: Maybe<String>;
  brandCode_not_contains?: Maybe<String>;
  brandCode_starts_with?: Maybe<String>;
  brandCode_not_starts_with?: Maybe<String>;
  brandCode_ends_with?: Maybe<String>;
  brandCode_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  isPrimaryBrand_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  basedIn?: Maybe<String>;
  basedIn_not?: Maybe<String>;
  basedIn_in?: Maybe<String[] | String>;
  basedIn_not_in?: Maybe<String[] | String>;
  basedIn_lt?: Maybe<String>;
  basedIn_lte?: Maybe<String>;
  basedIn_gt?: Maybe<String>;
  basedIn_gte?: Maybe<String>;
  basedIn_contains?: Maybe<String>;
  basedIn_not_contains?: Maybe<String>;
  basedIn_starts_with?: Maybe<String>;
  basedIn_not_starts_with?: Maybe<String>;
  basedIn_ends_with?: Maybe<String>;
  basedIn_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  since?: Maybe<DateTimeInput>;
  since_not?: Maybe<DateTimeInput>;
  since_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  since_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  since_lt?: Maybe<DateTimeInput>;
  since_lte?: Maybe<DateTimeInput>;
  since_gt?: Maybe<DateTimeInput>;
  since_gte?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  tier_not?: Maybe<BrandTier>;
  tier_in?: Maybe<BrandTier[] | BrandTier>;
  tier_not_in?: Maybe<BrandTier[] | BrandTier>;
  websiteUrl?: Maybe<String>;
  websiteUrl_not?: Maybe<String>;
  websiteUrl_in?: Maybe<String[] | String>;
  websiteUrl_not_in?: Maybe<String[] | String>;
  websiteUrl_lt?: Maybe<String>;
  websiteUrl_lte?: Maybe<String>;
  websiteUrl_gt?: Maybe<String>;
  websiteUrl_gte?: Maybe<String>;
  websiteUrl_contains?: Maybe<String>;
  websiteUrl_not_contains?: Maybe<String>;
  websiteUrl_starts_with?: Maybe<String>;
  websiteUrl_not_starts_with?: Maybe<String>;
  websiteUrl_ends_with?: Maybe<String>;
  websiteUrl_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BrandWhereInput[] | BrandWhereInput>;
  OR?: Maybe<BrandWhereInput[] | BrandWhereInput>;
  NOT?: Maybe<BrandWhereInput[] | BrandWhereInput>;
}

export interface ProductVariantCreateWithoutColorInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  size: Size;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  product: ProductCreateOneWithoutVariantsInput;
  retailPrice?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutProductVariantInput>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
}

export interface CollectionGroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CollectionGroupWhereInput>;
  AND?: Maybe<
    | CollectionGroupSubscriptionWhereInput[]
    | CollectionGroupSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CollectionGroupSubscriptionWhereInput[]
    | CollectionGroupSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CollectionGroupSubscriptionWhereInput[]
    | CollectionGroupSubscriptionWhereInput
  >;
}

export interface PhysicalProductCreateManyWithoutProductVariantInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutProductVariantInput[]
    | PhysicalProductCreateWithoutProductVariantInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
}

export type BrandWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
}>;

export interface PhysicalProductCreateWithoutProductVariantInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  location: LocationCreateOneWithoutPhysicalProductsInput;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface LocationCreateOneWithoutPhysicalProductsInput {
  create?: Maybe<LocationCreateWithoutPhysicalProductsInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface BillingInfoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BillingInfoWhereInput>;
  AND?: Maybe<
    BillingInfoSubscriptionWhereInput[] | BillingInfoSubscriptionWhereInput
  >;
  OR?: Maybe<
    BillingInfoSubscriptionWhereInput[] | BillingInfoSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BillingInfoSubscriptionWhereInput[] | BillingInfoSubscriptionWhereInput
  >;
}

export interface LocationCreateWithoutPhysicalProductsInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1: String;
  address2?: Maybe<String>;
  city: String;
  state: String;
  zipCode: String;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserCreateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
}

export interface BagItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BagItemWhereInput>;
  AND?: Maybe<BagItemSubscriptionWhereInput[] | BagItemSubscriptionWhereInput>;
  OR?: Maybe<BagItemSubscriptionWhereInput[] | BagItemSubscriptionWhereInput>;
  NOT?: Maybe<BagItemSubscriptionWhereInput[] | BagItemSubscriptionWhereInput>;
}

export interface ProductFunctionCreateManyInput {
  create?: Maybe<ProductFunctionCreateInput[] | ProductFunctionCreateInput>;
  connect?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
}

export interface UserUpdateInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
}

export interface ProductFunctionCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface ReservationUpdateManyMutationInput {
  reservationNumber?: Maybe<Int>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
}

export interface ProductCreateavailableSizesInput {
  set?: Maybe<Size[] | Size>;
}

export interface ColorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  colorCode?: Maybe<String>;
  colorCode_not?: Maybe<String>;
  colorCode_in?: Maybe<String[] | String>;
  colorCode_not_in?: Maybe<String[] | String>;
  colorCode_lt?: Maybe<String>;
  colorCode_lte?: Maybe<String>;
  colorCode_gt?: Maybe<String>;
  colorCode_gte?: Maybe<String>;
  colorCode_contains?: Maybe<String>;
  colorCode_not_contains?: Maybe<String>;
  colorCode_starts_with?: Maybe<String>;
  colorCode_not_starts_with?: Maybe<String>;
  colorCode_ends_with?: Maybe<String>;
  colorCode_not_ends_with?: Maybe<String>;
  hexCode?: Maybe<String>;
  hexCode_not?: Maybe<String>;
  hexCode_in?: Maybe<String[] | String>;
  hexCode_not_in?: Maybe<String[] | String>;
  hexCode_lt?: Maybe<String>;
  hexCode_lte?: Maybe<String>;
  hexCode_gt?: Maybe<String>;
  hexCode_gte?: Maybe<String>;
  hexCode_contains?: Maybe<String>;
  hexCode_not_contains?: Maybe<String>;
  hexCode_starts_with?: Maybe<String>;
  hexCode_not_starts_with?: Maybe<String>;
  hexCode_ends_with?: Maybe<String>;
  hexCode_not_ends_with?: Maybe<String>;
  productVariants_every?: Maybe<ProductVariantWhereInput>;
  productVariants_some?: Maybe<ProductVariantWhereInput>;
  productVariants_none?: Maybe<ProductVariantWhereInput>;
  AND?: Maybe<ColorWhereInput[] | ColorWhereInput>;
  OR?: Maybe<ColorWhereInput[] | ColorWhereInput>;
  NOT?: Maybe<ColorWhereInput[] | ColorWhereInput>;
}

export interface ProductCreateinnerMaterialsInput {
  set?: Maybe<Material[] | Material>;
}

export interface CustomerUpdateWithoutReservationsDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
}

export interface ProductCreateouterMaterialsInput {
  set?: Maybe<Material[] | Material>;
}

export type CollectionGroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export interface ProductVariantCreateManyWithoutProductInput {
  create?: Maybe<
    | ProductVariantCreateWithoutProductInput[]
    | ProductVariantCreateWithoutProductInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
}

export interface CollectionGroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  collectionCount?: Maybe<Int>;
  collectionCount_not?: Maybe<Int>;
  collectionCount_in?: Maybe<Int[] | Int>;
  collectionCount_not_in?: Maybe<Int[] | Int>;
  collectionCount_lt?: Maybe<Int>;
  collectionCount_lte?: Maybe<Int>;
  collectionCount_gt?: Maybe<Int>;
  collectionCount_gte?: Maybe<Int>;
  collections_every?: Maybe<CollectionWhereInput>;
  collections_some?: Maybe<CollectionWhereInput>;
  collections_none?: Maybe<CollectionWhereInput>;
  AND?: Maybe<CollectionGroupWhereInput[] | CollectionGroupWhereInput>;
  OR?: Maybe<CollectionGroupWhereInput[] | CollectionGroupWhereInput>;
  NOT?: Maybe<CollectionGroupWhereInput[] | CollectionGroupWhereInput>;
}

export interface ProductVariantCreateWithoutProductInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  color: ColorCreateOneWithoutProductVariantsInput;
  size: Size;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  retailPrice?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutProductVariantInput>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
}

export interface CustomerCreateWithoutReservationsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
}

export interface BillingInfoCreateOneInput {
  create?: Maybe<BillingInfoCreateInput>;
  connect?: Maybe<BillingInfoWhereUniqueInput>;
}

export interface ReservationCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  customer: CustomerCreateOneWithoutReservationsInput;
  sentPackage?: Maybe<PackageCreateOneInput>;
  returnedPackage?: Maybe<PackageCreateOneInput>;
  location?: Maybe<LocationCreateOneInput>;
  products?: Maybe<PhysicalProductCreateManyInput>;
  reservationNumber: Int;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
}

export interface BillingInfoCreateInput {
  id?: Maybe<ID_Input>;
  brand: String;
  name?: Maybe<String>;
  last_digits: String;
  expiration_month: Int;
  expiration_year: Int;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  auth0Id?: Maybe<String>;
  auth0Id_not?: Maybe<String>;
  auth0Id_in?: Maybe<String[] | String>;
  auth0Id_not_in?: Maybe<String[] | String>;
  auth0Id_lt?: Maybe<String>;
  auth0Id_lte?: Maybe<String>;
  auth0Id_gt?: Maybe<String>;
  auth0Id_gte?: Maybe<String>;
  auth0Id_contains?: Maybe<String>;
  auth0Id_not_contains?: Maybe<String>;
  auth0Id_starts_with?: Maybe<String>;
  auth0Id_not_starts_with?: Maybe<String>;
  auth0Id_ends_with?: Maybe<String>;
  auth0Id_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ReservationCreateManyWithoutCustomerInput {
  create?: Maybe<
    | ReservationCreateWithoutCustomerInput[]
    | ReservationCreateWithoutCustomerInput
  >;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
}

export interface ProductVariantUpdateInput {
  sku?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  size?: Maybe<Size>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
}

export interface ReservationCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  sentPackage?: Maybe<PackageCreateOneInput>;
  returnedPackage?: Maybe<PackageCreateOneInput>;
  location?: Maybe<LocationCreateOneInput>;
  products?: Maybe<PhysicalProductCreateManyInput>;
  reservationNumber: Int;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PackageCreateOneInput {
  create?: Maybe<PackageCreateInput>;
  connect?: Maybe<PackageWhereUniqueInput>;
}

export interface ProductRequestUpdateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface PackageCreateInput {
  id?: Maybe<ID_Input>;
  items?: Maybe<PhysicalProductCreateManyInput>;
  shippingLabel: LabelCreateOneInput;
  fromAddress: LocationCreateOneInput;
  toAddress: LocationCreateOneInput;
  weight?: Maybe<Float>;
}

export interface ProductRequestCreateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface PhysicalProductCreateManyInput {
  create?: Maybe<PhysicalProductCreateInput[] | PhysicalProductCreateInput>;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
}

export interface PhysicalProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seasonsUID?: Maybe<String>;
  seasonsUID_not?: Maybe<String>;
  seasonsUID_in?: Maybe<String[] | String>;
  seasonsUID_not_in?: Maybe<String[] | String>;
  seasonsUID_lt?: Maybe<String>;
  seasonsUID_lte?: Maybe<String>;
  seasonsUID_gt?: Maybe<String>;
  seasonsUID_gte?: Maybe<String>;
  seasonsUID_contains?: Maybe<String>;
  seasonsUID_not_contains?: Maybe<String>;
  seasonsUID_starts_with?: Maybe<String>;
  seasonsUID_not_starts_with?: Maybe<String>;
  seasonsUID_ends_with?: Maybe<String>;
  seasonsUID_not_ends_with?: Maybe<String>;
  location?: Maybe<LocationWhereInput>;
  productVariant?: Maybe<ProductVariantWhereInput>;
  inventoryStatus?: Maybe<InventoryStatus>;
  inventoryStatus_not?: Maybe<InventoryStatus>;
  inventoryStatus_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  inventoryStatus_not_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  productStatus_not?: Maybe<PhysicalProductStatus>;
  productStatus_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  productStatus_not_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PhysicalProductWhereInput[] | PhysicalProductWhereInput>;
  OR?: Maybe<PhysicalProductWhereInput[] | PhysicalProductWhereInput>;
  NOT?: Maybe<PhysicalProductWhereInput[] | PhysicalProductWhereInput>;
}

export interface PhysicalProductCreateInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  location: LocationCreateOneWithoutPhysicalProductsInput;
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
}

export interface ProductFunctionUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface LabelCreateOneInput {
  create?: Maybe<LabelCreateInput>;
  connect?: Maybe<LabelWhereUniqueInput>;
}

export type HomepageProductRailWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export interface LabelCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export interface HomepageProductRailWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<HomepageProductRailWhereInput[] | HomepageProductRailWhereInput>;
  OR?: Maybe<HomepageProductRailWhereInput[] | HomepageProductRailWhereInput>;
  NOT?: Maybe<HomepageProductRailWhereInput[] | HomepageProductRailWhereInput>;
}

export interface ProductVariantCreateOneInput {
  create?: Maybe<ProductVariantCreateInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface PhysicalProductUpdateManyMutationInput {
  seasonsUID?: Maybe<String>;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
}

export interface ProductVariantCreateInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  color: ColorCreateOneWithoutProductVariantsInput;
  size: Size;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  product: ProductCreateOneWithoutVariantsInput;
  retailPrice?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutProductVariantInput>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
}

export interface PackageUpdateManyMutationInput {
  weight?: Maybe<Float>;
}

export interface BagItemUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  productVariant?: Maybe<ProductVariantUpdateOneRequiredInput>;
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
}

export interface PackageUpdateInput {
  items?: Maybe<PhysicalProductUpdateManyInput>;
  shippingLabel?: Maybe<LabelUpdateOneRequiredInput>;
  fromAddress?: Maybe<LocationUpdateOneRequiredInput>;
  toAddress?: Maybe<LocationUpdateOneRequiredInput>;
  weight?: Maybe<Float>;
}

export interface CustomerUpdateOneRequiredInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
}

export interface CustomerUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
}

export interface LocationUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserUpdateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutLocationInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type LabelWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateDataInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
}

export interface ImageUpdateManyMutationInput {
  caption?: Maybe<String>;
  originalHeight?: Maybe<Int>;
  originalUrl?: Maybe<String>;
  originalWidth?: Maybe<Int>;
  resizedUrl?: Maybe<String>;
  title?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ImageCreateInput {
  id?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  originalHeight?: Maybe<Int>;
  originalUrl: String;
  originalWidth?: Maybe<Int>;
  resizedUrl: String;
  title?: Maybe<String>;
}

export interface CustomerDetailUpdateOneInput {
  create?: Maybe<CustomerDetailCreateInput>;
  update?: Maybe<CustomerDetailUpdateDataInput>;
  upsert?: Maybe<CustomerDetailUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerDetailWhereUniqueInput>;
}

export interface HomepageProductRailUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
}

export interface CustomerDetailUpdateDataInput {
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<String>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  averageWaistSize?: Maybe<String>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  shippingAddress?: Maybe<LocationUpdateOneInput>;
  phoneOS?: Maybe<String>;
}

export interface HomepageProductRailCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  products?: Maybe<ProductCreateManyInput>;
}

export interface LocationUpdateOneInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LocationUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserUpdateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutLocationInput>;
}

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CustomerUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailUpdateOneInput>;
  billingInfo?: Maybe<BillingInfoUpdateOneInput>;
  plan?: Maybe<Plan>;
  reservations?: Maybe<ReservationUpdateManyWithoutCustomerInput>;
}

export interface PhysicalProductUpdateManyWithoutLocationInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutLocationInput[]
    | PhysicalProductCreateWithoutLocationInput
  >;
  delete?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  set?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  update?: Maybe<
    | PhysicalProductUpdateWithWhereUniqueWithoutLocationInput[]
    | PhysicalProductUpdateWithWhereUniqueWithoutLocationInput
  >;
  upsert?: Maybe<
    | PhysicalProductUpsertWithWhereUniqueWithoutLocationInput[]
    | PhysicalProductUpsertWithWhereUniqueWithoutLocationInput
  >;
  deleteMany?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductUpdateManyWithWhereNestedInput[]
    | PhysicalProductUpdateManyWithWhereNestedInput
  >;
}

export interface ColorUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
  productVariants?: Maybe<ProductVariantUpdateManyWithoutColorInput>;
}

export interface BrandUpdateInput {
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name?: Maybe<String>;
  basedIn?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutBrandInput>;
  since?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  websiteUrl?: Maybe<String>;
}

export interface CollectionGroupUpdateManyMutationInput {
  slug?: Maybe<String>;
  title?: Maybe<String>;
  collectionCount?: Maybe<Int>;
}

export interface PhysicalProductUpdateWithoutLocationDataInput {
  seasonsUID?: Maybe<String>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
}

export interface CollectionUpdateManyWithWhereNestedInput {
  where: CollectionScalarWhereInput;
  data: CollectionUpdateManyDataInput;
}

export interface ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput {
  create?: Maybe<ProductVariantCreateWithoutPhysicalProductsInput>;
  update?: Maybe<ProductVariantUpdateWithoutPhysicalProductsDataInput>;
  upsert?: Maybe<ProductVariantUpsertWithoutPhysicalProductsInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export type PhysicalProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  seasonsUID?: Maybe<String>;
}>;

export interface ProductVariantUpdateWithoutPhysicalProductsDataInput {
  sku?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  size?: Maybe<Size>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
}

export interface CollectionUpdateDataInput {
  slug?: Maybe<String>;
  images?: Maybe<Json>;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptionTop?: Maybe<String>;
  descriptionBottom?: Maybe<String>;
  products?: Maybe<ProductUpdateManyInput>;
}

export interface ColorUpdateOneRequiredWithoutProductVariantsInput {
  create?: Maybe<ColorCreateWithoutProductVariantsInput>;
  update?: Maybe<ColorUpdateWithoutProductVariantsDataInput>;
  upsert?: Maybe<ColorUpsertWithoutProductVariantsInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export interface ColorUpdateWithoutProductVariantsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
}

export interface CollectionGroupUpdateInput {
  slug?: Maybe<String>;
  title?: Maybe<String>;
  collectionCount?: Maybe<Int>;
  collections?: Maybe<CollectionUpdateManyInput>;
}

export interface ColorUpsertWithoutProductVariantsInput {
  update: ColorUpdateWithoutProductVariantsDataInput;
  create: ColorCreateWithoutProductVariantsInput;
}

export type ProductFunctionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface ProductUpdateOneRequiredWithoutVariantsInput {
  create?: Maybe<ProductCreateWithoutVariantsInput>;
  update?: Maybe<ProductUpdateWithoutVariantsDataInput>;
  upsert?: Maybe<ProductUpsertWithoutVariantsInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface CollectionUpdateManyMutationInput {
  slug?: Maybe<String>;
  images?: Maybe<Json>;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptionTop?: Maybe<String>;
  descriptionBottom?: Maybe<String>;
}

export interface ProductUpdateWithoutVariantsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images?: Maybe<Json>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  availableSizes?: Maybe<ProductUpdateavailableSizesInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  status?: Maybe<ProductStatus>;
}

export type ProductRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BrandUpdateOneRequiredWithoutProductsInput {
  create?: Maybe<BrandCreateWithoutProductsInput>;
  update?: Maybe<BrandUpdateWithoutProductsDataInput>;
  upsert?: Maybe<BrandUpsertWithoutProductsInput>;
  connect?: Maybe<BrandWhereUniqueInput>;
}

export interface ProductRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  priceCurrency_not?: Maybe<String>;
  priceCurrency_in?: Maybe<String[] | String>;
  priceCurrency_not_in?: Maybe<String[] | String>;
  priceCurrency_lt?: Maybe<String>;
  priceCurrency_lte?: Maybe<String>;
  priceCurrency_gt?: Maybe<String>;
  priceCurrency_gte?: Maybe<String>;
  priceCurrency_contains?: Maybe<String>;
  priceCurrency_not_contains?: Maybe<String>;
  priceCurrency_starts_with?: Maybe<String>;
  priceCurrency_not_starts_with?: Maybe<String>;
  priceCurrency_ends_with?: Maybe<String>;
  priceCurrency_not_ends_with?: Maybe<String>;
  productID?: Maybe<String>;
  productID_not?: Maybe<String>;
  productID_in?: Maybe<String[] | String>;
  productID_not_in?: Maybe<String[] | String>;
  productID_lt?: Maybe<String>;
  productID_lte?: Maybe<String>;
  productID_gt?: Maybe<String>;
  productID_gte?: Maybe<String>;
  productID_contains?: Maybe<String>;
  productID_not_contains?: Maybe<String>;
  productID_starts_with?: Maybe<String>;
  productID_not_starts_with?: Maybe<String>;
  productID_ends_with?: Maybe<String>;
  productID_not_ends_with?: Maybe<String>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<ProductRequestWhereInput[] | ProductRequestWhereInput>;
  OR?: Maybe<ProductRequestWhereInput[] | ProductRequestWhereInput>;
  NOT?: Maybe<ProductRequestWhereInput[] | ProductRequestWhereInput>;
}

export interface BrandUpdateWithoutProductsDataInput {
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name?: Maybe<String>;
  basedIn?: Maybe<String>;
  since?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  websiteUrl?: Maybe<String>;
}

export interface ProductUpdateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput;
  create: BrandCreateWithoutProductsInput;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  category: CategoryCreateOneWithoutProductsInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images: Json;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color: ColorCreateOneInput;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  availableSizes?: Maybe<ProductCreateavailableSizesInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
  status?: Maybe<ProductStatus>;
}

export interface CategoryUpdateOneRequiredWithoutProductsInput {
  create?: Maybe<CategoryCreateWithoutProductsInput>;
  update?: Maybe<CategoryUpdateWithoutProductsDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutProductsInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface ProductCreateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface CategoryUpdateWithoutProductsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  children?: Maybe<CategoryUpdateManyWithoutChildrenInput>;
}

export interface CategoryUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
}

export interface CategoryUpdateManyWithoutChildrenInput {
  create?: Maybe<
    CategoryCreateWithoutChildrenInput[] | CategoryCreateWithoutChildrenInput
  >;
  delete?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  set?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  disconnect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  update?: Maybe<
    | CategoryUpdateWithWhereUniqueWithoutChildrenInput[]
    | CategoryUpdateWithWhereUniqueWithoutChildrenInput
  >;
  upsert?: Maybe<
    | CategoryUpsertWithWhereUniqueWithoutChildrenInput[]
    | CategoryUpsertWithWhereUniqueWithoutChildrenInput
  >;
  deleteMany?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  updateMany?: Maybe<
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput
  >;
}

export interface CategoryUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductUpdateManyWithoutCategoryInput>;
  children?: Maybe<CategoryUpdateManyWithoutChildrenInput>;
}

export interface CategoryUpdateWithWhereUniqueWithoutChildrenInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutChildrenDataInput;
}

export interface BrandUpdateManyMutationInput {
  slug?: Maybe<String>;
  brandCode?: Maybe<String>;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name?: Maybe<String>;
  basedIn?: Maybe<String>;
  since?: Maybe<DateTimeInput>;
  tier?: Maybe<BrandTier>;
  websiteUrl?: Maybe<String>;
}

export interface CategoryUpdateWithoutChildrenDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductUpdateManyWithoutCategoryInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutBrandDataInput;
  create: ProductCreateWithoutBrandInput;
}

export interface ProductUpdateManyWithoutCategoryInput {
  create?: Maybe<
    ProductCreateWithoutCategoryInput[] | ProductCreateWithoutCategoryInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProductUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProductUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutBrandDataInput;
}

export interface ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCategoryDataInput;
}

export interface CustomerCreateOneInput {
  create?: Maybe<CustomerCreateInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface ProductCreateWithoutBrandInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  category: CategoryCreateOneWithoutProductsInput;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images: Json;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color: ColorCreateOneInput;
  secondaryColor?: Maybe<ColorCreateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionCreateManyInput>;
  availableSizes?: Maybe<ProductCreateavailableSizesInput>;
  innerMaterials?: Maybe<ProductCreateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductCreateouterMaterialsInput>;
  variants?: Maybe<ProductVariantCreateManyWithoutProductInput>;
  status?: Maybe<ProductStatus>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ColorUpdateOneRequiredInput {
  create?: Maybe<ColorCreateInput>;
  update?: Maybe<ColorUpdateDataInput>;
  upsert?: Maybe<ColorUpsertNestedInput>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface CustomerDetailCreateOneInput {
  create?: Maybe<CustomerDetailCreateInput>;
  connect?: Maybe<CustomerDetailWhereUniqueInput>;
}

export interface ColorUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
  productVariants?: Maybe<ProductVariantUpdateManyWithoutColorInput>;
}

export interface LocationCreateOneInput {
  create?: Maybe<LocationCreateInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface ProductVariantUpdateManyWithoutColorInput {
  create?: Maybe<
    | ProductVariantCreateWithoutColorInput[]
    | ProductVariantCreateWithoutColorInput
  >;
  delete?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  set?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  update?: Maybe<
    | ProductVariantUpdateWithWhereUniqueWithoutColorInput[]
    | ProductVariantUpdateWithWhereUniqueWithoutColorInput
  >;
  upsert?: Maybe<
    | ProductVariantUpsertWithWhereUniqueWithoutColorInput[]
    | ProductVariantUpsertWithWhereUniqueWithoutColorInput
  >;
  deleteMany?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductVariantUpdateManyWithWhereNestedInput[]
    | ProductVariantUpdateManyWithWhereNestedInput
  >;
}

export interface PhysicalProductCreateManyWithoutLocationInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutLocationInput[]
    | PhysicalProductCreateWithoutLocationInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
}

export interface ProductVariantUpdateWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput;
  data: ProductVariantUpdateWithoutColorDataInput;
}

export interface ProductVariantCreateOneWithoutPhysicalProductsInput {
  create?: Maybe<ProductVariantCreateWithoutPhysicalProductsInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface ProductVariantUpdateWithoutColorDataInput {
  sku?: Maybe<String>;
  size?: Maybe<Size>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface PhysicalProductUpdateManyWithoutProductVariantInput {
  create?: Maybe<
    | PhysicalProductCreateWithoutProductVariantInput[]
    | PhysicalProductCreateWithoutProductVariantInput
  >;
  delete?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  set?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  update?: Maybe<
    | PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput[]
    | PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput
  >;
  upsert?: Maybe<
    | PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput[]
    | PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput
  >;
  deleteMany?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductUpdateManyWithWhereNestedInput[]
    | PhysicalProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductFunctionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductFunctionWhereInput>;
  AND?: Maybe<
    | ProductFunctionSubscriptionWhereInput[]
    | ProductFunctionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductFunctionSubscriptionWhereInput[]
    | ProductFunctionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductFunctionSubscriptionWhereInput[]
    | ProductFunctionSubscriptionWhereInput
  >;
}

export interface PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput;
  data: PhysicalProductUpdateWithoutProductVariantDataInput;
}

export interface CustomerDetailWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  weight?: Maybe<String>;
  weight_not?: Maybe<String>;
  weight_in?: Maybe<String[] | String>;
  weight_not_in?: Maybe<String[] | String>;
  weight_lt?: Maybe<String>;
  weight_lte?: Maybe<String>;
  weight_gt?: Maybe<String>;
  weight_gte?: Maybe<String>;
  weight_contains?: Maybe<String>;
  weight_not_contains?: Maybe<String>;
  weight_starts_with?: Maybe<String>;
  weight_not_starts_with?: Maybe<String>;
  weight_ends_with?: Maybe<String>;
  weight_not_ends_with?: Maybe<String>;
  bodyType?: Maybe<String>;
  bodyType_not?: Maybe<String>;
  bodyType_in?: Maybe<String[] | String>;
  bodyType_not_in?: Maybe<String[] | String>;
  bodyType_lt?: Maybe<String>;
  bodyType_lte?: Maybe<String>;
  bodyType_gt?: Maybe<String>;
  bodyType_gte?: Maybe<String>;
  bodyType_contains?: Maybe<String>;
  bodyType_not_contains?: Maybe<String>;
  bodyType_starts_with?: Maybe<String>;
  bodyType_not_starts_with?: Maybe<String>;
  bodyType_ends_with?: Maybe<String>;
  bodyType_not_ends_with?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  averageTopSize_not?: Maybe<String>;
  averageTopSize_in?: Maybe<String[] | String>;
  averageTopSize_not_in?: Maybe<String[] | String>;
  averageTopSize_lt?: Maybe<String>;
  averageTopSize_lte?: Maybe<String>;
  averageTopSize_gt?: Maybe<String>;
  averageTopSize_gte?: Maybe<String>;
  averageTopSize_contains?: Maybe<String>;
  averageTopSize_not_contains?: Maybe<String>;
  averageTopSize_starts_with?: Maybe<String>;
  averageTopSize_not_starts_with?: Maybe<String>;
  averageTopSize_ends_with?: Maybe<String>;
  averageTopSize_not_ends_with?: Maybe<String>;
  averageWaistSize?: Maybe<String>;
  averageWaistSize_not?: Maybe<String>;
  averageWaistSize_in?: Maybe<String[] | String>;
  averageWaistSize_not_in?: Maybe<String[] | String>;
  averageWaistSize_lt?: Maybe<String>;
  averageWaistSize_lte?: Maybe<String>;
  averageWaistSize_gt?: Maybe<String>;
  averageWaistSize_gte?: Maybe<String>;
  averageWaistSize_contains?: Maybe<String>;
  averageWaistSize_not_contains?: Maybe<String>;
  averageWaistSize_starts_with?: Maybe<String>;
  averageWaistSize_not_starts_with?: Maybe<String>;
  averageWaistSize_ends_with?: Maybe<String>;
  averageWaistSize_not_ends_with?: Maybe<String>;
  averagePantLength?: Maybe<String>;
  averagePantLength_not?: Maybe<String>;
  averagePantLength_in?: Maybe<String[] | String>;
  averagePantLength_not_in?: Maybe<String[] | String>;
  averagePantLength_lt?: Maybe<String>;
  averagePantLength_lte?: Maybe<String>;
  averagePantLength_gt?: Maybe<String>;
  averagePantLength_gte?: Maybe<String>;
  averagePantLength_contains?: Maybe<String>;
  averagePantLength_not_contains?: Maybe<String>;
  averagePantLength_starts_with?: Maybe<String>;
  averagePantLength_not_starts_with?: Maybe<String>;
  averagePantLength_ends_with?: Maybe<String>;
  averagePantLength_not_ends_with?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  preferredPronouns_not?: Maybe<String>;
  preferredPronouns_in?: Maybe<String[] | String>;
  preferredPronouns_not_in?: Maybe<String[] | String>;
  preferredPronouns_lt?: Maybe<String>;
  preferredPronouns_lte?: Maybe<String>;
  preferredPronouns_gt?: Maybe<String>;
  preferredPronouns_gte?: Maybe<String>;
  preferredPronouns_contains?: Maybe<String>;
  preferredPronouns_not_contains?: Maybe<String>;
  preferredPronouns_starts_with?: Maybe<String>;
  preferredPronouns_not_starts_with?: Maybe<String>;
  preferredPronouns_ends_with?: Maybe<String>;
  preferredPronouns_not_ends_with?: Maybe<String>;
  profession?: Maybe<String>;
  profession_not?: Maybe<String>;
  profession_in?: Maybe<String[] | String>;
  profession_not_in?: Maybe<String[] | String>;
  profession_lt?: Maybe<String>;
  profession_lte?: Maybe<String>;
  profession_gt?: Maybe<String>;
  profession_gte?: Maybe<String>;
  profession_contains?: Maybe<String>;
  profession_not_contains?: Maybe<String>;
  profession_starts_with?: Maybe<String>;
  profession_not_starts_with?: Maybe<String>;
  profession_ends_with?: Maybe<String>;
  profession_not_ends_with?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  partyFrequency_not?: Maybe<String>;
  partyFrequency_in?: Maybe<String[] | String>;
  partyFrequency_not_in?: Maybe<String[] | String>;
  partyFrequency_lt?: Maybe<String>;
  partyFrequency_lte?: Maybe<String>;
  partyFrequency_gt?: Maybe<String>;
  partyFrequency_gte?: Maybe<String>;
  partyFrequency_contains?: Maybe<String>;
  partyFrequency_not_contains?: Maybe<String>;
  partyFrequency_starts_with?: Maybe<String>;
  partyFrequency_not_starts_with?: Maybe<String>;
  partyFrequency_ends_with?: Maybe<String>;
  partyFrequency_not_ends_with?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  travelFrequency_not?: Maybe<String>;
  travelFrequency_in?: Maybe<String[] | String>;
  travelFrequency_not_in?: Maybe<String[] | String>;
  travelFrequency_lt?: Maybe<String>;
  travelFrequency_lte?: Maybe<String>;
  travelFrequency_gt?: Maybe<String>;
  travelFrequency_gte?: Maybe<String>;
  travelFrequency_contains?: Maybe<String>;
  travelFrequency_not_contains?: Maybe<String>;
  travelFrequency_starts_with?: Maybe<String>;
  travelFrequency_not_starts_with?: Maybe<String>;
  travelFrequency_ends_with?: Maybe<String>;
  travelFrequency_not_ends_with?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  shoppingFrequency_not?: Maybe<String>;
  shoppingFrequency_in?: Maybe<String[] | String>;
  shoppingFrequency_not_in?: Maybe<String[] | String>;
  shoppingFrequency_lt?: Maybe<String>;
  shoppingFrequency_lte?: Maybe<String>;
  shoppingFrequency_gt?: Maybe<String>;
  shoppingFrequency_gte?: Maybe<String>;
  shoppingFrequency_contains?: Maybe<String>;
  shoppingFrequency_not_contains?: Maybe<String>;
  shoppingFrequency_starts_with?: Maybe<String>;
  shoppingFrequency_not_starts_with?: Maybe<String>;
  shoppingFrequency_ends_with?: Maybe<String>;
  shoppingFrequency_not_ends_with?: Maybe<String>;
  averageSpend?: Maybe<String>;
  averageSpend_not?: Maybe<String>;
  averageSpend_in?: Maybe<String[] | String>;
  averageSpend_not_in?: Maybe<String[] | String>;
  averageSpend_lt?: Maybe<String>;
  averageSpend_lte?: Maybe<String>;
  averageSpend_gt?: Maybe<String>;
  averageSpend_gte?: Maybe<String>;
  averageSpend_contains?: Maybe<String>;
  averageSpend_not_contains?: Maybe<String>;
  averageSpend_starts_with?: Maybe<String>;
  averageSpend_not_starts_with?: Maybe<String>;
  averageSpend_ends_with?: Maybe<String>;
  averageSpend_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  commuteStyle_not?: Maybe<String>;
  commuteStyle_in?: Maybe<String[] | String>;
  commuteStyle_not_in?: Maybe<String[] | String>;
  commuteStyle_lt?: Maybe<String>;
  commuteStyle_lte?: Maybe<String>;
  commuteStyle_gt?: Maybe<String>;
  commuteStyle_gte?: Maybe<String>;
  commuteStyle_contains?: Maybe<String>;
  commuteStyle_not_contains?: Maybe<String>;
  commuteStyle_starts_with?: Maybe<String>;
  commuteStyle_not_starts_with?: Maybe<String>;
  commuteStyle_ends_with?: Maybe<String>;
  commuteStyle_not_ends_with?: Maybe<String>;
  shippingAddress?: Maybe<LocationWhereInput>;
  phoneOS?: Maybe<String>;
  phoneOS_not?: Maybe<String>;
  phoneOS_in?: Maybe<String[] | String>;
  phoneOS_not_in?: Maybe<String[] | String>;
  phoneOS_lt?: Maybe<String>;
  phoneOS_lte?: Maybe<String>;
  phoneOS_gt?: Maybe<String>;
  phoneOS_gte?: Maybe<String>;
  phoneOS_contains?: Maybe<String>;
  phoneOS_not_contains?: Maybe<String>;
  phoneOS_starts_with?: Maybe<String>;
  phoneOS_not_starts_with?: Maybe<String>;
  phoneOS_ends_with?: Maybe<String>;
  phoneOS_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerDetailWhereInput[] | CustomerDetailWhereInput>;
  OR?: Maybe<CustomerDetailWhereInput[] | CustomerDetailWhereInput>;
  NOT?: Maybe<CustomerDetailWhereInput[] | CustomerDetailWhereInput>;
}

export interface PhysicalProductUpdateWithoutProductVariantDataInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneRequiredWithoutPhysicalProductsInput>;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
}

export interface PhysicalProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhysicalProductWhereInput>;
  AND?: Maybe<
    | PhysicalProductSubscriptionWhereInput[]
    | PhysicalProductSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PhysicalProductSubscriptionWhereInput[]
    | PhysicalProductSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PhysicalProductSubscriptionWhereInput[]
    | PhysicalProductSubscriptionWhereInput
  >;
}

export interface LocationUpdateOneRequiredWithoutPhysicalProductsInput {
  create?: Maybe<LocationCreateWithoutPhysicalProductsInput>;
  update?: Maybe<LocationUpdateWithoutPhysicalProductsDataInput>;
  upsert?: Maybe<LocationUpsertWithoutPhysicalProductsInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LocationWhereInput>;
  AND?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
  OR?: Maybe<LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput>;
  NOT?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
}

export interface LocationUpdateWithoutPhysicalProductsDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserUpdateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  OR?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  NOT?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface LocationUpsertWithoutPhysicalProductsInput {
  update: LocationUpdateWithoutPhysicalProductsDataInput;
  create: LocationCreateWithoutPhysicalProductsInput;
}

export type BillingInfoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput;
  update: PhysicalProductUpdateWithoutProductVariantDataInput;
  create: PhysicalProductCreateWithoutProductVariantInput;
}

export interface CollectionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CollectionWhereInput>;
  AND?: Maybe<
    CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput
  >;
  OR?: Maybe<
    CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput
  >;
}

export interface PhysicalProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seasonsUID?: Maybe<String>;
  seasonsUID_not?: Maybe<String>;
  seasonsUID_in?: Maybe<String[] | String>;
  seasonsUID_not_in?: Maybe<String[] | String>;
  seasonsUID_lt?: Maybe<String>;
  seasonsUID_lte?: Maybe<String>;
  seasonsUID_gt?: Maybe<String>;
  seasonsUID_gte?: Maybe<String>;
  seasonsUID_contains?: Maybe<String>;
  seasonsUID_not_contains?: Maybe<String>;
  seasonsUID_starts_with?: Maybe<String>;
  seasonsUID_not_starts_with?: Maybe<String>;
  seasonsUID_ends_with?: Maybe<String>;
  seasonsUID_not_ends_with?: Maybe<String>;
  inventoryStatus?: Maybe<InventoryStatus>;
  inventoryStatus_not?: Maybe<InventoryStatus>;
  inventoryStatus_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  inventoryStatus_not_in?: Maybe<InventoryStatus[] | InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
  productStatus_not?: Maybe<PhysicalProductStatus>;
  productStatus_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  productStatus_not_in?: Maybe<PhysicalProductStatus[] | PhysicalProductStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  OR?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  NOT?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
}

export interface BrandSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BrandWhereInput>;
  AND?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
  OR?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
  NOT?: Maybe<BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput>;
}

export interface PhysicalProductUpdateManyWithWhereNestedInput {
  where: PhysicalProductScalarWhereInput;
  data: PhysicalProductUpdateManyDataInput;
}

export interface UserUpdateManyMutationInput {
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  role?: Maybe<UserRole>;
}

export interface PhysicalProductUpdateManyDataInput {
  seasonsUID?: Maybe<String>;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
}

export interface CollectionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subTitle?: Maybe<String>;
  subTitle_not?: Maybe<String>;
  subTitle_in?: Maybe<String[] | String>;
  subTitle_not_in?: Maybe<String[] | String>;
  subTitle_lt?: Maybe<String>;
  subTitle_lte?: Maybe<String>;
  subTitle_gt?: Maybe<String>;
  subTitle_gte?: Maybe<String>;
  subTitle_contains?: Maybe<String>;
  subTitle_not_contains?: Maybe<String>;
  subTitle_starts_with?: Maybe<String>;
  subTitle_not_starts_with?: Maybe<String>;
  subTitle_ends_with?: Maybe<String>;
  subTitle_not_ends_with?: Maybe<String>;
  descriptionTop?: Maybe<String>;
  descriptionTop_not?: Maybe<String>;
  descriptionTop_in?: Maybe<String[] | String>;
  descriptionTop_not_in?: Maybe<String[] | String>;
  descriptionTop_lt?: Maybe<String>;
  descriptionTop_lte?: Maybe<String>;
  descriptionTop_gt?: Maybe<String>;
  descriptionTop_gte?: Maybe<String>;
  descriptionTop_contains?: Maybe<String>;
  descriptionTop_not_contains?: Maybe<String>;
  descriptionTop_starts_with?: Maybe<String>;
  descriptionTop_not_starts_with?: Maybe<String>;
  descriptionTop_ends_with?: Maybe<String>;
  descriptionTop_not_ends_with?: Maybe<String>;
  descriptionBottom?: Maybe<String>;
  descriptionBottom_not?: Maybe<String>;
  descriptionBottom_in?: Maybe<String[] | String>;
  descriptionBottom_not_in?: Maybe<String[] | String>;
  descriptionBottom_lt?: Maybe<String>;
  descriptionBottom_lte?: Maybe<String>;
  descriptionBottom_gt?: Maybe<String>;
  descriptionBottom_gte?: Maybe<String>;
  descriptionBottom_contains?: Maybe<String>;
  descriptionBottom_not_contains?: Maybe<String>;
  descriptionBottom_starts_with?: Maybe<String>;
  descriptionBottom_not_starts_with?: Maybe<String>;
  descriptionBottom_ends_with?: Maybe<String>;
  descriptionBottom_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<CollectionWhereInput[] | CollectionWhereInput>;
  OR?: Maybe<CollectionWhereInput[] | CollectionWhereInput>;
  NOT?: Maybe<CollectionWhereInput[] | CollectionWhereInput>;
}

export interface ProductVariantUpsertWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput;
  update: ProductVariantUpdateWithoutColorDataInput;
  create: ProductVariantCreateWithoutColorInput;
}

export interface CustomerUpdateOneRequiredWithoutReservationsInput {
  create?: Maybe<CustomerCreateWithoutReservationsInput>;
  update?: Maybe<CustomerUpdateWithoutReservationsDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutReservationsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface ProductVariantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  size?: Maybe<Size>;
  size_not?: Maybe<Size>;
  size_in?: Maybe<Size[] | Size>;
  size_not_in?: Maybe<Size[] | Size>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  productID?: Maybe<String>;
  productID_not?: Maybe<String>;
  productID_in?: Maybe<String[] | String>;
  productID_not_in?: Maybe<String[] | String>;
  productID_lt?: Maybe<String>;
  productID_lte?: Maybe<String>;
  productID_gt?: Maybe<String>;
  productID_gte?: Maybe<String>;
  productID_contains?: Maybe<String>;
  productID_not_contains?: Maybe<String>;
  productID_starts_with?: Maybe<String>;
  productID_not_starts_with?: Maybe<String>;
  productID_ends_with?: Maybe<String>;
  productID_not_ends_with?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  retailPrice_not?: Maybe<Float>;
  retailPrice_in?: Maybe<Float[] | Float>;
  retailPrice_not_in?: Maybe<Float[] | Float>;
  retailPrice_lt?: Maybe<Float>;
  retailPrice_lte?: Maybe<Float>;
  retailPrice_gt?: Maybe<Float>;
  retailPrice_gte?: Maybe<Float>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reservable_not?: Maybe<Int>;
  reservable_in?: Maybe<Int[] | Int>;
  reservable_not_in?: Maybe<Int[] | Int>;
  reservable_lt?: Maybe<Int>;
  reservable_lte?: Maybe<Int>;
  reservable_gt?: Maybe<Int>;
  reservable_gte?: Maybe<Int>;
  reserved?: Maybe<Int>;
  reserved_not?: Maybe<Int>;
  reserved_in?: Maybe<Int[] | Int>;
  reserved_not_in?: Maybe<Int[] | Int>;
  reserved_lt?: Maybe<Int>;
  reserved_lte?: Maybe<Int>;
  reserved_gt?: Maybe<Int>;
  reserved_gte?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  nonReservable_not?: Maybe<Int>;
  nonReservable_in?: Maybe<Int[] | Int>;
  nonReservable_not_in?: Maybe<Int[] | Int>;
  nonReservable_lt?: Maybe<Int>;
  nonReservable_lte?: Maybe<Int>;
  nonReservable_gt?: Maybe<Int>;
  nonReservable_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
  OR?: Maybe<ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput>;
  NOT?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
}

export interface ProductVariantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  color?: Maybe<ColorWhereInput>;
  size?: Maybe<Size>;
  size_not?: Maybe<Size>;
  size_in?: Maybe<Size[] | Size>;
  size_not_in?: Maybe<Size[] | Size>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  productID?: Maybe<String>;
  productID_not?: Maybe<String>;
  productID_in?: Maybe<String[] | String>;
  productID_not_in?: Maybe<String[] | String>;
  productID_lt?: Maybe<String>;
  productID_lte?: Maybe<String>;
  productID_gt?: Maybe<String>;
  productID_gte?: Maybe<String>;
  productID_contains?: Maybe<String>;
  productID_not_contains?: Maybe<String>;
  productID_starts_with?: Maybe<String>;
  productID_not_starts_with?: Maybe<String>;
  productID_ends_with?: Maybe<String>;
  productID_not_ends_with?: Maybe<String>;
  product?: Maybe<ProductWhereInput>;
  retailPrice?: Maybe<Float>;
  retailPrice_not?: Maybe<Float>;
  retailPrice_in?: Maybe<Float[] | Float>;
  retailPrice_not_in?: Maybe<Float[] | Float>;
  retailPrice_lt?: Maybe<Float>;
  retailPrice_lte?: Maybe<Float>;
  retailPrice_gt?: Maybe<Float>;
  retailPrice_gte?: Maybe<Float>;
  physicalProducts_every?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_some?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_none?: Maybe<PhysicalProductWhereInput>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reservable_not?: Maybe<Int>;
  reservable_in?: Maybe<Int[] | Int>;
  reservable_not_in?: Maybe<Int[] | Int>;
  reservable_lt?: Maybe<Int>;
  reservable_lte?: Maybe<Int>;
  reservable_gt?: Maybe<Int>;
  reservable_gte?: Maybe<Int>;
  reserved?: Maybe<Int>;
  reserved_not?: Maybe<Int>;
  reserved_in?: Maybe<Int[] | Int>;
  reserved_not_in?: Maybe<Int[] | Int>;
  reserved_lt?: Maybe<Int>;
  reserved_lte?: Maybe<Int>;
  reserved_gt?: Maybe<Int>;
  reserved_gte?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
  nonReservable_not?: Maybe<Int>;
  nonReservable_in?: Maybe<Int[] | Int>;
  nonReservable_not_in?: Maybe<Int[] | Int>;
  nonReservable_lt?: Maybe<Int>;
  nonReservable_lte?: Maybe<Int>;
  nonReservable_gt?: Maybe<Int>;
  nonReservable_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductVariantWhereInput[] | ProductVariantWhereInput>;
  OR?: Maybe<ProductVariantWhereInput[] | ProductVariantWhereInput>;
  NOT?: Maybe<ProductVariantWhereInput[] | ProductVariantWhereInput>;
}

export interface ProductVariantUpdateManyWithWhereNestedInput {
  where: ProductVariantScalarWhereInput;
  data: ProductVariantUpdateManyDataInput;
}

export type ColorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
  colorCode?: Maybe<String>;
}>;

export interface ProductVariantUpdateManyDataInput {
  sku?: Maybe<String>;
  size?: Maybe<Size>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
}

export interface ProductRequestUpdateManyMutationInput {
  brand?: Maybe<String>;
  description?: Maybe<String>;
  images?: Maybe<ProductRequestUpdateimagesInput>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  productID?: Maybe<String>;
  reason?: Maybe<String>;
  sku?: Maybe<String>;
  url?: Maybe<String>;
}

export interface ColorUpsertNestedInput {
  update: ColorUpdateDataInput;
  create: ColorCreateInput;
}

export interface ProductRequestUpdateInput {
  brand?: Maybe<String>;
  description?: Maybe<String>;
  images?: Maybe<ProductRequestUpdateimagesInput>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  productID?: Maybe<String>;
  reason?: Maybe<String>;
  sku?: Maybe<String>;
  url?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface ColorUpdateOneInput {
  create?: Maybe<ColorCreateInput>;
  update?: Maybe<ColorUpdateDataInput>;
  upsert?: Maybe<ColorUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ColorWhereUniqueInput>;
}

export interface ProductRequestCreateInput {
  id?: Maybe<ID_Input>;
  brand?: Maybe<String>;
  description?: Maybe<String>;
  images?: Maybe<ProductRequestCreateimagesInput>;
  name?: Maybe<String>;
  price?: Maybe<Int>;
  priceCurrency?: Maybe<String>;
  productID?: Maybe<String>;
  reason: String;
  sku?: Maybe<String>;
  url: String;
  user?: Maybe<UserCreateOneInput>;
}

export interface ProductFunctionUpdateManyInput {
  create?: Maybe<ProductFunctionCreateInput[] | ProductFunctionCreateInput>;
  update?: Maybe<
    | ProductFunctionUpdateWithWhereUniqueNestedInput[]
    | ProductFunctionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductFunctionUpsertWithWhereUniqueNestedInput[]
    | ProductFunctionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  connect?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  set?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProductFunctionWhereUniqueInput[] | ProductFunctionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductFunctionUpdateManyWithWhereNestedInput[]
    | ProductFunctionUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images?: Maybe<Json>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  tags?: Maybe<Json>;
  availableSizes?: Maybe<ProductUpdateavailableSizesInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  status?: Maybe<ProductStatus>;
}

export interface ProductFunctionUpdateWithWhereUniqueNestedInput {
  where: ProductFunctionWhereUniqueInput;
  data: ProductFunctionUpdateDataInput;
}

export interface PhysicalProductUpdateInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneRequiredWithoutPhysicalProductsInput>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
}

export interface ProductFunctionUpdateDataInput {
  name?: Maybe<String>;
}

export interface ImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  originalHeight?: Maybe<Int>;
  originalHeight_not?: Maybe<Int>;
  originalHeight_in?: Maybe<Int[] | Int>;
  originalHeight_not_in?: Maybe<Int[] | Int>;
  originalHeight_lt?: Maybe<Int>;
  originalHeight_lte?: Maybe<Int>;
  originalHeight_gt?: Maybe<Int>;
  originalHeight_gte?: Maybe<Int>;
  originalUrl?: Maybe<String>;
  originalUrl_not?: Maybe<String>;
  originalUrl_in?: Maybe<String[] | String>;
  originalUrl_not_in?: Maybe<String[] | String>;
  originalUrl_lt?: Maybe<String>;
  originalUrl_lte?: Maybe<String>;
  originalUrl_gt?: Maybe<String>;
  originalUrl_gte?: Maybe<String>;
  originalUrl_contains?: Maybe<String>;
  originalUrl_not_contains?: Maybe<String>;
  originalUrl_starts_with?: Maybe<String>;
  originalUrl_not_starts_with?: Maybe<String>;
  originalUrl_ends_with?: Maybe<String>;
  originalUrl_not_ends_with?: Maybe<String>;
  originalWidth?: Maybe<Int>;
  originalWidth_not?: Maybe<Int>;
  originalWidth_in?: Maybe<Int[] | Int>;
  originalWidth_not_in?: Maybe<Int[] | Int>;
  originalWidth_lt?: Maybe<Int>;
  originalWidth_lte?: Maybe<Int>;
  originalWidth_gt?: Maybe<Int>;
  originalWidth_gte?: Maybe<Int>;
  resizedUrl?: Maybe<String>;
  resizedUrl_not?: Maybe<String>;
  resizedUrl_in?: Maybe<String[] | String>;
  resizedUrl_not_in?: Maybe<String[] | String>;
  resizedUrl_lt?: Maybe<String>;
  resizedUrl_lte?: Maybe<String>;
  resizedUrl_gt?: Maybe<String>;
  resizedUrl_gte?: Maybe<String>;
  resizedUrl_contains?: Maybe<String>;
  resizedUrl_not_contains?: Maybe<String>;
  resizedUrl_starts_with?: Maybe<String>;
  resizedUrl_not_starts_with?: Maybe<String>;
  resizedUrl_ends_with?: Maybe<String>;
  resizedUrl_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  OR?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  NOT?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface ProductFunctionUpsertWithWhereUniqueNestedInput {
  where: ProductFunctionWhereUniqueInput;
  update: ProductFunctionUpdateDataInput;
  create: ProductFunctionCreateInput;
}

export interface LabelUpdateManyMutationInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export interface ProductFunctionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
  OR?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
  NOT?: Maybe<
    ProductFunctionScalarWhereInput[] | ProductFunctionScalarWhereInput
  >;
}

export interface ImageUpdateInput {
  caption?: Maybe<String>;
  originalHeight?: Maybe<Int>;
  originalUrl?: Maybe<String>;
  originalWidth?: Maybe<Int>;
  resizedUrl?: Maybe<String>;
  title?: Maybe<String>;
}

export interface ProductFunctionUpdateManyWithWhereNestedInput {
  where: ProductFunctionScalarWhereInput;
  data: ProductFunctionUpdateManyDataInput;
}

export interface HomepageProductRailUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  products?: Maybe<ProductUpdateManyInput>;
}

export interface ProductFunctionUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface CustomerDetailUpdateInput {
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<String>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  averageWaistSize?: Maybe<String>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  shippingAddress?: Maybe<LocationUpdateOneInput>;
  phoneOS?: Maybe<String>;
}

export interface ProductUpdateavailableSizesInput {
  set?: Maybe<Size[] | Size>;
}

export interface ColorUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  colorCode?: Maybe<String>;
  hexCode?: Maybe<String>;
}

export interface ProductUpdateinnerMaterialsInput {
  set?: Maybe<Material[] | Material>;
}

export interface CollectionUpdateManyDataInput {
  slug?: Maybe<String>;
  images?: Maybe<Json>;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptionTop?: Maybe<String>;
  descriptionBottom?: Maybe<String>;
}

export interface ProductUpdateouterMaterialsInput {
  set?: Maybe<Material[] | Material>;
}

export interface CollectionUpsertWithWhereUniqueNestedInput {
  where: CollectionWhereUniqueInput;
  update: CollectionUpdateDataInput;
  create: CollectionCreateInput;
}

export interface ProductVariantUpdateManyWithoutProductInput {
  create?: Maybe<
    | ProductVariantCreateWithoutProductInput[]
    | ProductVariantCreateWithoutProductInput
  >;
  delete?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  connect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  set?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput
  >;
  update?: Maybe<
    | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    | ProductVariantUpdateWithWhereUniqueWithoutProductInput
  >;
  upsert?: Maybe<
    | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    | ProductVariantUpsertWithWhereUniqueWithoutProductInput
  >;
  deleteMany?: Maybe<
    ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductVariantUpdateManyWithWhereNestedInput[]
    | ProductVariantUpdateManyWithWhereNestedInput
  >;
}

export interface CollectionUpdateManyInput {
  create?: Maybe<CollectionCreateInput[] | CollectionCreateInput>;
  update?: Maybe<
    | CollectionUpdateWithWhereUniqueNestedInput[]
    | CollectionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CollectionUpsertWithWhereUniqueNestedInput[]
    | CollectionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CollectionWhereUniqueInput[] | CollectionWhereUniqueInput>;
  connect?: Maybe<CollectionWhereUniqueInput[] | CollectionWhereUniqueInput>;
  set?: Maybe<CollectionWhereUniqueInput[] | CollectionWhereUniqueInput>;
  disconnect?: Maybe<CollectionWhereUniqueInput[] | CollectionWhereUniqueInput>;
  deleteMany?: Maybe<CollectionScalarWhereInput[] | CollectionScalarWhereInput>;
  updateMany?: Maybe<
    | CollectionUpdateManyWithWhereNestedInput[]
    | CollectionUpdateManyWithWhereNestedInput
  >;
}

export interface ProductVariantUpdateWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput;
  data: ProductVariantUpdateWithoutProductDataInput;
}

export interface CollectionGroupCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  title?: Maybe<String>;
  collectionCount?: Maybe<Int>;
  collections?: Maybe<CollectionCreateManyInput>;
}

export interface ProductVariantUpdateWithoutProductDataInput {
  sku?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  size?: Maybe<Size>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
}

export interface ProductUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images?: Maybe<Json>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  availableSizes?: Maybe<ProductUpdateavailableSizesInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
  status?: Maybe<ProductStatus>;
}

export interface ProductVariantUpsertWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput;
  update: ProductVariantUpdateWithoutProductDataInput;
  create: ProductVariantCreateWithoutProductInput;
}

export interface CollectionUpdateInput {
  slug?: Maybe<String>;
  images?: Maybe<Json>;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptionTop?: Maybe<String>;
  descriptionBottom?: Maybe<String>;
  products?: Maybe<ProductUpdateManyInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCategoryDataInput;
  create: ProductCreateWithoutCategoryInput;
}

export interface CollectionCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  images: Json;
  title?: Maybe<String>;
  subTitle?: Maybe<String>;
  descriptionTop?: Maybe<String>;
  descriptionBottom?: Maybe<String>;
  products?: Maybe<ProductCreateManyInput>;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  externalURL?: Maybe<String>;
  externalURL_not?: Maybe<String>;
  externalURL_in?: Maybe<String[] | String>;
  externalURL_not_in?: Maybe<String[] | String>;
  externalURL_lt?: Maybe<String>;
  externalURL_lte?: Maybe<String>;
  externalURL_gt?: Maybe<String>;
  externalURL_gte?: Maybe<String>;
  externalURL_contains?: Maybe<String>;
  externalURL_not_contains?: Maybe<String>;
  externalURL_starts_with?: Maybe<String>;
  externalURL_not_starts_with?: Maybe<String>;
  externalURL_ends_with?: Maybe<String>;
  externalURL_not_ends_with?: Maybe<String>;
  modelHeight?: Maybe<Int>;
  modelHeight_not?: Maybe<Int>;
  modelHeight_in?: Maybe<Int[] | Int>;
  modelHeight_not_in?: Maybe<Int[] | Int>;
  modelHeight_lt?: Maybe<Int>;
  modelHeight_lte?: Maybe<Int>;
  modelHeight_gt?: Maybe<Int>;
  modelHeight_gte?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  modelSize_not?: Maybe<Size>;
  modelSize_in?: Maybe<Size[] | Size>;
  modelSize_not_in?: Maybe<Size[] | Size>;
  retailPrice?: Maybe<Int>;
  retailPrice_not?: Maybe<Int>;
  retailPrice_in?: Maybe<Int[] | Int>;
  retailPrice_not_in?: Maybe<Int[] | Int>;
  retailPrice_lt?: Maybe<Int>;
  retailPrice_lte?: Maybe<Int>;
  retailPrice_gt?: Maybe<Int>;
  retailPrice_gte?: Maybe<Int>;
  status?: Maybe<ProductStatus>;
  status_not?: Maybe<ProductStatus>;
  status_in?: Maybe<ProductStatus[] | ProductStatus>;
  status_not_in?: Maybe<ProductStatus[] | ProductStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
  products?: Maybe<ProductCreateManyWithoutCategoryInput>;
  children?: Maybe<CategoryCreateManyWithoutChildrenInput>;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductUpdateWithoutBrandDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images?: Maybe<Json>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  availableSizes?: Maybe<ProductUpdateavailableSizesInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
  status?: Maybe<ProductStatus>;
}

export interface ProductUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images?: Maybe<Json>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  tags?: Maybe<Json>;
  availableSizes?: Maybe<ProductUpdateavailableSizesInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  status?: Maybe<ProductStatus>;
}

export interface BagItemCreateInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneInput;
  productVariant: ProductVariantCreateOneInput;
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status: BagItemStatus;
}

export interface CategoryUpsertWithWhereUniqueWithoutChildrenInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutChildrenDataInput;
  create: CategoryCreateWithoutChildrenInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role?: Maybe<UserRole>;
}

export interface CategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  AND?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  OR?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  NOT?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface LocationCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  name: String;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1: String;
  address2?: Maybe<String>;
  city: String;
  state: String;
  zipCode: String;
  locationType?: Maybe<LocationType>;
  user?: Maybe<UserCreateOneInput>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductCreateManyWithoutLocationInput>;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface ProductVariantCreateWithoutPhysicalProductsInput {
  id?: Maybe<ID_Input>;
  sku?: Maybe<String>;
  color: ColorCreateOneWithoutProductVariantsInput;
  size: Size;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID: String;
  product: ProductCreateOneWithoutVariantsInput;
  retailPrice?: Maybe<Float>;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
}

export interface CategoryUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  image?: Maybe<Json>;
  description?: Maybe<String>;
  visible?: Maybe<Boolean>;
}

export interface ReservationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  customer?: Maybe<CustomerWhereInput>;
  sentPackage?: Maybe<PackageWhereInput>;
  returnedPackage?: Maybe<PackageWhereInput>;
  location?: Maybe<LocationWhereInput>;
  products_every?: Maybe<PhysicalProductWhereInput>;
  products_some?: Maybe<PhysicalProductWhereInput>;
  products_none?: Maybe<PhysicalProductWhereInput>;
  reservationNumber?: Maybe<Int>;
  reservationNumber_not?: Maybe<Int>;
  reservationNumber_in?: Maybe<Int[] | Int>;
  reservationNumber_not_in?: Maybe<Int[] | Int>;
  reservationNumber_lt?: Maybe<Int>;
  reservationNumber_lte?: Maybe<Int>;
  reservationNumber_gt?: Maybe<Int>;
  reservationNumber_gte?: Maybe<Int>;
  shipped?: Maybe<Boolean>;
  shipped_not?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  status_not?: Maybe<ReservationStatus>;
  status_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  status_not_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  shippedAt_not?: Maybe<DateTimeInput>;
  shippedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_lt?: Maybe<DateTimeInput>;
  shippedAt_lte?: Maybe<DateTimeInput>;
  shippedAt_gt?: Maybe<DateTimeInput>;
  shippedAt_gte?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  receivedAt_not?: Maybe<DateTimeInput>;
  receivedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_lt?: Maybe<DateTimeInput>;
  receivedAt_lte?: Maybe<DateTimeInput>;
  receivedAt_gt?: Maybe<DateTimeInput>;
  receivedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
  OR?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
  NOT?: Maybe<ReservationWhereInput[] | ReservationWhereInput>;
}

export interface CategoryUpsertWithoutProductsInput {
  update: CategoryUpdateWithoutProductsDataInput;
  create: CategoryCreateWithoutProductsInput;
}

export interface PackageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PackageWhereInput>;
  AND?: Maybe<PackageSubscriptionWhereInput[] | PackageSubscriptionWhereInput>;
  OR?: Maybe<PackageSubscriptionWhereInput[] | PackageSubscriptionWhereInput>;
  NOT?: Maybe<PackageSubscriptionWhereInput[] | PackageSubscriptionWhereInput>;
}

export interface ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput;
  create: ProductCreateWithoutVariantsInput;
}

export interface CustomerDetailSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerDetailWhereInput>;
  AND?: Maybe<
    | CustomerDetailSubscriptionWhereInput[]
    | CustomerDetailSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerDetailSubscriptionWhereInput[]
    | CustomerDetailSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerDetailSubscriptionWhereInput[]
    | CustomerDetailSubscriptionWhereInput
  >;
}

export interface ProductVariantUpsertWithoutPhysicalProductsInput {
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput;
  create: ProductVariantCreateWithoutPhysicalProductsInput;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  brand?: Maybe<BrandWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  externalURL?: Maybe<String>;
  externalURL_not?: Maybe<String>;
  externalURL_in?: Maybe<String[] | String>;
  externalURL_not_in?: Maybe<String[] | String>;
  externalURL_lt?: Maybe<String>;
  externalURL_lte?: Maybe<String>;
  externalURL_gt?: Maybe<String>;
  externalURL_gte?: Maybe<String>;
  externalURL_contains?: Maybe<String>;
  externalURL_not_contains?: Maybe<String>;
  externalURL_starts_with?: Maybe<String>;
  externalURL_not_starts_with?: Maybe<String>;
  externalURL_ends_with?: Maybe<String>;
  externalURL_not_ends_with?: Maybe<String>;
  modelHeight?: Maybe<Int>;
  modelHeight_not?: Maybe<Int>;
  modelHeight_in?: Maybe<Int[] | Int>;
  modelHeight_not_in?: Maybe<Int[] | Int>;
  modelHeight_lt?: Maybe<Int>;
  modelHeight_lte?: Maybe<Int>;
  modelHeight_gt?: Maybe<Int>;
  modelHeight_gte?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  modelSize_not?: Maybe<Size>;
  modelSize_in?: Maybe<Size[] | Size>;
  modelSize_not_in?: Maybe<Size[] | Size>;
  retailPrice?: Maybe<Int>;
  retailPrice_not?: Maybe<Int>;
  retailPrice_in?: Maybe<Int[] | Int>;
  retailPrice_not_in?: Maybe<Int[] | Int>;
  retailPrice_lt?: Maybe<Int>;
  retailPrice_lte?: Maybe<Int>;
  retailPrice_gt?: Maybe<Int>;
  retailPrice_gte?: Maybe<Int>;
  color?: Maybe<ColorWhereInput>;
  secondaryColor?: Maybe<ColorWhereInput>;
  functions_every?: Maybe<ProductFunctionWhereInput>;
  functions_some?: Maybe<ProductFunctionWhereInput>;
  functions_none?: Maybe<ProductFunctionWhereInput>;
  variants_every?: Maybe<ProductVariantWhereInput>;
  variants_some?: Maybe<ProductVariantWhereInput>;
  variants_none?: Maybe<ProductVariantWhereInput>;
  status?: Maybe<ProductStatus>;
  status_not?: Maybe<ProductStatus>;
  status_in?: Maybe<ProductStatus[] | ProductStatus>;
  status_not_in?: Maybe<ProductStatus[] | ProductStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface PhysicalProductUpsertWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput;
  update: PhysicalProductUpdateWithoutLocationDataInput;
  create: PhysicalProductCreateWithoutLocationInput;
}

export type CollectionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface ReservationUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneRequiredWithoutReservationsInput>;
  sentPackage?: Maybe<PackageUpdateOneInput>;
  returnedPackage?: Maybe<PackageUpdateOneInput>;
  location?: Maybe<LocationUpdateOneInput>;
  products?: Maybe<PhysicalProductUpdateManyInput>;
  reservationNumber?: Maybe<Int>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
}

export interface CustomerDetailUpsertNestedInput {
  update: CustomerDetailUpdateDataInput;
  create: CustomerDetailCreateInput;
}

export interface ProductVariantUpdateManyMutationInput {
  sku?: Maybe<String>;
  size?: Maybe<Size>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  retailPrice?: Maybe<Float>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
}

export interface BillingInfoUpdateOneInput {
  create?: Maybe<BillingInfoCreateInput>;
  update?: Maybe<BillingInfoUpdateDataInput>;
  upsert?: Maybe<BillingInfoUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BillingInfoWhereUniqueInput>;
}

export type CustomerDetailWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BillingInfoUpdateDataInput {
  brand?: Maybe<String>;
  name?: Maybe<String>;
  last_digits?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface ProductUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  brand?: Maybe<BrandUpdateOneRequiredWithoutProductsInput>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductsInput>;
  description?: Maybe<String>;
  externalURL?: Maybe<String>;
  images?: Maybe<Json>;
  modelHeight?: Maybe<Int>;
  modelSize?: Maybe<Size>;
  retailPrice?: Maybe<Int>;
  color?: Maybe<ColorUpdateOneRequiredInput>;
  secondaryColor?: Maybe<ColorUpdateOneInput>;
  tags?: Maybe<Json>;
  functions?: Maybe<ProductFunctionUpdateManyInput>;
  availableSizes?: Maybe<ProductUpdateavailableSizesInput>;
  innerMaterials?: Maybe<ProductUpdateinnerMaterialsInput>;
  outerMaterials?: Maybe<ProductUpdateouterMaterialsInput>;
  variants?: Maybe<ProductVariantUpdateManyWithoutProductInput>;
  status?: Maybe<ProductStatus>;
}

export interface BillingInfoUpsertNestedInput {
  update: BillingInfoUpdateDataInput;
  create: BillingInfoCreateInput;
}

export interface LocationUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<String>;
  description?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipCode?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
}

export interface ReservationUpdateManyWithoutCustomerInput {
  create?: Maybe<
    | ReservationCreateWithoutCustomerInput[]
    | ReservationCreateWithoutCustomerInput
  >;
  delete?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  connect?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  set?: Maybe<ReservationWhereUniqueInput[] | ReservationWhereUniqueInput>;
  disconnect?: Maybe<
    ReservationWhereUniqueInput[] | ReservationWhereUniqueInput
  >;
  update?: Maybe<
    | ReservationUpdateWithWhereUniqueWithoutCustomerInput[]
    | ReservationUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | ReservationUpsertWithWhereUniqueWithoutCustomerInput[]
    | ReservationUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<
    ReservationScalarWhereInput[] | ReservationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ReservationUpdateManyWithWhereNestedInput[]
    | ReservationUpdateManyWithWhereNestedInput
  >;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
}>;

export interface ReservationUpdateWithWhereUniqueWithoutCustomerInput {
  where: ReservationWhereUniqueInput;
  data: ReservationUpdateWithoutCustomerDataInput;
}

export interface CustomerUpdateManyMutationInput {
  status?: Maybe<CustomerStatus>;
  plan?: Maybe<Plan>;
}

export interface ReservationUpdateWithoutCustomerDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  sentPackage?: Maybe<PackageUpdateOneInput>;
  returnedPackage?: Maybe<PackageUpdateOneInput>;
  location?: Maybe<LocationUpdateOneInput>;
  products?: Maybe<PhysicalProductUpdateManyInput>;
  reservationNumber?: Maybe<Int>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
}

export interface CollectionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subTitle?: Maybe<String>;
  subTitle_not?: Maybe<String>;
  subTitle_in?: Maybe<String[] | String>;
  subTitle_not_in?: Maybe<String[] | String>;
  subTitle_lt?: Maybe<String>;
  subTitle_lte?: Maybe<String>;
  subTitle_gt?: Maybe<String>;
  subTitle_gte?: Maybe<String>;
  subTitle_contains?: Maybe<String>;
  subTitle_not_contains?: Maybe<String>;
  subTitle_starts_with?: Maybe<String>;
  subTitle_not_starts_with?: Maybe<String>;
  subTitle_ends_with?: Maybe<String>;
  subTitle_not_ends_with?: Maybe<String>;
  descriptionTop?: Maybe<String>;
  descriptionTop_not?: Maybe<String>;
  descriptionTop_in?: Maybe<String[] | String>;
  descriptionTop_not_in?: Maybe<String[] | String>;
  descriptionTop_lt?: Maybe<String>;
  descriptionTop_lte?: Maybe<String>;
  descriptionTop_gt?: Maybe<String>;
  descriptionTop_gte?: Maybe<String>;
  descriptionTop_contains?: Maybe<String>;
  descriptionTop_not_contains?: Maybe<String>;
  descriptionTop_starts_with?: Maybe<String>;
  descriptionTop_not_starts_with?: Maybe<String>;
  descriptionTop_ends_with?: Maybe<String>;
  descriptionTop_not_ends_with?: Maybe<String>;
  descriptionBottom?: Maybe<String>;
  descriptionBottom_not?: Maybe<String>;
  descriptionBottom_in?: Maybe<String[] | String>;
  descriptionBottom_not_in?: Maybe<String[] | String>;
  descriptionBottom_lt?: Maybe<String>;
  descriptionBottom_lte?: Maybe<String>;
  descriptionBottom_gt?: Maybe<String>;
  descriptionBottom_gte?: Maybe<String>;
  descriptionBottom_contains?: Maybe<String>;
  descriptionBottom_not_contains?: Maybe<String>;
  descriptionBottom_starts_with?: Maybe<String>;
  descriptionBottom_not_starts_with?: Maybe<String>;
  descriptionBottom_ends_with?: Maybe<String>;
  descriptionBottom_not_ends_with?: Maybe<String>;
  AND?: Maybe<CollectionScalarWhereInput[] | CollectionScalarWhereInput>;
  OR?: Maybe<CollectionScalarWhereInput[] | CollectionScalarWhereInput>;
  NOT?: Maybe<CollectionScalarWhereInput[] | CollectionScalarWhereInput>;
}

export interface PackageUpdateOneInput {
  create?: Maybe<PackageCreateInput>;
  update?: Maybe<PackageUpdateDataInput>;
  upsert?: Maybe<PackageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PackageWhereUniqueInput>;
}

export interface CollectionCreateManyInput {
  create?: Maybe<CollectionCreateInput[] | CollectionCreateInput>;
  connect?: Maybe<CollectionWhereUniqueInput[] | CollectionWhereUniqueInput>;
}

export interface PackageUpdateDataInput {
  items?: Maybe<PhysicalProductUpdateManyInput>;
  shippingLabel?: Maybe<LabelUpdateOneRequiredInput>;
  fromAddress?: Maybe<LocationUpdateOneRequiredInput>;
  toAddress?: Maybe<LocationUpdateOneRequiredInput>;
  weight?: Maybe<Float>;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface PhysicalProductUpdateManyInput {
  create?: Maybe<PhysicalProductCreateInput[] | PhysicalProductCreateInput>;
  update?: Maybe<
    | PhysicalProductUpdateWithWhereUniqueNestedInput[]
    | PhysicalProductUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PhysicalProductUpsertWithWhereUniqueNestedInput[]
    | PhysicalProductUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  connect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  set?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhysicalProductWhereUniqueInput[] | PhysicalProductWhereUniqueInput
  >;
  deleteMany?: Maybe<
    PhysicalProductScalarWhereInput[] | PhysicalProductScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhysicalProductUpdateManyWithWhereNestedInput[]
    | PhysicalProductUpdateManyWithWhereNestedInput
  >;
}

export type ReservationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  reservationNumber?: Maybe<Int>;
}>;

export interface PhysicalProductUpdateWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput;
  data: PhysicalProductUpdateDataInput;
}

export interface ProductUpdateManyWithoutBrandInput {
  create?: Maybe<
    ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    | ProductUpdateWithWhereUniqueWithoutBrandInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    | ProductUpsertWithWhereUniqueWithoutBrandInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface PhysicalProductUpdateDataInput {
  seasonsUID?: Maybe<String>;
  location?: Maybe<LocationUpdateOneRequiredWithoutPhysicalProductsInput>;
  productVariant?: Maybe<
    ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  >;
  inventoryStatus?: Maybe<InventoryStatus>;
  productStatus?: Maybe<PhysicalProductStatus>;
}

export interface CustomerDetailCreateInput {
  id?: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<String>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  averageWaistSize?: Maybe<String>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  shippingAddress?: Maybe<LocationCreateOneInput>;
  phoneOS?: Maybe<String>;
}

export interface PhysicalProductUpsertWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput;
  update: PhysicalProductUpdateDataInput;
  create: PhysicalProductCreateInput;
}

export interface ProductVariantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductVariantWhereInput>;
  AND?: Maybe<
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput
  >;
}

export interface LabelUpdateOneRequiredInput {
  create?: Maybe<LabelCreateInput>;
  update?: Maybe<LabelUpdateDataInput>;
  upsert?: Maybe<LabelUpsertNestedInput>;
  connect?: Maybe<LabelWhereUniqueInput>;
}

export interface BagItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  productVariant?: Maybe<ProductVariantWhereInput>;
  position?: Maybe<Int>;
  position_not?: Maybe<Int>;
  position_in?: Maybe<Int[] | Int>;
  position_not_in?: Maybe<Int[] | Int>;
  position_lt?: Maybe<Int>;
  position_lte?: Maybe<Int>;
  position_gt?: Maybe<Int>;
  position_gte?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  saved_not?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
  status_not?: Maybe<BagItemStatus>;
  status_in?: Maybe<BagItemStatus[] | BagItemStatus>;
  status_not_in?: Maybe<BagItemStatus[] | BagItemStatus>;
  AND?: Maybe<BagItemWhereInput[] | BagItemWhereInput>;
  OR?: Maybe<BagItemWhereInput[] | BagItemWhereInput>;
  NOT?: Maybe<BagItemWhereInput[] | BagItemWhereInput>;
}

export interface LabelUpdateDataInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
}>;

export interface LabelUpsertNestedInput {
  update: LabelUpdateDataInput;
  create: LabelCreateInput;
}

export interface CustomerCreateOneWithoutReservationsInput {
  create?: Maybe<CustomerCreateWithoutReservationsInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface LocationUpdateOneRequiredInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface ProductFunctionUpdateInput {
  name?: Maybe<String>;
}

export interface PackageUpsertNestedInput {
  update: PackageUpdateDataInput;
  create: PackageCreateInput;
}

export interface LabelUpdateInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  trackingNumber?: Maybe<String>;
  trackingURL?: Maybe<String>;
}

export interface ReservationUpsertWithWhereUniqueWithoutCustomerInput {
  where: ReservationWhereUniqueInput;
  update: ReservationUpdateWithoutCustomerDataInput;
  create: ReservationCreateWithoutCustomerInput;
}

export type PackageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ReservationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reservationNumber?: Maybe<Int>;
  reservationNumber_not?: Maybe<Int>;
  reservationNumber_in?: Maybe<Int[] | Int>;
  reservationNumber_not_in?: Maybe<Int[] | Int>;
  reservationNumber_lt?: Maybe<Int>;
  reservationNumber_lte?: Maybe<Int>;
  reservationNumber_gt?: Maybe<Int>;
  reservationNumber_gte?: Maybe<Int>;
  shipped?: Maybe<Boolean>;
  shipped_not?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  status_not?: Maybe<ReservationStatus>;
  status_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  status_not_in?: Maybe<ReservationStatus[] | ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  shippedAt_not?: Maybe<DateTimeInput>;
  shippedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  shippedAt_lt?: Maybe<DateTimeInput>;
  shippedAt_lte?: Maybe<DateTimeInput>;
  shippedAt_gt?: Maybe<DateTimeInput>;
  shippedAt_gte?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
  receivedAt_not?: Maybe<DateTimeInput>;
  receivedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receivedAt_lt?: Maybe<DateTimeInput>;
  receivedAt_lte?: Maybe<DateTimeInput>;
  receivedAt_gt?: Maybe<DateTimeInput>;
  receivedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
  OR?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
  NOT?: Maybe<ReservationScalarWhereInput[] | ReservationScalarWhereInput>;
}

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ReservationUpdateManyWithWhereNestedInput {
  where: ReservationScalarWhereInput;
  data: ReservationUpdateManyDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  auth0Id?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface ReservationUpdateManyDataInput {
  reservationNumber?: Maybe<Int>;
  shipped?: Maybe<Boolean>;
  status?: Maybe<ReservationStatus>;
  shippedAt?: Maybe<DateTimeInput>;
  receivedAt?: Maybe<DateTimeInput>;
}

export interface PhysicalProductCreateWithoutLocationInput {
  id?: Maybe<ID_Input>;
  seasonsUID: String;
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
}

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface ColorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ColorWhereInput>;
  AND?: Maybe<ColorSubscriptionWhereInput[] | ColorSubscriptionWhereInput>;
  OR?: Maybe<ColorSubscriptionWhereInput[] | ColorSubscriptionWhereInput>;
  NOT?: Maybe<ColorSubscriptionWhereInput[] | ColorSubscriptionWhereInput>;
}

export interface ProductVariantUpdateOneRequiredInput {
  create?: Maybe<ProductVariantCreateInput>;
  update?: Maybe<ProductVariantUpdateDataInput>;
  upsert?: Maybe<ProductVariantUpsertNestedInput>;
  connect?: Maybe<ProductVariantWhereUniqueInput>;
}

export interface LocationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  locationType?: Maybe<LocationType>;
  locationType_not?: Maybe<LocationType>;
  locationType_in?: Maybe<LocationType[] | LocationType>;
  locationType_not_in?: Maybe<LocationType[] | LocationType>;
  user?: Maybe<UserWhereInput>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  physicalProducts_every?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_some?: Maybe<PhysicalProductWhereInput>;
  physicalProducts_none?: Maybe<PhysicalProductWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  OR?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  NOT?: Maybe<LocationWhereInput[] | LocationWhereInput>;
}

export interface ProductVariantUpdateDataInput {
  sku?: Maybe<String>;
  color?: Maybe<ColorUpdateOneRequiredWithoutProductVariantsInput>;
  size?: Maybe<Size>;
  weight?: Maybe<Float>;
  height?: Maybe<Float>;
  productID?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredWithoutVariantsInput>;
  retailPrice?: Maybe<Float>;
  physicalProducts?: Maybe<PhysicalProductUpdateManyWithoutProductVariantInput>;
  total?: Maybe<Int>;
  reservable?: Maybe<Int>;
  reserved?: Maybe<Int>;
  nonReservable?: Maybe<Int>;
}

export interface CustomerDetailUpdateManyMutationInput {
  phoneNumber?: Maybe<String>;
  birthday?: Maybe<DateTimeInput>;
  height?: Maybe<Int>;
  weight?: Maybe<String>;
  bodyType?: Maybe<String>;
  averageTopSize?: Maybe<String>;
  averageWaistSize?: Maybe<String>;
  averagePantLength?: Maybe<String>;
  preferredPronouns?: Maybe<String>;
  profession?: Maybe<String>;
  partyFrequency?: Maybe<String>;
  travelFrequency?: Maybe<String>;
  shoppingFrequency?: Maybe<String>;
  averageSpend?: Maybe<String>;
  style?: Maybe<String>;
  commuteStyle?: Maybe<String>;
  phoneOS?: Maybe<String>;
}

export interface ProductVariantUpsertNestedInput {
  update: ProductVariantUpdateDataInput;
  create: ProductVariantCreateInput;
}

export type ProductVariantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  sku?: Maybe<String>;
}>;

export interface BillingInfoUpdateInput {
  brand?: Maybe<String>;
  name?: Maybe<String>;
  last_digits?: Maybe<String>;
  expiration_month?: Maybe<Int>;
  expiration_year?: Maybe<Int>;
  street1?: Maybe<String>;
  street2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postal_code?: Maybe<String>;
}

export interface BrandCreateInput {
  id?: Maybe<ID_Input>;
  slug: String;
  brandCode: String;
  description?: Maybe<String>;
  isPrimaryBrand?: Maybe<Boolean>;
  logo?: Maybe<Json>;
  name: String;
  basedIn?: Maybe<String>;
  products?: Maybe<ProductCreateManyWithoutBrandInput>;
  since?: Maybe<DateTimeInput>;
  tier: BrandTier;
  websiteUrl?: Maybe<String>;
}

export interface ProductCreateManyWithoutBrandInput {
  create?: Maybe<
    ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface BagItemUpdateManyMutationInput {
  position?: Maybe<Int>;
  saved?: Maybe<Boolean>;
  status?: Maybe<BagItemStatus>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  status?: Maybe<CustomerStatus>;
  detail?: Maybe<CustomerDetailCreateOneInput>;
  billingInfo?: Maybe<BillingInfoCreateOneInput>;
  plan?: Maybe<Plan>;
  reservations?: Maybe<ReservationCreateManyWithoutCustomerInput>;
}

export interface CollectionUpdateWithWhereUniqueNestedInput {
  where: CollectionWhereUniqueInput;
  data: CollectionUpdateDataInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CustomerUpsertWithoutReservationsInput {
  update: CustomerUpdateWithoutReservationsDataInput;
  create: CustomerCreateWithoutReservationsInput;
}

export interface PackageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  items_every?: Maybe<PhysicalProductWhereInput>;
  items_some?: Maybe<PhysicalProductWhereInput>;
  items_none?: Maybe<PhysicalProductWhereInput>;
  shippingLabel?: Maybe<LabelWhereInput>;
  fromAddress?: Maybe<LocationWhereInput>;
  toAddress?: Maybe<LocationWhereInput>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PackageWhereInput[] | PackageWhereInput>;
  OR?: Maybe<PackageWhereInput[] | PackageWhereInput>;
  NOT?: Maybe<PackageWhereInput[] | PackageWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  auth0Id: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  auth0Id: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CollectionGroup {
  id: ID_Output;
  slug: String;
  title?: String;
  collectionCount?: Int;
}

export interface CollectionGroupPromise
  extends Promise<CollectionGroup>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  title: () => Promise<String>;
  collectionCount: () => Promise<Int>;
  collections: <T = FragmentableArray<Collection>>(args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CollectionGroupSubscription
  extends Promise<AsyncIterator<CollectionGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  collectionCount: () => Promise<AsyncIterator<Int>>;
  collections: <T = Promise<AsyncIterator<CollectionSubscription>>>(args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CollectionGroupNullablePromise
  extends Promise<CollectionGroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  title: () => Promise<String>;
  collectionCount: () => Promise<Int>;
  collections: <T = FragmentableArray<Collection>>(args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductVariantSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariant;
  updatedFields: String[];
  previousValues: ProductVariantPreviousValues;
}

export interface ProductVariantSubscriptionPayloadPromise
  extends Promise<ProductVariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantPreviousValuesPromise>() => T;
}

export interface ProductVariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantPreviousValuesSubscription>() => T;
}

export interface AggregateCollection {
  count: Int;
}

export interface AggregateCollectionPromise
  extends Promise<AggregateCollection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionSubscription
  extends Promise<AsyncIterator<AggregateCollection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionConnection {
  pageInfo: PageInfo;
  edges: CollectionEdge[];
}

export interface CollectionConnectionPromise
  extends Promise<CollectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionEdge>>() => T;
  aggregate: <T = AggregateCollectionPromise>() => T;
}

export interface CollectionConnectionSubscription
  extends Promise<AsyncIterator<CollectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionSubscription>() => T;
}

export interface CollectionEdge {
  node: Collection;
  cursor: String;
}

export interface CollectionEdgePromise
  extends Promise<CollectionEdge>,
    Fragmentable {
  node: <T = CollectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionEdgeSubscription
  extends Promise<AsyncIterator<CollectionEdge>>,
    Fragmentable {
  node: <T = CollectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Collection {
  id: ID_Output;
  slug: String;
  images: Json;
  title?: String;
  subTitle?: String;
  descriptionTop?: String;
  descriptionBottom?: String;
}

export interface CollectionPromise extends Promise<Collection>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  images: () => Promise<Json>;
  title: () => Promise<String>;
  subTitle: () => Promise<String>;
  descriptionTop: () => Promise<String>;
  descriptionBottom: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CollectionSubscription
  extends Promise<AsyncIterator<Collection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<Json>>;
  title: () => Promise<AsyncIterator<String>>;
  subTitle: () => Promise<AsyncIterator<String>>;
  descriptionTop: () => Promise<AsyncIterator<String>>;
  descriptionBottom: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CollectionNullablePromise
  extends Promise<Collection | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  images: () => Promise<Json>;
  title: () => Promise<String>;
  subTitle: () => Promise<String>;
  descriptionTop: () => Promise<String>;
  descriptionBottom: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Customer {
  id: ID_Output;
  status?: CustomerStatus;
  plan?: Plan;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  status: () => Promise<CustomerStatus>;
  detail: <T = CustomerDetailPromise>() => T;
  billingInfo: <T = BillingInfoPromise>() => T;
  plan: () => Promise<Plan>;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<CustomerStatus>>;
  detail: <T = CustomerDetailSubscription>() => T;
  billingInfo: <T = BillingInfoSubscription>() => T;
  plan: () => Promise<AsyncIterator<Plan>>;
  reservations: <T = Promise<AsyncIterator<ReservationSubscription>>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  status: () => Promise<CustomerStatus>;
  detail: <T = CustomerDetailPromise>() => T;
  billingInfo: <T = BillingInfoPromise>() => T;
  plan: () => Promise<Plan>;
  reservations: <T = FragmentableArray<Reservation>>(args?: {
    where?: ReservationWhereInput;
    orderBy?: ReservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReservationEdge {
  node: Reservation;
  cursor: String;
}

export interface ReservationEdgePromise
  extends Promise<ReservationEdge>,
    Fragmentable {
  node: <T = ReservationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReservationEdgeSubscription
  extends Promise<AsyncIterator<ReservationEdge>>,
    Fragmentable {
  node: <T = ReservationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductVariant {
  count: Int;
}

export interface AggregateProductVariantPromise
  extends Promise<AggregateProductVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantSubscription
  extends Promise<AsyncIterator<AggregateProductVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface ProductVariantConnection {
  pageInfo: PageInfo;
  edges: ProductVariantEdge[];
}

export interface ProductVariantConnectionPromise
  extends Promise<ProductVariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantEdge>>() => T;
  aggregate: <T = AggregateProductVariantPromise>() => T;
}

export interface ProductVariantConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductVariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductVariantSubscription>() => T;
}

export interface BagItem {
  id: ID_Output;
  position?: Int;
  saved?: Boolean;
  status: BagItemStatus;
}

export interface BagItemPromise extends Promise<BagItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  position: () => Promise<Int>;
  saved: () => Promise<Boolean>;
  status: () => Promise<BagItemStatus>;
}

export interface BagItemSubscription
  extends Promise<AsyncIterator<BagItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  productVariant: <T = ProductVariantSubscription>() => T;
  position: () => Promise<AsyncIterator<Int>>;
  saved: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<BagItemStatus>>;
}

export interface BagItemNullablePromise
  extends Promise<BagItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  position: () => Promise<Int>;
  saved: () => Promise<Boolean>;
  status: () => Promise<BagItemStatus>;
}

export interface ProductRequestEdge {
  node: ProductRequest;
  cursor: String;
}

export interface ProductRequestEdgePromise
  extends Promise<ProductRequestEdge>,
    Fragmentable {
  node: <T = ProductRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductRequestEdgeSubscription
  extends Promise<AsyncIterator<ProductRequestEdge>>,
    Fragmentable {
  node: <T = ProductRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BagItemSubscriptionPayload {
  mutation: MutationType;
  node: BagItem;
  updatedFields: String[];
  previousValues: BagItemPreviousValues;
}

export interface BagItemSubscriptionPayloadPromise
  extends Promise<BagItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BagItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BagItemPreviousValuesPromise>() => T;
}

export interface BagItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BagItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BagItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BagItemPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  auth0Id: String;
  email: String;
  firstName: String;
  lastName: String;
  role: UserRole;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  auth0Id: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  auth0Id: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  auth0Id: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  role: () => Promise<UserRole>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BagItemPreviousValues {
  id: ID_Output;
  position?: Int;
  saved?: Boolean;
  status: BagItemStatus;
}

export interface BagItemPreviousValuesPromise
  extends Promise<BagItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  position: () => Promise<Int>;
  saved: () => Promise<Boolean>;
  status: () => Promise<BagItemStatus>;
}

export interface BagItemPreviousValuesSubscription
  extends Promise<AsyncIterator<BagItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  position: () => Promise<AsyncIterator<Int>>;
  saved: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<BagItemStatus>>;
}

export interface AggregateProductFunction {
  count: Int;
}

export interface AggregateProductFunctionPromise
  extends Promise<AggregateProductFunction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductFunctionSubscription
  extends Promise<AsyncIterator<AggregateProductFunction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBrand {
  count: Int;
}

export interface AggregateBrandPromise
  extends Promise<AggregateBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandSubscription
  extends Promise<AsyncIterator<AggregateBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductFunctionConnection {
  pageInfo: PageInfo;
  edges: ProductFunctionEdge[];
}

export interface ProductFunctionConnectionPromise
  extends Promise<ProductFunctionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductFunctionEdge>>() => T;
  aggregate: <T = AggregateProductFunctionPromise>() => T;
}

export interface ProductFunctionConnectionSubscription
  extends Promise<AsyncIterator<ProductFunctionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductFunctionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductFunctionSubscription>() => T;
}

export interface BillingInfoSubscriptionPayload {
  mutation: MutationType;
  node: BillingInfo;
  updatedFields: String[];
  previousValues: BillingInfoPreviousValues;
}

export interface BillingInfoSubscriptionPayloadPromise
  extends Promise<BillingInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BillingInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BillingInfoPreviousValuesPromise>() => T;
}

export interface BillingInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BillingInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BillingInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BillingInfoPreviousValuesSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BillingInfoPreviousValues {
  id: ID_Output;
  brand: String;
  name?: String;
  last_digits: String;
  expiration_month: Int;
  expiration_year: Int;
  street1?: String;
  street2?: String;
  city?: String;
  state?: String;
  country?: String;
  postal_code?: String;
}

export interface BillingInfoPreviousValuesPromise
  extends Promise<BillingInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  name: () => Promise<String>;
  last_digits: () => Promise<String>;
  expiration_month: () => Promise<Int>;
  expiration_year: () => Promise<Int>;
  street1: () => Promise<String>;
  street2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postal_code: () => Promise<String>;
}

export interface BillingInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<BillingInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  last_digits: () => Promise<AsyncIterator<String>>;
  expiration_month: () => Promise<AsyncIterator<Int>>;
  expiration_year: () => Promise<AsyncIterator<Int>>;
  street1: () => Promise<AsyncIterator<String>>;
  street2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  postal_code: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhysicalProduct {
  count: Int;
}

export interface AggregatePhysicalProductPromise
  extends Promise<AggregatePhysicalProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhysicalProductSubscription
  extends Promise<AsyncIterator<AggregatePhysicalProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandEdge {
  node: Brand;
  cursor: String;
}

export interface BrandEdgePromise extends Promise<BrandEdge>, Fragmentable {
  node: <T = BrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandEdgeSubscription
  extends Promise<AsyncIterator<BrandEdge>>,
    Fragmentable {
  node: <T = BrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PhysicalProductConnection {
  pageInfo: PageInfo;
  edges: PhysicalProductEdge[];
}

export interface PhysicalProductConnectionPromise
  extends Promise<PhysicalProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhysicalProductEdge>>() => T;
  aggregate: <T = AggregatePhysicalProductPromise>() => T;
}

export interface PhysicalProductConnectionSubscription
  extends Promise<AsyncIterator<PhysicalProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhysicalProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhysicalProductSubscription>() => T;
}

export interface BrandSubscriptionPayload {
  mutation: MutationType;
  node: Brand;
  updatedFields: String[];
  previousValues: BrandPreviousValues;
}

export interface BrandSubscriptionPayloadPromise
  extends Promise<BrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandPreviousValuesPromise>() => T;
}

export interface BrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandPreviousValuesSubscription>() => T;
}

export interface PackageEdge {
  node: Package;
  cursor: String;
}

export interface PackageEdgePromise extends Promise<PackageEdge>, Fragmentable {
  node: <T = PackagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PackageEdgeSubscription
  extends Promise<AsyncIterator<PackageEdge>>,
    Fragmentable {
  node: <T = PackageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BrandPreviousValues {
  id: ID_Output;
  slug: String;
  brandCode: String;
  description?: String;
  isPrimaryBrand: Boolean;
  logo?: Json;
  name: String;
  basedIn?: String;
  since?: DateTimeOutput;
  tier: BrandTier;
  websiteUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BrandPreviousValuesPromise
  extends Promise<BrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  brandCode: () => Promise<String>;
  description: () => Promise<String>;
  isPrimaryBrand: () => Promise<Boolean>;
  logo: () => Promise<Json>;
  name: () => Promise<String>;
  basedIn: () => Promise<String>;
  since: () => Promise<DateTimeOutput>;
  tier: () => Promise<BrandTier>;
  websiteUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BrandPreviousValuesSubscription
  extends Promise<AsyncIterator<BrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  brandCode: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isPrimaryBrand: () => Promise<AsyncIterator<Boolean>>;
  logo: () => Promise<AsyncIterator<Json>>;
  name: () => Promise<AsyncIterator<String>>;
  basedIn: () => Promise<AsyncIterator<String>>;
  since: () => Promise<AsyncIterator<DateTimeOutput>>;
  tier: () => Promise<AsyncIterator<BrandTier>>;
  websiteUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Brand {
  id: ID_Output;
  slug: String;
  brandCode: String;
  description?: String;
  isPrimaryBrand: Boolean;
  logo?: Json;
  name: String;
  basedIn?: String;
  since?: DateTimeOutput;
  tier: BrandTier;
  websiteUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BrandPromise extends Promise<Brand>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  brandCode: () => Promise<String>;
  description: () => Promise<String>;
  isPrimaryBrand: () => Promise<Boolean>;
  logo: () => Promise<Json>;
  name: () => Promise<String>;
  basedIn: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  since: () => Promise<DateTimeOutput>;
  tier: () => Promise<BrandTier>;
  websiteUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BrandSubscription
  extends Promise<AsyncIterator<Brand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  brandCode: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isPrimaryBrand: () => Promise<AsyncIterator<Boolean>>;
  logo: () => Promise<AsyncIterator<Json>>;
  name: () => Promise<AsyncIterator<String>>;
  basedIn: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  since: () => Promise<AsyncIterator<DateTimeOutput>>;
  tier: () => Promise<AsyncIterator<BrandTier>>;
  websiteUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BrandNullablePromise
  extends Promise<Brand | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  brandCode: () => Promise<String>;
  description: () => Promise<String>;
  isPrimaryBrand: () => Promise<Boolean>;
  logo: () => Promise<Json>;
  name: () => Promise<String>;
  basedIn: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  since: () => Promise<DateTimeOutput>;
  tier: () => Promise<BrandTier>;
  websiteUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BrandConnection {
  pageInfo: PageInfo;
  edges: BrandEdge[];
}

export interface BrandConnectionPromise
  extends Promise<BrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandEdge>>() => T;
  aggregate: <T = AggregateBrandPromise>() => T;
}

export interface BrandConnectionSubscription
  extends Promise<AsyncIterator<BrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface ReservationPreviousValues {
  id: ID_Output;
  reservationNumber: Int;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: DateTimeOutput;
  receivedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReservationPreviousValuesPromise
  extends Promise<ReservationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reservationNumber: () => Promise<Int>;
  shipped: () => Promise<Boolean>;
  status: () => Promise<ReservationStatus>;
  shippedAt: () => Promise<DateTimeOutput>;
  receivedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationPreviousValuesSubscription
  extends Promise<AsyncIterator<ReservationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reservationNumber: () => Promise<AsyncIterator<Int>>;
  shipped: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<ReservationStatus>>;
  shippedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  receivedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  image?: Json;
  description?: String;
  visible: Boolean;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<Json>;
  description: () => Promise<String>;
  visible: () => Promise<Boolean>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<Json>>;
  description: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBillingInfo {
  count: Int;
}

export interface AggregateBillingInfoPromise
  extends Promise<AggregateBillingInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBillingInfoSubscription
  extends Promise<AsyncIterator<AggregateBillingInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface CollectionSubscriptionPayload {
  mutation: MutationType;
  node: Collection;
  updatedFields: String[];
  previousValues: CollectionPreviousValues;
}

export interface CollectionSubscriptionPayloadPromise
  extends Promise<CollectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionPreviousValuesPromise>() => T;
}

export interface CollectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionPreviousValuesSubscription>() => T;
}

export interface AggregateLabel {
  count: Int;
}

export interface AggregateLabelPromise
  extends Promise<AggregateLabel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLabelSubscription
  extends Promise<AsyncIterator<AggregateLabel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionPreviousValues {
  id: ID_Output;
  slug: String;
  images: Json;
  title?: String;
  subTitle?: String;
  descriptionTop?: String;
  descriptionBottom?: String;
}

export interface CollectionPreviousValuesPromise
  extends Promise<CollectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  images: () => Promise<Json>;
  title: () => Promise<String>;
  subTitle: () => Promise<String>;
  descriptionTop: () => Promise<String>;
  descriptionBottom: () => Promise<String>;
}

export interface CollectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<Json>>;
  title: () => Promise<AsyncIterator<String>>;
  subTitle: () => Promise<AsyncIterator<String>>;
  descriptionTop: () => Promise<AsyncIterator<String>>;
  descriptionBottom: () => Promise<AsyncIterator<String>>;
}

export interface LabelConnection {
  pageInfo: PageInfo;
  edges: LabelEdge[];
}

export interface LabelConnectionPromise
  extends Promise<LabelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LabelEdge>>() => T;
  aggregate: <T = AggregateLabelPromise>() => T;
}

export interface LabelConnectionSubscription
  extends Promise<AsyncIterator<LabelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LabelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLabelSubscription>() => T;
}

export interface BillingInfoEdge {
  node: BillingInfo;
  cursor: String;
}

export interface BillingInfoEdgePromise
  extends Promise<BillingInfoEdge>,
    Fragmentable {
  node: <T = BillingInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BillingInfoEdgeSubscription
  extends Promise<AsyncIterator<BillingInfoEdge>>,
    Fragmentable {
  node: <T = BillingInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionGroupSubscriptionPayload {
  mutation: MutationType;
  node: CollectionGroup;
  updatedFields: String[];
  previousValues: CollectionGroupPreviousValues;
}

export interface CollectionGroupSubscriptionPayloadPromise
  extends Promise<CollectionGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionGroupPreviousValuesPromise>() => T;
}

export interface CollectionGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionGroupPreviousValuesSubscription>() => T;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface CollectionGroupPreviousValues {
  id: ID_Output;
  slug: String;
  title?: String;
  collectionCount?: Int;
}

export interface CollectionGroupPreviousValuesPromise
  extends Promise<CollectionGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  title: () => Promise<String>;
  collectionCount: () => Promise<Int>;
}

export interface CollectionGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  collectionCount: () => Promise<AsyncIterator<Int>>;
}

export interface Image {
  id: ID_Output;
  caption?: String;
  originalHeight?: Int;
  originalUrl: String;
  originalWidth?: Int;
  resizedUrl: String;
  title?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  originalHeight: () => Promise<Int>;
  originalUrl: () => Promise<String>;
  originalWidth: () => Promise<Int>;
  resizedUrl: () => Promise<String>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  originalHeight: () => Promise<AsyncIterator<Int>>;
  originalUrl: () => Promise<AsyncIterator<String>>;
  originalWidth: () => Promise<AsyncIterator<Int>>;
  resizedUrl: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  originalHeight: () => Promise<Int>;
  originalUrl: () => Promise<String>;
  originalWidth: () => Promise<Int>;
  resizedUrl: () => Promise<String>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BillingInfoConnection {
  pageInfo: PageInfo;
  edges: BillingInfoEdge[];
}

export interface BillingInfoConnectionPromise
  extends Promise<BillingInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BillingInfoEdge>>() => T;
  aggregate: <T = AggregateBillingInfoPromise>() => T;
}

export interface BillingInfoConnectionSubscription
  extends Promise<AsyncIterator<BillingInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BillingInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBillingInfoSubscription>() => T;
}

export interface HomepageProductRailEdge {
  node: HomepageProductRail;
  cursor: String;
}

export interface HomepageProductRailEdgePromise
  extends Promise<HomepageProductRailEdge>,
    Fragmentable {
  node: <T = HomepageProductRailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HomepageProductRailEdgeSubscription
  extends Promise<AsyncIterator<HomepageProductRailEdge>>,
    Fragmentable {
  node: <T = HomepageProductRailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ColorSubscriptionPayload {
  mutation: MutationType;
  node: Color;
  updatedFields: String[];
  previousValues: ColorPreviousValues;
}

export interface ColorSubscriptionPayloadPromise
  extends Promise<ColorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ColorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ColorPreviousValuesPromise>() => T;
}

export interface ColorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ColorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ColorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ColorPreviousValuesSubscription>() => T;
}

export interface Product {
  id: ID_Output;
  slug: String;
  name: String;
  description?: String;
  externalURL?: String;
  images: Json;
  modelHeight?: Int;
  modelSize?: Size;
  retailPrice?: Int;
  tags?: Json;
  availableSizes: Size[];
  innerMaterials: Material[];
  outerMaterials: Material[];
  status?: ProductStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  category: <T = CategoryPromise>() => T;
  description: () => Promise<String>;
  externalURL: () => Promise<String>;
  images: () => Promise<Json>;
  modelHeight: () => Promise<Int>;
  modelSize: () => Promise<Size>;
  retailPrice: () => Promise<Int>;
  color: <T = ColorPromise>() => T;
  secondaryColor: <T = ColorPromise>() => T;
  tags: () => Promise<Json>;
  functions: <T = FragmentableArray<ProductFunction>>(args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availableSizes: () => Promise<Size[]>;
  innerMaterials: () => Promise<Material[]>;
  outerMaterials: () => Promise<Material[]>;
  variants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<ProductStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: <T = BrandSubscription>() => T;
  category: <T = CategorySubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  externalURL: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<Json>>;
  modelHeight: () => Promise<AsyncIterator<Int>>;
  modelSize: () => Promise<AsyncIterator<Size>>;
  retailPrice: () => Promise<AsyncIterator<Int>>;
  color: <T = ColorSubscription>() => T;
  secondaryColor: <T = ColorSubscription>() => T;
  tags: () => Promise<AsyncIterator<Json>>;
  functions: <T = Promise<AsyncIterator<ProductFunctionSubscription>>>(args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availableSizes: () => Promise<AsyncIterator<Size[]>>;
  innerMaterials: () => Promise<AsyncIterator<Material[]>>;
  outerMaterials: () => Promise<AsyncIterator<Material[]>>;
  variants: <T = Promise<AsyncIterator<ProductVariantSubscription>>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<ProductStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  category: <T = CategoryPromise>() => T;
  description: () => Promise<String>;
  externalURL: () => Promise<String>;
  images: () => Promise<Json>;
  modelHeight: () => Promise<Int>;
  modelSize: () => Promise<Size>;
  retailPrice: () => Promise<Int>;
  color: <T = ColorPromise>() => T;
  secondaryColor: <T = ColorPromise>() => T;
  tags: () => Promise<Json>;
  functions: <T = FragmentableArray<ProductFunction>>(args?: {
    where?: ProductFunctionWhereInput;
    orderBy?: ProductFunctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availableSizes: () => Promise<Size[]>;
  innerMaterials: () => Promise<Material[]>;
  outerMaterials: () => Promise<Material[]>;
  variants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<ProductStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ColorPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
}

export interface ColorPreviousValuesPromise
  extends Promise<ColorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  colorCode: () => Promise<String>;
  hexCode: () => Promise<String>;
}

export interface ColorPreviousValuesSubscription
  extends Promise<AsyncIterator<ColorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  colorCode: () => Promise<AsyncIterator<String>>;
  hexCode: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerDetail {
  count: Int;
}

export interface AggregateCustomerDetailPromise
  extends Promise<AggregateCustomerDetail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerDetailSubscription
  extends Promise<AsyncIterator<AggregateCustomerDetail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBagItem {
  count: Int;
}

export interface AggregateBagItemPromise
  extends Promise<AggregateBagItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBagItemSubscription
  extends Promise<AsyncIterator<AggregateBagItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerDetailConnection {
  pageInfo: PageInfo;
  edges: CustomerDetailEdge[];
}

export interface CustomerDetailConnectionPromise
  extends Promise<CustomerDetailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerDetailEdge>>() => T;
  aggregate: <T = AggregateCustomerDetailPromise>() => T;
}

export interface CustomerDetailConnectionSubscription
  extends Promise<AsyncIterator<CustomerDetailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerDetailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerDetailSubscription>() => T;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  status?: CustomerStatus;
  plan?: Plan;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<CustomerStatus>;
  plan: () => Promise<Plan>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<CustomerStatus>>;
  plan: () => Promise<AsyncIterator<Plan>>;
}

export interface AggregateColor {
  count: Int;
}

export interface AggregateColorPromise
  extends Promise<AggregateColor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateColorSubscription
  extends Promise<AsyncIterator<AggregateColor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BagItemEdge {
  node: BagItem;
  cursor: String;
}

export interface BagItemEdgePromise extends Promise<BagItemEdge>, Fragmentable {
  node: <T = BagItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BagItemEdgeSubscription
  extends Promise<AsyncIterator<BagItemEdge>>,
    Fragmentable {
  node: <T = BagItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ColorConnection {
  pageInfo: PageInfo;
  edges: ColorEdge[];
}

export interface ColorConnectionPromise
  extends Promise<ColorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ColorEdge>>() => T;
  aggregate: <T = AggregateColorPromise>() => T;
}

export interface ColorConnectionSubscription
  extends Promise<AsyncIterator<ColorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ColorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateColorSubscription>() => T;
}

export interface CustomerDetailSubscriptionPayload {
  mutation: MutationType;
  node: CustomerDetail;
  updatedFields: String[];
  previousValues: CustomerDetailPreviousValues;
}

export interface CustomerDetailSubscriptionPayloadPromise
  extends Promise<CustomerDetailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerDetailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerDetailPreviousValuesPromise>() => T;
}

export interface CustomerDetailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerDetailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerDetailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerDetailPreviousValuesSubscription>() => T;
}

export interface CollectionGroupEdge {
  node: CollectionGroup;
  cursor: String;
}

export interface CollectionGroupEdgePromise
  extends Promise<CollectionGroupEdge>,
    Fragmentable {
  node: <T = CollectionGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionGroupEdgeSubscription
  extends Promise<AsyncIterator<CollectionGroupEdge>>,
    Fragmentable {
  node: <T = CollectionGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerDetailPreviousValues {
  id: ID_Output;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  height?: Int;
  weight?: String;
  bodyType?: String;
  averageTopSize?: String;
  averageWaistSize?: String;
  averagePantLength?: String;
  preferredPronouns?: String;
  profession?: String;
  partyFrequency?: String;
  travelFrequency?: String;
  shoppingFrequency?: String;
  averageSpend?: String;
  style?: String;
  commuteStyle?: String;
  phoneOS?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerDetailPreviousValuesPromise
  extends Promise<CustomerDetailPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  height: () => Promise<Int>;
  weight: () => Promise<String>;
  bodyType: () => Promise<String>;
  averageTopSize: () => Promise<String>;
  averageWaistSize: () => Promise<String>;
  averagePantLength: () => Promise<String>;
  preferredPronouns: () => Promise<String>;
  profession: () => Promise<String>;
  partyFrequency: () => Promise<String>;
  travelFrequency: () => Promise<String>;
  shoppingFrequency: () => Promise<String>;
  averageSpend: () => Promise<String>;
  style: () => Promise<String>;
  commuteStyle: () => Promise<String>;
  phoneOS: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerDetailPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerDetailPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  height: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<String>>;
  bodyType: () => Promise<AsyncIterator<String>>;
  averageTopSize: () => Promise<AsyncIterator<String>>;
  averageWaistSize: () => Promise<AsyncIterator<String>>;
  averagePantLength: () => Promise<AsyncIterator<String>>;
  preferredPronouns: () => Promise<AsyncIterator<String>>;
  profession: () => Promise<AsyncIterator<String>>;
  partyFrequency: () => Promise<AsyncIterator<String>>;
  travelFrequency: () => Promise<AsyncIterator<String>>;
  shoppingFrequency: () => Promise<AsyncIterator<String>>;
  averageSpend: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  commuteStyle: () => Promise<AsyncIterator<String>>;
  phoneOS: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Category {
  id: ID_Output;
  slug: String;
  name: String;
  image?: Json;
  description?: String;
  visible: Boolean;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<Json>;
  description: () => Promise<String>;
  visible: () => Promise<Boolean>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<Json>>;
  description: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  image: () => Promise<Json>;
  description: () => Promise<String>;
  visible: () => Promise<Boolean>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface HomepageProductRailSubscriptionPayload {
  mutation: MutationType;
  node: HomepageProductRail;
  updatedFields: String[];
  previousValues: HomepageProductRailPreviousValues;
}

export interface HomepageProductRailSubscriptionPayloadPromise
  extends Promise<HomepageProductRailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HomepageProductRailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HomepageProductRailPreviousValuesPromise>() => T;
}

export interface HomepageProductRailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HomepageProductRailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HomepageProductRailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HomepageProductRailPreviousValuesSubscription>() => T;
}

export interface ReservationConnection {
  pageInfo: PageInfo;
  edges: ReservationEdge[];
}

export interface ReservationConnectionPromise
  extends Promise<ReservationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReservationEdge>>() => T;
  aggregate: <T = AggregateReservationPromise>() => T;
}

export interface ReservationConnectionSubscription
  extends Promise<AsyncIterator<ReservationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReservationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReservationSubscription>() => T;
}

export interface HomepageProductRailPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
}

export interface HomepageProductRailPreviousValuesPromise
  extends Promise<HomepageProductRailPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
}

export interface HomepageProductRailPreviousValuesSubscription
  extends Promise<AsyncIterator<HomepageProductRailPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductRequest {
  count: Int;
}

export interface AggregateProductRequestPromise
  extends Promise<AggregateProductRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductRequestSubscription
  extends Promise<AsyncIterator<AggregateProductRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BagItemConnection {
  pageInfo: PageInfo;
  edges: BagItemEdge[];
}

export interface BagItemConnectionPromise
  extends Promise<BagItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BagItemEdge>>() => T;
  aggregate: <T = AggregateBagItemPromise>() => T;
}

export interface BagItemConnectionSubscription
  extends Promise<AsyncIterator<BagItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BagItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBagItemSubscription>() => T;
}

export interface ProductRequest {
  id: ID_Output;
  brand?: String;
  description?: String;
  images: String[];
  name?: String;
  price?: Int;
  priceCurrency?: String;
  productID?: String;
  reason: String;
  sku?: String;
  url: String;
}

export interface ProductRequestPromise
  extends Promise<ProductRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  images: () => Promise<String[]>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  priceCurrency: () => Promise<String>;
  productID: () => Promise<String>;
  reason: () => Promise<String>;
  sku: () => Promise<String>;
  url: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface ProductRequestSubscription
  extends Promise<AsyncIterator<ProductRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  priceCurrency: () => Promise<AsyncIterator<String>>;
  productID: () => Promise<AsyncIterator<String>>;
  reason: () => Promise<AsyncIterator<String>>;
  sku: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface ProductRequestNullablePromise
  extends Promise<ProductRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  images: () => Promise<String[]>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  priceCurrency: () => Promise<String>;
  productID: () => Promise<String>;
  reason: () => Promise<String>;
  sku: () => Promise<String>;
  url: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImagePreviousValues {
  id: ID_Output;
  caption?: String;
  originalHeight?: Int;
  originalUrl: String;
  originalWidth?: Int;
  resizedUrl: String;
  title?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  originalHeight: () => Promise<Int>;
  originalUrl: () => Promise<String>;
  originalWidth: () => Promise<Int>;
  resizedUrl: () => Promise<String>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  originalHeight: () => Promise<AsyncIterator<Int>>;
  originalUrl: () => Promise<AsyncIterator<String>>;
  originalWidth: () => Promise<AsyncIterator<Int>>;
  resizedUrl: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PhysicalProductEdge {
  node: PhysicalProduct;
  cursor: String;
}

export interface PhysicalProductEdgePromise
  extends Promise<PhysicalProductEdge>,
    Fragmentable {
  node: <T = PhysicalProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhysicalProductEdgeSubscription
  extends Promise<AsyncIterator<PhysicalProductEdge>>,
    Fragmentable {
  node: <T = PhysicalProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductVariantPreviousValues {
  id: ID_Output;
  sku?: String;
  size: Size;
  weight?: Float;
  height?: Float;
  productID: String;
  retailPrice?: Float;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductVariantPreviousValuesPromise
  extends Promise<ProductVariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sku: () => Promise<String>;
  size: () => Promise<Size>;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  productID: () => Promise<String>;
  retailPrice: () => Promise<Float>;
  total: () => Promise<Int>;
  reservable: () => Promise<Int>;
  reserved: () => Promise<Int>;
  nonReservable: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sku: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Size>>;
  weight: () => Promise<AsyncIterator<Float>>;
  height: () => Promise<AsyncIterator<Float>>;
  productID: () => Promise<AsyncIterator<String>>;
  retailPrice: () => Promise<AsyncIterator<Float>>;
  total: () => Promise<AsyncIterator<Int>>;
  reservable: () => Promise<AsyncIterator<Int>>;
  reserved: () => Promise<AsyncIterator<Int>>;
  nonReservable: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PackageConnection {
  pageInfo: PageInfo;
  edges: PackageEdge[];
}

export interface PackageConnectionPromise
  extends Promise<PackageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PackageEdge>>() => T;
  aggregate: <T = AggregatePackagePromise>() => T;
}

export interface PackageConnectionSubscription
  extends Promise<AsyncIterator<PackageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PackageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePackageSubscription>() => T;
}

export interface LabelSubscriptionPayload {
  mutation: MutationType;
  node: Label;
  updatedFields: String[];
  previousValues: LabelPreviousValues;
}

export interface LabelSubscriptionPayloadPromise
  extends Promise<LabelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LabelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LabelPreviousValuesPromise>() => T;
}

export interface LabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LabelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LabelPreviousValuesSubscription>() => T;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface LabelPreviousValues {
  id: ID_Output;
  name?: String;
  image?: String;
  trackingNumber?: String;
  trackingURL?: String;
}

export interface LabelPreviousValuesPromise
  extends Promise<LabelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  trackingNumber: () => Promise<String>;
  trackingURL: () => Promise<String>;
}

export interface LabelPreviousValuesSubscription
  extends Promise<AsyncIterator<LabelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  trackingNumber: () => Promise<AsyncIterator<String>>;
  trackingURL: () => Promise<AsyncIterator<String>>;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Label {
  id: ID_Output;
  name?: String;
  image?: String;
  trackingNumber?: String;
  trackingURL?: String;
}

export interface LabelPromise extends Promise<Label>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  trackingNumber: () => Promise<String>;
  trackingURL: () => Promise<String>;
}

export interface LabelSubscription
  extends Promise<AsyncIterator<Label>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  trackingNumber: () => Promise<AsyncIterator<String>>;
  trackingURL: () => Promise<AsyncIterator<String>>;
}

export interface LabelNullablePromise
  extends Promise<Label | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  trackingNumber: () => Promise<String>;
  trackingURL: () => Promise<String>;
}

export interface LabelEdge {
  node: Label;
  cursor: String;
}

export interface LabelEdgePromise extends Promise<LabelEdge>, Fragmentable {
  node: <T = LabelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LabelEdgeSubscription
  extends Promise<AsyncIterator<LabelEdge>>,
    Fragmentable {
  node: <T = LabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  company?: String;
  description?: String;
  address1: String;
  address2?: String;
  city: String;
  state: String;
  zipCode: String;
  locationType?: LocationType;
  lat?: Float;
  lng?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipCode: () => Promise<String>;
  locationType: () => Promise<LocationType>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  locationType: () => Promise<AsyncIterator<LocationType>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateHomepageProductRail {
  count: Int;
}

export interface AggregateHomepageProductRailPromise
  extends Promise<AggregateHomepageProductRail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHomepageProductRailSubscription
  extends Promise<AsyncIterator<AggregateHomepageProductRail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Package {
  id: ID_Output;
  weight?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PackagePromise extends Promise<Package>, Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shippingLabel: <T = LabelPromise>() => T;
  fromAddress: <T = LocationPromise>() => T;
  toAddress: <T = LocationPromise>() => T;
  weight: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PackageSubscription
  extends Promise<AsyncIterator<Package>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  items: <T = Promise<AsyncIterator<PhysicalProductSubscription>>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shippingLabel: <T = LabelSubscription>() => T;
  fromAddress: <T = LocationSubscription>() => T;
  toAddress: <T = LocationSubscription>() => T;
  weight: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PackageNullablePromise
  extends Promise<Package | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shippingLabel: <T = LabelPromise>() => T;
  fromAddress: <T = LocationPromise>() => T;
  toAddress: <T = LocationPromise>() => T;
  weight: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HomepageProductRail {
  id: ID_Output;
  slug: String;
  name: String;
}

export interface HomepageProductRailPromise
  extends Promise<HomepageProductRail>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface HomepageProductRailSubscription
  extends Promise<AsyncIterator<HomepageProductRail>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface HomepageProductRailNullablePromise
  extends Promise<HomepageProductRail | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderPreviousValues {
  id: ID_Output;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ColorEdge {
  node: Color;
  cursor: String;
}

export interface ColorEdgePromise extends Promise<ColorEdge>, Fragmentable {
  node: <T = ColorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ColorEdgeSubscription
  extends Promise<AsyncIterator<ColorEdge>>,
    Fragmentable {
  node: <T = ColorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Reservation {
  id: ID_Output;
  reservationNumber: Int;
  shipped: Boolean;
  status: ReservationStatus;
  shippedAt?: DateTimeOutput;
  receivedAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReservationPromise extends Promise<Reservation>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  sentPackage: <T = PackagePromise>() => T;
  returnedPackage: <T = PackagePromise>() => T;
  location: <T = LocationPromise>() => T;
  products: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationNumber: () => Promise<Int>;
  shipped: () => Promise<Boolean>;
  status: () => Promise<ReservationStatus>;
  shippedAt: () => Promise<DateTimeOutput>;
  receivedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReservationSubscription
  extends Promise<AsyncIterator<Reservation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  customer: <T = CustomerSubscription>() => T;
  sentPackage: <T = PackageSubscription>() => T;
  returnedPackage: <T = PackageSubscription>() => T;
  location: <T = LocationSubscription>() => T;
  products: <T = Promise<AsyncIterator<PhysicalProductSubscription>>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationNumber: () => Promise<AsyncIterator<Int>>;
  shipped: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<ReservationStatus>>;
  shippedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  receivedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReservationNullablePromise
  extends Promise<Reservation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  sentPackage: <T = PackagePromise>() => T;
  returnedPackage: <T = PackagePromise>() => T;
  location: <T = LocationPromise>() => T;
  products: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reservationNumber: () => Promise<Int>;
  shipped: () => Promise<Boolean>;
  status: () => Promise<ReservationStatus>;
  shippedAt: () => Promise<DateTimeOutput>;
  receivedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CollectionGroupConnection {
  pageInfo: PageInfo;
  edges: CollectionGroupEdge[];
}

export interface CollectionGroupConnectionPromise
  extends Promise<CollectionGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionGroupEdge>>() => T;
  aggregate: <T = AggregateCollectionGroupPromise>() => T;
}

export interface CollectionGroupConnectionSubscription
  extends Promise<AsyncIterator<CollectionGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionGroupSubscription>() => T;
}

export interface PackageSubscriptionPayload {
  mutation: MutationType;
  node: Package;
  updatedFields: String[];
  previousValues: PackagePreviousValues;
}

export interface PackageSubscriptionPayloadPromise
  extends Promise<PackageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PackagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PackagePreviousValuesPromise>() => T;
}

export interface PackageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PackageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PackageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PackagePreviousValuesSubscription>() => T;
}

export interface AggregateReservation {
  count: Int;
}

export interface AggregateReservationPromise
  extends Promise<AggregateReservation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReservationSubscription
  extends Promise<AsyncIterator<AggregateReservation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PackagePreviousValues {
  id: ID_Output;
  weight?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PackagePreviousValuesPromise
  extends Promise<PackagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PackagePreviousValuesSubscription
  extends Promise<AsyncIterator<PackagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductRequestConnection {
  pageInfo: PageInfo;
  edges: ProductRequestEdge[];
}

export interface ProductRequestConnectionPromise
  extends Promise<ProductRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductRequestEdge>>() => T;
  aggregate: <T = AggregateProductRequestPromise>() => T;
}

export interface ProductRequestConnectionSubscription
  extends Promise<AsyncIterator<ProductRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductRequestSubscription>() => T;
}

export interface PhysicalProduct {
  id: ID_Output;
  seasonsUID: String;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhysicalProductPromise
  extends Promise<PhysicalProduct>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seasonsUID: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  inventoryStatus: () => Promise<InventoryStatus>;
  productStatus: () => Promise<PhysicalProductStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProductSubscription
  extends Promise<AsyncIterator<PhysicalProduct>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seasonsUID: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  productVariant: <T = ProductVariantSubscription>() => T;
  inventoryStatus: () => Promise<AsyncIterator<InventoryStatus>>;
  productStatus: () => Promise<AsyncIterator<PhysicalProductStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PhysicalProductNullablePromise
  extends Promise<PhysicalProduct | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seasonsUID: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  inventoryStatus: () => Promise<InventoryStatus>;
  productStatus: () => Promise<PhysicalProductStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface PhysicalProductSubscriptionPayload {
  mutation: MutationType;
  node: PhysicalProduct;
  updatedFields: String[];
  previousValues: PhysicalProductPreviousValues;
}

export interface PhysicalProductSubscriptionPayloadPromise
  extends Promise<PhysicalProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhysicalProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhysicalProductPreviousValuesPromise>() => T;
}

export interface PhysicalProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhysicalProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhysicalProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhysicalProductPreviousValuesSubscription>() => T;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhysicalProductPreviousValues {
  id: ID_Output;
  seasonsUID: String;
  inventoryStatus: InventoryStatus;
  productStatus: PhysicalProductStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhysicalProductPreviousValuesPromise
  extends Promise<PhysicalProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seasonsUID: () => Promise<String>;
  inventoryStatus: () => Promise<InventoryStatus>;
  productStatus: () => Promise<PhysicalProductStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhysicalProductPreviousValuesSubscription
  extends Promise<AsyncIterator<PhysicalProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seasonsUID: () => Promise<AsyncIterator<String>>;
  inventoryStatus: () => Promise<AsyncIterator<InventoryStatus>>;
  productStatus: () => Promise<AsyncIterator<PhysicalProductStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerDetail {
  id: ID_Output;
  phoneNumber?: String;
  birthday?: DateTimeOutput;
  height?: Int;
  weight?: String;
  bodyType?: String;
  averageTopSize?: String;
  averageWaistSize?: String;
  averagePantLength?: String;
  preferredPronouns?: String;
  profession?: String;
  partyFrequency?: String;
  travelFrequency?: String;
  shoppingFrequency?: String;
  averageSpend?: String;
  style?: String;
  commuteStyle?: String;
  phoneOS?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerDetailPromise
  extends Promise<CustomerDetail>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  height: () => Promise<Int>;
  weight: () => Promise<String>;
  bodyType: () => Promise<String>;
  averageTopSize: () => Promise<String>;
  averageWaistSize: () => Promise<String>;
  averagePantLength: () => Promise<String>;
  preferredPronouns: () => Promise<String>;
  profession: () => Promise<String>;
  partyFrequency: () => Promise<String>;
  travelFrequency: () => Promise<String>;
  shoppingFrequency: () => Promise<String>;
  averageSpend: () => Promise<String>;
  style: () => Promise<String>;
  commuteStyle: () => Promise<String>;
  shippingAddress: <T = LocationPromise>() => T;
  phoneOS: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerDetailSubscription
  extends Promise<AsyncIterator<CustomerDetail>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  height: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<String>>;
  bodyType: () => Promise<AsyncIterator<String>>;
  averageTopSize: () => Promise<AsyncIterator<String>>;
  averageWaistSize: () => Promise<AsyncIterator<String>>;
  averagePantLength: () => Promise<AsyncIterator<String>>;
  preferredPronouns: () => Promise<AsyncIterator<String>>;
  profession: () => Promise<AsyncIterator<String>>;
  partyFrequency: () => Promise<AsyncIterator<String>>;
  travelFrequency: () => Promise<AsyncIterator<String>>;
  shoppingFrequency: () => Promise<AsyncIterator<String>>;
  averageSpend: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  commuteStyle: () => Promise<AsyncIterator<String>>;
  shippingAddress: <T = LocationSubscription>() => T;
  phoneOS: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerDetailNullablePromise
  extends Promise<CustomerDetail | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  height: () => Promise<Int>;
  weight: () => Promise<String>;
  bodyType: () => Promise<String>;
  averageTopSize: () => Promise<String>;
  averageWaistSize: () => Promise<String>;
  averagePantLength: () => Promise<String>;
  preferredPronouns: () => Promise<String>;
  profession: () => Promise<String>;
  partyFrequency: () => Promise<String>;
  travelFrequency: () => Promise<String>;
  shoppingFrequency: () => Promise<String>;
  averageSpend: () => Promise<String>;
  style: () => Promise<String>;
  commuteStyle: () => Promise<String>;
  shippingAddress: <T = LocationPromise>() => T;
  phoneOS: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariant {
  id: ID_Output;
  sku?: String;
  size: Size;
  weight?: Float;
  height?: Float;
  productID: String;
  retailPrice?: Float;
  total: Int;
  reservable: Int;
  reserved: Int;
  nonReservable: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductVariantPromise
  extends Promise<ProductVariant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sku: () => Promise<String>;
  color: <T = ColorPromise>() => T;
  size: () => Promise<Size>;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  productID: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  retailPrice: () => Promise<Float>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Int>;
  reservable: () => Promise<Int>;
  reserved: () => Promise<Int>;
  nonReservable: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantSubscription
  extends Promise<AsyncIterator<ProductVariant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sku: () => Promise<AsyncIterator<String>>;
  color: <T = ColorSubscription>() => T;
  size: () => Promise<AsyncIterator<Size>>;
  weight: () => Promise<AsyncIterator<Float>>;
  height: () => Promise<AsyncIterator<Float>>;
  productID: () => Promise<AsyncIterator<String>>;
  product: <T = ProductSubscription>() => T;
  retailPrice: () => Promise<AsyncIterator<Float>>;
  physicalProducts: <
    T = Promise<AsyncIterator<PhysicalProductSubscription>>
  >(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<AsyncIterator<Int>>;
  reservable: () => Promise<AsyncIterator<Int>>;
  reserved: () => Promise<AsyncIterator<Int>>;
  nonReservable: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductVariantNullablePromise
  extends Promise<ProductVariant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sku: () => Promise<String>;
  color: <T = ColorPromise>() => T;
  size: () => Promise<Size>;
  weight: () => Promise<Float>;
  height: () => Promise<Float>;
  productID: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  retailPrice: () => Promise<Float>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Int>;
  reservable: () => Promise<Int>;
  reserved: () => Promise<Int>;
  nonReservable: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Location {
  id: ID_Output;
  slug: String;
  name: String;
  company?: String;
  description?: String;
  address1: String;
  address2?: String;
  city: String;
  state: String;
  zipCode: String;
  locationType?: LocationType;
  lat?: Float;
  lng?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipCode: () => Promise<String>;
  locationType: () => Promise<LocationType>;
  user: <T = UserPromise>() => T;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  locationType: () => Promise<AsyncIterator<LocationType>>;
  user: <T = UserSubscription>() => T;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  physicalProducts: <
    T = Promise<AsyncIterator<PhysicalProductSubscription>>
  >(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LocationNullablePromise
  extends Promise<Location | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  company: () => Promise<String>;
  description: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipCode: () => Promise<String>;
  locationType: () => Promise<LocationType>;
  user: <T = UserPromise>() => T;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  physicalProducts: <T = FragmentableArray<PhysicalProduct>>(args?: {
    where?: PhysicalProductWhereInput;
    orderBy?: PhysicalProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface CustomerDetailEdge {
  node: CustomerDetail;
  cursor: String;
}

export interface CustomerDetailEdgePromise
  extends Promise<CustomerDetailEdge>,
    Fragmentable {
  node: <T = CustomerDetailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerDetailEdgeSubscription
  extends Promise<AsyncIterator<CustomerDetailEdge>>,
    Fragmentable {
  node: <T = CustomerDetailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  description?: String;
  externalURL?: String;
  images: Json;
  modelHeight?: Int;
  modelSize?: Size;
  retailPrice?: Int;
  tags?: Json;
  availableSizes: Size[];
  innerMaterials: Material[];
  outerMaterials: Material[];
  status?: ProductStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  externalURL: () => Promise<String>;
  images: () => Promise<Json>;
  modelHeight: () => Promise<Int>;
  modelSize: () => Promise<Size>;
  retailPrice: () => Promise<Int>;
  tags: () => Promise<Json>;
  availableSizes: () => Promise<Size[]>;
  innerMaterials: () => Promise<Material[]>;
  outerMaterials: () => Promise<Material[]>;
  status: () => Promise<ProductStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  externalURL: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<Json>>;
  modelHeight: () => Promise<AsyncIterator<Int>>;
  modelSize: () => Promise<AsyncIterator<Size>>;
  retailPrice: () => Promise<AsyncIterator<Int>>;
  tags: () => Promise<AsyncIterator<Json>>;
  availableSizes: () => Promise<AsyncIterator<Size[]>>;
  innerMaterials: () => Promise<AsyncIterator<Material[]>>;
  outerMaterials: () => Promise<AsyncIterator<Material[]>>;
  status: () => Promise<AsyncIterator<ProductStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCollectionGroup {
  count: Int;
}

export interface AggregateCollectionGroupPromise
  extends Promise<AggregateCollectionGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionGroupSubscription
  extends Promise<AsyncIterator<AggregateCollectionGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BillingInfo {
  id: ID_Output;
  brand: String;
  name?: String;
  last_digits: String;
  expiration_month: Int;
  expiration_year: Int;
  street1?: String;
  street2?: String;
  city?: String;
  state?: String;
  country?: String;
  postal_code?: String;
}

export interface BillingInfoPromise extends Promise<BillingInfo>, Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  name: () => Promise<String>;
  last_digits: () => Promise<String>;
  expiration_month: () => Promise<Int>;
  expiration_year: () => Promise<Int>;
  street1: () => Promise<String>;
  street2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postal_code: () => Promise<String>;
}

export interface BillingInfoSubscription
  extends Promise<AsyncIterator<BillingInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  last_digits: () => Promise<AsyncIterator<String>>;
  expiration_month: () => Promise<AsyncIterator<Int>>;
  expiration_year: () => Promise<AsyncIterator<Int>>;
  street1: () => Promise<AsyncIterator<String>>;
  street2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  postal_code: () => Promise<AsyncIterator<String>>;
}

export interface BillingInfoNullablePromise
  extends Promise<BillingInfo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  name: () => Promise<String>;
  last_digits: () => Promise<String>;
  expiration_month: () => Promise<Int>;
  expiration_year: () => Promise<Int>;
  street1: () => Promise<String>;
  street2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postal_code: () => Promise<String>;
}

export interface ProductVariantEdge {
  node: ProductVariant;
  cursor: String;
}

export interface ProductVariantEdgePromise
  extends Promise<ProductVariantEdge>,
    Fragmentable {
  node: <T = ProductVariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantEdge>>,
    Fragmentable {
  node: <T = ProductVariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductFunctionSubscriptionPayload {
  mutation: MutationType;
  node: ProductFunction;
  updatedFields: String[];
  previousValues: ProductFunctionPreviousValues;
}

export interface ProductFunctionSubscriptionPayloadPromise
  extends Promise<ProductFunctionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductFunctionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductFunctionPreviousValuesPromise>() => T;
}

export interface ProductFunctionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductFunctionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductFunctionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductFunctionPreviousValuesSubscription>() => T;
}

export interface AggregatePackage {
  count: Int;
}

export interface AggregatePackagePromise
  extends Promise<AggregatePackage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePackageSubscription
  extends Promise<AsyncIterator<AggregatePackage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductFunctionPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface ProductFunctionPreviousValuesPromise
  extends Promise<ProductFunctionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductFunctionPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductFunctionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ReservationSubscriptionPayload {
  mutation: MutationType;
  node: Reservation;
  updatedFields: String[];
  previousValues: ReservationPreviousValues;
}

export interface ReservationSubscriptionPayloadPromise
  extends Promise<ReservationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReservationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReservationPreviousValuesPromise>() => T;
}

export interface ReservationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReservationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReservationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReservationPreviousValuesSubscription>() => T;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface ProductFunction {
  id: ID_Output;
  name?: String;
}

export interface ProductFunctionPromise
  extends Promise<ProductFunction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductFunctionSubscription
  extends Promise<AsyncIterator<ProductFunction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductFunctionNullablePromise
  extends Promise<ProductFunction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductRequestPreviousValues {
  id: ID_Output;
  brand?: String;
  description?: String;
  images: String[];
  name?: String;
  price?: Int;
  priceCurrency?: String;
  productID?: String;
  reason: String;
  sku?: String;
  url: String;
}

export interface ProductRequestPreviousValuesPromise
  extends Promise<ProductRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  images: () => Promise<String[]>;
  name: () => Promise<String>;
  price: () => Promise<Int>;
  priceCurrency: () => Promise<String>;
  productID: () => Promise<String>;
  reason: () => Promise<String>;
  sku: () => Promise<String>;
  url: () => Promise<String>;
}

export interface ProductRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brand: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<String[]>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  priceCurrency: () => Promise<AsyncIterator<String>>;
  productID: () => Promise<AsyncIterator<String>>;
  reason: () => Promise<AsyncIterator<String>>;
  sku: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ProductRequestSubscriptionPayload {
  mutation: MutationType;
  node: ProductRequest;
  updatedFields: String[];
  previousValues: ProductRequestPreviousValues;
}

export interface ProductRequestSubscriptionPayloadPromise
  extends Promise<ProductRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductRequestPreviousValuesPromise>() => T;
}

export interface ProductRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductRequestPreviousValuesSubscription>() => T;
}

export interface Color {
  id: ID_Output;
  slug: String;
  name: String;
  colorCode: String;
  hexCode: String;
}

export interface ColorPromise extends Promise<Color>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  colorCode: () => Promise<String>;
  hexCode: () => Promise<String>;
  productVariants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ColorSubscription
  extends Promise<AsyncIterator<Color>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  colorCode: () => Promise<AsyncIterator<String>>;
  hexCode: () => Promise<AsyncIterator<String>>;
  productVariants: <
    T = Promise<AsyncIterator<ProductVariantSubscription>>
  >(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ColorNullablePromise
  extends Promise<Color | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  colorCode: () => Promise<String>;
  hexCode: () => Promise<String>;
  productVariants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HomepageProductRailConnection {
  pageInfo: PageInfo;
  edges: HomepageProductRailEdge[];
}

export interface HomepageProductRailConnectionPromise
  extends Promise<HomepageProductRailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HomepageProductRailEdge>>() => T;
  aggregate: <T = AggregateHomepageProductRailPromise>() => T;
}

export interface HomepageProductRailConnectionSubscription
  extends Promise<AsyncIterator<HomepageProductRailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<HomepageProductRailEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateHomepageProductRailSubscription>() => T;
}

export interface Order {
  id: ID_Output;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ProductFunctionEdge {
  node: ProductFunction;
  cursor: String;
}

export interface ProductFunctionEdgePromise
  extends Promise<ProductFunctionEdge>,
    Fragmentable {
  node: <T = ProductFunctionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductFunctionEdgeSubscription
  extends Promise<AsyncIterator<ProductFunctionEdge>>,
    Fragmentable {
  node: <T = ProductFunctionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Json = any;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "BrandTier",
    embedded: false
  },
  {
    name: "Size",
    embedded: false
  },
  {
    name: "Material",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "LocationType",
    embedded: false
  },
  {
    name: "CustomerStatus",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "InventoryStatus",
    embedded: false
  },
  {
    name: "PhysicalProductStatus",
    embedded: false
  },
  {
    name: "ProductStatus",
    embedded: false
  },
  {
    name: "ReservationStatus",
    embedded: false
  },
  {
    name: "BagItemStatus",
    embedded: false
  },
  {
    name: "Plan",
    embedded: false
  },
  {
    name: "Brand",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Color",
    embedded: false
  },
  {
    name: "Collection",
    embedded: false
  },
  {
    name: "CollectionGroup",
    embedded: false
  },
  {
    name: "HomepageProductRail",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductFunction",
    embedded: false
  },
  {
    name: "ProductVariant",
    embedded: false
  },
  {
    name: "PhysicalProduct",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "CustomerDetail",
    embedded: false
  },
  {
    name: "BagItem",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Reservation",
    embedded: false
  },
  {
    name: "Package",
    embedded: false
  },
  {
    name: "Label",
    embedded: false
  },
  {
    name: "BillingInfo",
    embedded: false
  },
  {
    name: "ProductRequest",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
