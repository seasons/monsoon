// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBag {
  count: Int!
}

type AggregateBrand {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateColor {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregatePhysicalProduct {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductVariant {
  count: Int!
}

type AggregateProductVariantInventoryLevel {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Bag {
  id: ID!
  items(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
  customer: Customer!
}

type BagConnection {
  pageInfo: PageInfo!
  edges: [BagEdge]!
  aggregate: AggregateBag!
}

input BagCreateInput {
  id: ID
  items: ProductVariantCreateManyInput
  customer: CustomerCreateOneWithoutBagInput!
}

input BagCreateOneWithoutCustomerInput {
  create: BagCreateWithoutCustomerInput
  connect: BagWhereUniqueInput
}

input BagCreateWithoutCustomerInput {
  id: ID
  items: ProductVariantCreateManyInput
}

type BagEdge {
  node: Bag!
  cursor: String!
}

enum BagOrderByInput {
  id_ASC
  id_DESC
}

type BagPreviousValues {
  id: ID!
}

type BagSubscriptionPayload {
  mutation: MutationType!
  node: Bag
  updatedFields: [String!]
  previousValues: BagPreviousValues
}

input BagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BagWhereInput
  AND: [BagSubscriptionWhereInput!]
  OR: [BagSubscriptionWhereInput!]
  NOT: [BagSubscriptionWhereInput!]
}

input BagUpdateInput {
  items: ProductVariantUpdateManyInput
  customer: CustomerUpdateOneRequiredWithoutBagInput
}

input BagUpdateOneRequiredWithoutCustomerInput {
  create: BagCreateWithoutCustomerInput
  update: BagUpdateWithoutCustomerDataInput
  upsert: BagUpsertWithoutCustomerInput
  connect: BagWhereUniqueInput
}

input BagUpdateWithoutCustomerDataInput {
  items: ProductVariantUpdateManyInput
}

input BagUpsertWithoutCustomerInput {
  update: BagUpdateWithoutCustomerDataInput!
  create: BagCreateWithoutCustomerInput!
}

input BagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  items_every: ProductVariantWhereInput
  items_some: ProductVariantWhereInput
  items_none: ProductVariantWhereInput
  customer: CustomerWhereInput
  AND: [BagWhereInput!]
  OR: [BagWhereInput!]
  NOT: [BagWhereInput!]
}

input BagWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Brand {
  id: ID!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  since: DateTime
  slug: String!
  tier: BrandTier!
  createdAt: DateTime!
  updatedAt: DateTime!
  websiteUrl: String
}

type BrandConnection {
  pageInfo: PageInfo!
  edges: [BrandEdge]!
  aggregate: AggregateBrand!
}

input BrandCreateInput {
  id: ID
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  products: ProductCreateManyWithoutBrandInput
  since: DateTime
  slug: String!
  tier: BrandTier!
  websiteUrl: String
}

input BrandCreateOneWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandCreateWithoutProductsInput {
  id: ID
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  since: DateTime
  slug: String!
  tier: BrandTier!
  websiteUrl: String
}

type BrandEdge {
  node: Brand!
  cursor: String!
}

enum BrandOrderByInput {
  id_ASC
  id_DESC
  brandCode_ASC
  brandCode_DESC
  description_ASC
  description_DESC
  isPrimaryBrand_ASC
  isPrimaryBrand_DESC
  logo_ASC
  logo_DESC
  name_ASC
  name_DESC
  since_ASC
  since_DESC
  slug_ASC
  slug_DESC
  tier_ASC
  tier_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  websiteUrl_ASC
  websiteUrl_DESC
}

type BrandPreviousValues {
  id: ID!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  since: DateTime
  slug: String!
  tier: BrandTier!
  createdAt: DateTime!
  updatedAt: DateTime!
  websiteUrl: String
}

type BrandSubscriptionPayload {
  mutation: MutationType!
  node: Brand
  updatedFields: [String!]
  previousValues: BrandPreviousValues
}

input BrandSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BrandWhereInput
  AND: [BrandSubscriptionWhereInput!]
  OR: [BrandSubscriptionWhereInput!]
  NOT: [BrandSubscriptionWhereInput!]
}

enum BrandTier {
  Tier0
  Tier1
  Tier2
  Niche
  Upcoming
  Retro
  Boutique
  Local
}

input BrandUpdateInput {
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  products: ProductUpdateManyWithoutBrandInput
  since: DateTime
  slug: String
  tier: BrandTier
  websiteUrl: String
}

input BrandUpdateManyMutationInput {
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  since: DateTime
  slug: String
  tier: BrandTier
  websiteUrl: String
}

input BrandUpdateOneRequiredWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  update: BrandUpdateWithoutProductsDataInput
  upsert: BrandUpsertWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandUpdateWithoutProductsDataInput {
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  since: DateTime
  slug: String
  tier: BrandTier
  websiteUrl: String
}

input BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput!
  create: BrandCreateWithoutProductsInput!
}

input BrandWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  brandCode: String
  brandCode_not: String
  brandCode_in: [String!]
  brandCode_not_in: [String!]
  brandCode_lt: String
  brandCode_lte: String
  brandCode_gt: String
  brandCode_gte: String
  brandCode_contains: String
  brandCode_not_contains: String
  brandCode_starts_with: String
  brandCode_not_starts_with: String
  brandCode_ends_with: String
  brandCode_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isPrimaryBrand: Boolean
  isPrimaryBrand_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  since: DateTime
  since_not: DateTime
  since_in: [DateTime!]
  since_not_in: [DateTime!]
  since_lt: DateTime
  since_lte: DateTime
  since_gt: DateTime
  since_gte: DateTime
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  tier: BrandTier
  tier_not: BrandTier
  tier_in: [BrandTier!]
  tier_not_in: [BrandTier!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  websiteUrl: String
  websiteUrl_not: String
  websiteUrl_in: [String!]
  websiteUrl_not_in: [String!]
  websiteUrl_lt: String
  websiteUrl_lte: String
  websiteUrl_gt: String
  websiteUrl_gte: String
  websiteUrl_contains: String
  websiteUrl_not_contains: String
  websiteUrl_starts_with: String
  websiteUrl_not_starts_with: String
  websiteUrl_ends_with: String
  websiteUrl_not_ends_with: String
  AND: [BrandWhereInput!]
  OR: [BrandWhereInput!]
  NOT: [BrandWhereInput!]
}

input BrandWhereUniqueInput {
  id: ID
  brandCode: String
  slug: String
}

type Category {
  id: ID!
  description: String
  name: String!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  description: String
  name: String!
  products: ProductCreateManyWithoutCategoryInput
}

input CategoryCreateOneWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutProductsInput {
  id: ID
  description: String
  name: String!
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
}

type CategoryPreviousValues {
  id: ID!
  description: String
  name: String!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateInput {
  description: String
  name: String
  products: ProductUpdateManyWithoutCategoryInput
}

input CategoryUpdateManyMutationInput {
  description: String
  name: String
}

input CategoryUpdateOneRequiredWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput
  update: CategoryUpdateWithoutProductsDataInput
  upsert: CategoryUpsertWithoutProductsInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutProductsDataInput {
  description: String
  name: String
}

input CategoryUpsertWithoutProductsInput {
  update: CategoryUpdateWithoutProductsDataInput!
  create: CategoryCreateWithoutProductsInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

type Color {
  id: ID!
  hexCode: String!
  name: String
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
}

type ColorConnection {
  pageInfo: PageInfo!
  edges: [ColorEdge]!
  aggregate: AggregateColor!
}

input ColorCreateInput {
  id: ID
  hexCode: String!
  name: String
  productVariants: ProductVariantCreateManyWithoutColorInput
}

input ColorCreateOneWithoutProductVariantsInput {
  create: ColorCreateWithoutProductVariantsInput
  connect: ColorWhereUniqueInput
}

input ColorCreateWithoutProductVariantsInput {
  id: ID
  hexCode: String!
  name: String
}

type ColorEdge {
  node: Color!
  cursor: String!
}

enum ColorOrderByInput {
  id_ASC
  id_DESC
  hexCode_ASC
  hexCode_DESC
  name_ASC
  name_DESC
}

type ColorPreviousValues {
  id: ID!
  hexCode: String!
  name: String
}

type ColorSubscriptionPayload {
  mutation: MutationType!
  node: Color
  updatedFields: [String!]
  previousValues: ColorPreviousValues
}

input ColorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ColorWhereInput
  AND: [ColorSubscriptionWhereInput!]
  OR: [ColorSubscriptionWhereInput!]
  NOT: [ColorSubscriptionWhereInput!]
}

input ColorUpdateInput {
  hexCode: String
  name: String
  productVariants: ProductVariantUpdateManyWithoutColorInput
}

input ColorUpdateManyMutationInput {
  hexCode: String
  name: String
}

input ColorUpdateOneRequiredWithoutProductVariantsInput {
  create: ColorCreateWithoutProductVariantsInput
  update: ColorUpdateWithoutProductVariantsDataInput
  upsert: ColorUpsertWithoutProductVariantsInput
  connect: ColorWhereUniqueInput
}

input ColorUpdateWithoutProductVariantsDataInput {
  hexCode: String
  name: String
}

input ColorUpsertWithoutProductVariantsInput {
  update: ColorUpdateWithoutProductVariantsDataInput!
  create: ColorCreateWithoutProductVariantsInput!
}

input ColorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hexCode: String
  hexCode_not: String
  hexCode_in: [String!]
  hexCode_not_in: [String!]
  hexCode_lt: String
  hexCode_lte: String
  hexCode_gt: String
  hexCode_gte: String
  hexCode_contains: String
  hexCode_not_contains: String
  hexCode_starts_with: String
  hexCode_not_starts_with: String
  hexCode_ends_with: String
  hexCode_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  productVariants_every: ProductVariantWhereInput
  productVariants_some: ProductVariantWhereInput
  productVariants_none: ProductVariantWhereInput
  AND: [ColorWhereInput!]
  OR: [ColorWhereInput!]
  NOT: [ColorWhereInput!]
}

input ColorWhereUniqueInput {
  id: ID
}

type Customer {
  id: ID!
  user: User!
  status: CustomerStatus
  bag: Bag!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  user: UserCreateOneInput!
  status: CustomerStatus
  bag: BagCreateOneWithoutCustomerInput!
}

input CustomerCreateOneWithoutBagInput {
  create: CustomerCreateWithoutBagInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutBagInput {
  id: ID
  user: UserCreateOneInput!
  status: CustomerStatus
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
}

type CustomerPreviousValues {
  id: ID!
  status: CustomerStatus
}

enum CustomerStatus {
  Invited
  Waitlisted
  Activated
  Suspended
  Deactivated
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  user: UserUpdateOneRequiredInput
  status: CustomerStatus
  bag: BagUpdateOneRequiredWithoutCustomerInput
}

input CustomerUpdateManyMutationInput {
  status: CustomerStatus
}

input CustomerUpdateOneRequiredWithoutBagInput {
  create: CustomerCreateWithoutBagInput
  update: CustomerUpdateWithoutBagDataInput
  upsert: CustomerUpsertWithoutBagInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutBagDataInput {
  user: UserUpdateOneRequiredInput
  status: CustomerStatus
}

input CustomerUpsertWithoutBagInput {
  update: CustomerUpdateWithoutBagDataInput!
  create: CustomerCreateWithoutBagInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  status: CustomerStatus
  status_not: CustomerStatus
  status_in: [CustomerStatus!]
  status_not_in: [CustomerStatus!]
  bag: BagWhereInput
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

type Image {
  id: ID!
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: ID
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  caption_ASC
  caption_DESC
  originalHeight_ASC
  originalHeight_DESC
  originalUrl_ASC
  originalUrl_DESC
  originalWidth_ASC
  originalWidth_DESC
  resizedUrl_ASC
  resizedUrl_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ImagePreviousValues {
  id: ID!
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateInput {
  caption: String
  originalHeight: Int
  originalUrl: String
  originalWidth: Int
  resizedUrl: String
  title: String
}

input ImageUpdateManyMutationInput {
  caption: String
  originalHeight: Int
  originalUrl: String
  originalWidth: Int
  resizedUrl: String
  title: String
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  originalHeight: Int
  originalHeight_not: Int
  originalHeight_in: [Int!]
  originalHeight_not_in: [Int!]
  originalHeight_lt: Int
  originalHeight_lte: Int
  originalHeight_gt: Int
  originalHeight_gte: Int
  originalUrl: String
  originalUrl_not: String
  originalUrl_in: [String!]
  originalUrl_not_in: [String!]
  originalUrl_lt: String
  originalUrl_lte: String
  originalUrl_gt: String
  originalUrl_gte: String
  originalUrl_contains: String
  originalUrl_not_contains: String
  originalUrl_starts_with: String
  originalUrl_not_starts_with: String
  originalUrl_ends_with: String
  originalUrl_not_ends_with: String
  originalWidth: Int
  originalWidth_not: Int
  originalWidth_in: [Int!]
  originalWidth_not_in: [Int!]
  originalWidth_lt: Int
  originalWidth_lte: Int
  originalWidth_gt: Int
  originalWidth_gte: Int
  resizedUrl: String
  resizedUrl_not: String
  resizedUrl_in: [String!]
  resizedUrl_not_in: [String!]
  resizedUrl_lt: String
  resizedUrl_lte: String
  resizedUrl_gt: String
  resizedUrl_gte: String
  resizedUrl_contains: String
  resizedUrl_not_contains: String
  resizedUrl_starts_with: String
  resizedUrl_not_starts_with: String
  resizedUrl_ends_with: String
  resizedUrl_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  id: ID!
  name: String
  description: String
  address1: String!
  address2: String!
  city: String!
  lat: Float
  lng: Float
  state: String!
  zip: Int!
  locationType: LocationType
  user: User
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  name: String
  description: String
  address1: String!
  address2: String!
  city: String!
  lat: Float
  lng: Float
  state: String!
  zip: Int!
  locationType: LocationType
  user: UserCreateOneInput
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  address1_ASC
  address1_DESC
  address2_ASC
  address2_DESC
  city_ASC
  city_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  state_ASC
  state_DESC
  zip_ASC
  zip_DESC
  locationType_ASC
  locationType_DESC
}

type LocationPreviousValues {
  id: ID!
  name: String
  description: String
  address1: String!
  address2: String!
  city: String!
  lat: Float
  lng: Float
  state: String!
  zip: Int!
  locationType: LocationType
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

enum LocationType {
  Office
  Warehouse
  Cleaner
  Customer
}

input LocationUpdateDataInput {
  name: String
  description: String
  address1: String
  address2: String
  city: String
  lat: Float
  lng: Float
  state: String
  zip: Int
  locationType: LocationType
  user: UserUpdateOneInput
}

input LocationUpdateInput {
  name: String
  description: String
  address1: String
  address2: String
  city: String
  lat: Float
  lng: Float
  state: String
  zip: Int
  locationType: LocationType
  user: UserUpdateOneInput
}

input LocationUpdateManyMutationInput {
  name: String
  description: String
  address1: String
  address2: String
  city: String
  lat: Float
  lng: Float
  state: String
  zip: Int
  locationType: LocationType
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  address1: String
  address1_not: String
  address1_in: [String!]
  address1_not_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_gt: String
  address1_gte: String
  address1_contains: String
  address1_not_contains: String
  address1_starts_with: String
  address1_not_starts_with: String
  address1_ends_with: String
  address1_not_ends_with: String
  address2: String
  address2_not: String
  address2_in: [String!]
  address2_not_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_gt: String
  address2_gte: String
  address2_contains: String
  address2_not_contains: String
  address2_starts_with: String
  address2_not_starts_with: String
  address2_ends_with: String
  address2_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: Int
  zip_not: Int
  zip_in: [Int!]
  zip_not_in: [Int!]
  zip_lt: Int
  zip_lte: Int
  zip_gt: Int
  zip_gte: Int
  locationType: LocationType
  locationType_not: LocationType
  locationType_in: [LocationType!]
  locationType_not_in: [LocationType!]
  user: UserWhereInput
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBag(data: BagCreateInput!): Bag!
  updateBag(data: BagUpdateInput!, where: BagWhereUniqueInput!): Bag
  upsertBag(where: BagWhereUniqueInput!, create: BagCreateInput!, update: BagUpdateInput!): Bag!
  deleteBag(where: BagWhereUniqueInput!): Bag
  deleteManyBags(where: BagWhereInput): BatchPayload!
  createBrand(data: BrandCreateInput!): Brand!
  updateBrand(data: BrandUpdateInput!, where: BrandWhereUniqueInput!): Brand
  updateManyBrands(data: BrandUpdateManyMutationInput!, where: BrandWhereInput): BatchPayload!
  upsertBrand(where: BrandWhereUniqueInput!, create: BrandCreateInput!, update: BrandUpdateInput!): Brand!
  deleteBrand(where: BrandWhereUniqueInput!): Brand
  deleteManyBrands(where: BrandWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createColor(data: ColorCreateInput!): Color!
  updateColor(data: ColorUpdateInput!, where: ColorWhereUniqueInput!): Color
  updateManyColors(data: ColorUpdateManyMutationInput!, where: ColorWhereInput): BatchPayload!
  upsertColor(where: ColorWhereUniqueInput!, create: ColorCreateInput!, update: ColorUpdateInput!): Color!
  deleteColor(where: ColorWhereUniqueInput!): Color
  deleteManyColors(where: ColorWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createPhysicalProduct(data: PhysicalProductCreateInput!): PhysicalProduct!
  updatePhysicalProduct(data: PhysicalProductUpdateInput!, where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  updateManyPhysicalProducts(data: PhysicalProductUpdateManyMutationInput!, where: PhysicalProductWhereInput): BatchPayload!
  upsertPhysicalProduct(where: PhysicalProductWhereUniqueInput!, create: PhysicalProductCreateInput!, update: PhysicalProductUpdateInput!): PhysicalProduct!
  deletePhysicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  deleteManyPhysicalProducts(where: PhysicalProductWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductVariant(data: ProductVariantCreateInput!): ProductVariant!
  updateProductVariant(data: ProductVariantUpdateInput!, where: ProductVariantWhereUniqueInput!): ProductVariant
  updateManyProductVariants(data: ProductVariantUpdateManyMutationInput!, where: ProductVariantWhereInput): BatchPayload!
  upsertProductVariant(where: ProductVariantWhereUniqueInput!, create: ProductVariantCreateInput!, update: ProductVariantUpdateInput!): ProductVariant!
  deleteProductVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  deleteManyProductVariants(where: ProductVariantWhereInput): BatchPayload!
  createProductVariantInventoryLevel(data: ProductVariantInventoryLevelCreateInput!): ProductVariantInventoryLevel!
  updateProductVariantInventoryLevel(data: ProductVariantInventoryLevelUpdateInput!, where: ProductVariantInventoryLevelWhereUniqueInput!): ProductVariantInventoryLevel
  updateManyProductVariantInventoryLevels(data: ProductVariantInventoryLevelUpdateManyMutationInput!, where: ProductVariantInventoryLevelWhereInput): BatchPayload!
  upsertProductVariantInventoryLevel(where: ProductVariantInventoryLevelWhereUniqueInput!, create: ProductVariantInventoryLevelCreateInput!, update: ProductVariantInventoryLevelUpdateInput!): ProductVariantInventoryLevel!
  deleteProductVariantInventoryLevel(where: ProductVariantInventoryLevelWhereUniqueInput!): ProductVariantInventoryLevel
  deleteManyProductVariantInventoryLevels(where: ProductVariantInventoryLevelWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PhysicalProduct {
  id: ID!
  seasonsUID: String!
  location: Location
  productVariant: ProductVariant
  inventoryLevel: ProductVariantInventoryLevel
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhysicalProductConnection {
  pageInfo: PageInfo!
  edges: [PhysicalProductEdge]!
  aggregate: AggregatePhysicalProduct!
}

input PhysicalProductCreateInput {
  id: ID
  seasonsUID: String!
  location: LocationCreateOneInput
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput
  inventoryLevel: ProductVariantInventoryLevelCreateOneInput
}

input PhysicalProductCreateManyWithoutProductVariantInput {
  create: [PhysicalProductCreateWithoutProductVariantInput!]
  connect: [PhysicalProductWhereUniqueInput!]
}

input PhysicalProductCreateWithoutProductVariantInput {
  id: ID
  seasonsUID: String!
  location: LocationCreateOneInput
  inventoryLevel: ProductVariantInventoryLevelCreateOneInput
}

type PhysicalProductEdge {
  node: PhysicalProduct!
  cursor: String!
}

enum PhysicalProductOrderByInput {
  id_ASC
  id_DESC
  seasonsUID_ASC
  seasonsUID_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhysicalProductPreviousValues {
  id: ID!
  seasonsUID: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PhysicalProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seasonsUID: String
  seasonsUID_not: String
  seasonsUID_in: [String!]
  seasonsUID_not_in: [String!]
  seasonsUID_lt: String
  seasonsUID_lte: String
  seasonsUID_gt: String
  seasonsUID_gte: String
  seasonsUID_contains: String
  seasonsUID_not_contains: String
  seasonsUID_starts_with: String
  seasonsUID_not_starts_with: String
  seasonsUID_ends_with: String
  seasonsUID_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhysicalProductScalarWhereInput!]
  OR: [PhysicalProductScalarWhereInput!]
  NOT: [PhysicalProductScalarWhereInput!]
}

type PhysicalProductSubscriptionPayload {
  mutation: MutationType!
  node: PhysicalProduct
  updatedFields: [String!]
  previousValues: PhysicalProductPreviousValues
}

input PhysicalProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhysicalProductWhereInput
  AND: [PhysicalProductSubscriptionWhereInput!]
  OR: [PhysicalProductSubscriptionWhereInput!]
  NOT: [PhysicalProductSubscriptionWhereInput!]
}

input PhysicalProductUpdateInput {
  seasonsUID: String
  location: LocationUpdateOneInput
  productVariant: ProductVariantUpdateOneWithoutPhysicalProductsInput
  inventoryLevel: ProductVariantInventoryLevelUpdateOneInput
}

input PhysicalProductUpdateManyDataInput {
  seasonsUID: String
}

input PhysicalProductUpdateManyMutationInput {
  seasonsUID: String
}

input PhysicalProductUpdateManyWithoutProductVariantInput {
  create: [PhysicalProductCreateWithoutProductVariantInput!]
  delete: [PhysicalProductWhereUniqueInput!]
  connect: [PhysicalProductWhereUniqueInput!]
  set: [PhysicalProductWhereUniqueInput!]
  disconnect: [PhysicalProductWhereUniqueInput!]
  update: [PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput!]
  upsert: [PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput!]
  deleteMany: [PhysicalProductScalarWhereInput!]
  updateMany: [PhysicalProductUpdateManyWithWhereNestedInput!]
}

input PhysicalProductUpdateManyWithWhereNestedInput {
  where: PhysicalProductScalarWhereInput!
  data: PhysicalProductUpdateManyDataInput!
}

input PhysicalProductUpdateWithoutProductVariantDataInput {
  seasonsUID: String
  location: LocationUpdateOneInput
  inventoryLevel: ProductVariantInventoryLevelUpdateOneInput
}

input PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput!
  data: PhysicalProductUpdateWithoutProductVariantDataInput!
}

input PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput!
  update: PhysicalProductUpdateWithoutProductVariantDataInput!
  create: PhysicalProductCreateWithoutProductVariantInput!
}

input PhysicalProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seasonsUID: String
  seasonsUID_not: String
  seasonsUID_in: [String!]
  seasonsUID_not_in: [String!]
  seasonsUID_lt: String
  seasonsUID_lte: String
  seasonsUID_gt: String
  seasonsUID_gte: String
  seasonsUID_contains: String
  seasonsUID_not_contains: String
  seasonsUID_starts_with: String
  seasonsUID_not_starts_with: String
  seasonsUID_ends_with: String
  seasonsUID_not_ends_with: String
  location: LocationWhereInput
  productVariant: ProductVariantWhereInput
  inventoryLevel: ProductVariantInventoryLevelWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhysicalProductWhereInput!]
  OR: [PhysicalProductWhereInput!]
  NOT: [PhysicalProductWhereInput!]
}

input PhysicalProductWhereUniqueInput {
  id: ID
  seasonsUID: String
}

type Product {
  id: ID!
  brand: Brand!
  category: Category!
  description: String
  externalUrl: String
  images: Json!
  modelHeight: Int
  modelSize: Int
  name: String!
  retailPrice: Int
  tags: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  brand: BrandCreateOneWithoutProductsInput!
  category: CategoryCreateOneWithoutProductsInput!
  description: String
  externalUrl: String
  images: Json!
  modelHeight: Int
  modelSize: Int
  name: String!
  retailPrice: Int
  tags: Json
}

input ProductCreateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutBrandInput {
  id: ID
  category: CategoryCreateOneWithoutProductsInput!
  description: String
  externalUrl: String
  images: Json!
  modelHeight: Int
  modelSize: Int
  name: String!
  retailPrice: Int
  tags: Json
}

input ProductCreateWithoutCategoryInput {
  id: ID
  brand: BrandCreateOneWithoutProductsInput!
  description: String
  externalUrl: String
  images: Json!
  modelHeight: Int
  modelSize: Int
  name: String!
  retailPrice: Int
  tags: Json
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  externalUrl_ASC
  externalUrl_DESC
  images_ASC
  images_DESC
  modelHeight_ASC
  modelHeight_DESC
  modelSize_ASC
  modelSize_DESC
  name_ASC
  name_DESC
  retailPrice_ASC
  retailPrice_DESC
  tags_ASC
  tags_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  description: String
  externalUrl: String
  images: Json!
  modelHeight: Int
  modelSize: Int
  name: String!
  retailPrice: Int
  tags: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  externalUrl: String
  externalUrl_not: String
  externalUrl_in: [String!]
  externalUrl_not_in: [String!]
  externalUrl_lt: String
  externalUrl_lte: String
  externalUrl_gt: String
  externalUrl_gte: String
  externalUrl_contains: String
  externalUrl_not_contains: String
  externalUrl_starts_with: String
  externalUrl_not_starts_with: String
  externalUrl_ends_with: String
  externalUrl_not_ends_with: String
  modelHeight: Int
  modelHeight_not: Int
  modelHeight_in: [Int!]
  modelHeight_not_in: [Int!]
  modelHeight_lt: Int
  modelHeight_lte: Int
  modelHeight_gt: Int
  modelHeight_gte: Int
  modelSize: Int
  modelSize_not: Int
  modelSize_in: [Int!]
  modelSize_not_in: [Int!]
  modelSize_lt: Int
  modelSize_lte: Int
  modelSize_gt: Int
  modelSize_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  brand: BrandUpdateOneRequiredWithoutProductsInput
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalUrl: String
  images: Json
  modelHeight: Int
  modelSize: Int
  name: String
  retailPrice: Int
  tags: Json
}

input ProductUpdateInput {
  brand: BrandUpdateOneRequiredWithoutProductsInput
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalUrl: String
  images: Json
  modelHeight: Int
  modelSize: Int
  name: String
  retailPrice: Int
  tags: Json
}

input ProductUpdateManyDataInput {
  description: String
  externalUrl: String
  images: Json
  modelHeight: Int
  modelSize: Int
  name: String
  retailPrice: Int
  tags: Json
}

input ProductUpdateManyMutationInput {
  description: String
  externalUrl: String
  images: Json
  modelHeight: Int
  modelSize: Int
  name: String
  retailPrice: Int
  tags: Json
}

input ProductUpdateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutBrandInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutBrandInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateWithoutBrandDataInput {
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalUrl: String
  images: Json
  modelHeight: Int
  modelSize: Int
  name: String
  retailPrice: Int
  tags: Json
}

input ProductUpdateWithoutCategoryDataInput {
  brand: BrandUpdateOneRequiredWithoutProductsInput
  description: String
  externalUrl: String
  images: Json
  modelHeight: Int
  modelSize: Int
  name: String
  retailPrice: Int
  tags: Json
}

input ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutBrandDataInput!
}

input ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCategoryDataInput!
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutBrandDataInput!
  create: ProductCreateWithoutBrandInput!
}

input ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCategoryDataInput!
  create: ProductCreateWithoutCategoryInput!
}

type ProductVariant {
  id: ID!
  sku: String
  upc: Int
  color: Color!
  weight: Int
  height: Int
  product: Product!
  retailPrice: Int
  images: Json
  inventoryLevels(where: ProductVariantInventoryLevelWhereInput, orderBy: ProductVariantInventoryLevelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariantInventoryLevel!]
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductVariantConnection {
  pageInfo: PageInfo!
  edges: [ProductVariantEdge]!
  aggregate: AggregateProductVariant!
}

input ProductVariantCreateInput {
  id: ID
  sku: String
  upc: Int
  color: ColorCreateOneWithoutProductVariantsInput!
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  images: Json
  inventoryLevels: ProductVariantInventoryLevelCreateManyWithoutProductVariantInput
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
}

input ProductVariantCreateManyInput {
  create: [ProductVariantCreateInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateManyWithoutColorInput {
  create: [ProductVariantCreateWithoutColorInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateOneWithoutInventoryLevelsInput {
  create: ProductVariantCreateWithoutInventoryLevelsInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantCreateOneWithoutPhysicalProductsInput {
  create: ProductVariantCreateWithoutPhysicalProductsInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantCreateWithoutColorInput {
  id: ID
  sku: String
  upc: Int
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  images: Json
  inventoryLevels: ProductVariantInventoryLevelCreateManyWithoutProductVariantInput
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
}

input ProductVariantCreateWithoutInventoryLevelsInput {
  id: ID
  sku: String
  upc: Int
  color: ColorCreateOneWithoutProductVariantsInput!
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  images: Json
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
}

input ProductVariantCreateWithoutPhysicalProductsInput {
  id: ID
  sku: String
  upc: Int
  color: ColorCreateOneWithoutProductVariantsInput!
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  images: Json
  inventoryLevels: ProductVariantInventoryLevelCreateManyWithoutProductVariantInput
}

type ProductVariantEdge {
  node: ProductVariant!
  cursor: String!
}

type ProductVariantInventoryLevel {
  id: ID!
  product: Product!
  productVariant: ProductVariant!
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

type ProductVariantInventoryLevelConnection {
  pageInfo: PageInfo!
  edges: [ProductVariantInventoryLevelEdge]!
  aggregate: AggregateProductVariantInventoryLevel!
}

input ProductVariantInventoryLevelCreateInput {
  id: ID
  product: ProductCreateOneInput!
  productVariant: ProductVariantCreateOneWithoutInventoryLevelsInput!
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

input ProductVariantInventoryLevelCreateManyWithoutProductVariantInput {
  create: [ProductVariantInventoryLevelCreateWithoutProductVariantInput!]
  connect: [ProductVariantInventoryLevelWhereUniqueInput!]
}

input ProductVariantInventoryLevelCreateOneInput {
  create: ProductVariantInventoryLevelCreateInput
  connect: ProductVariantInventoryLevelWhereUniqueInput
}

input ProductVariantInventoryLevelCreateWithoutProductVariantInput {
  id: ID
  product: ProductCreateOneInput!
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

type ProductVariantInventoryLevelEdge {
  node: ProductVariantInventoryLevel!
  cursor: String!
}

enum ProductVariantInventoryLevelOrderByInput {
  id_ASC
  id_DESC
  nonReservablePhysicalProducts_ASC
  nonReservablePhysicalProducts_DESC
  reservablePhysicalProducts_ASC
  reservablePhysicalProducts_DESC
  reservedPhysicalProducts_ASC
  reservedPhysicalProducts_DESC
}

type ProductVariantInventoryLevelPreviousValues {
  id: ID!
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

input ProductVariantInventoryLevelScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nonReservablePhysicalProducts: Int
  nonReservablePhysicalProducts_not: Int
  nonReservablePhysicalProducts_in: [Int!]
  nonReservablePhysicalProducts_not_in: [Int!]
  nonReservablePhysicalProducts_lt: Int
  nonReservablePhysicalProducts_lte: Int
  nonReservablePhysicalProducts_gt: Int
  nonReservablePhysicalProducts_gte: Int
  reservablePhysicalProducts: Int
  reservablePhysicalProducts_not: Int
  reservablePhysicalProducts_in: [Int!]
  reservablePhysicalProducts_not_in: [Int!]
  reservablePhysicalProducts_lt: Int
  reservablePhysicalProducts_lte: Int
  reservablePhysicalProducts_gt: Int
  reservablePhysicalProducts_gte: Int
  reservedPhysicalProducts: Int
  reservedPhysicalProducts_not: Int
  reservedPhysicalProducts_in: [Int!]
  reservedPhysicalProducts_not_in: [Int!]
  reservedPhysicalProducts_lt: Int
  reservedPhysicalProducts_lte: Int
  reservedPhysicalProducts_gt: Int
  reservedPhysicalProducts_gte: Int
  AND: [ProductVariantInventoryLevelScalarWhereInput!]
  OR: [ProductVariantInventoryLevelScalarWhereInput!]
  NOT: [ProductVariantInventoryLevelScalarWhereInput!]
}

type ProductVariantInventoryLevelSubscriptionPayload {
  mutation: MutationType!
  node: ProductVariantInventoryLevel
  updatedFields: [String!]
  previousValues: ProductVariantInventoryLevelPreviousValues
}

input ProductVariantInventoryLevelSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductVariantInventoryLevelWhereInput
  AND: [ProductVariantInventoryLevelSubscriptionWhereInput!]
  OR: [ProductVariantInventoryLevelSubscriptionWhereInput!]
  NOT: [ProductVariantInventoryLevelSubscriptionWhereInput!]
}

input ProductVariantInventoryLevelUpdateDataInput {
  product: ProductUpdateOneRequiredInput
  productVariant: ProductVariantUpdateOneRequiredWithoutInventoryLevelsInput
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

input ProductVariantInventoryLevelUpdateInput {
  product: ProductUpdateOneRequiredInput
  productVariant: ProductVariantUpdateOneRequiredWithoutInventoryLevelsInput
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

input ProductVariantInventoryLevelUpdateManyDataInput {
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

input ProductVariantInventoryLevelUpdateManyMutationInput {
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

input ProductVariantInventoryLevelUpdateManyWithoutProductVariantInput {
  create: [ProductVariantInventoryLevelCreateWithoutProductVariantInput!]
  delete: [ProductVariantInventoryLevelWhereUniqueInput!]
  connect: [ProductVariantInventoryLevelWhereUniqueInput!]
  set: [ProductVariantInventoryLevelWhereUniqueInput!]
  disconnect: [ProductVariantInventoryLevelWhereUniqueInput!]
  update: [ProductVariantInventoryLevelUpdateWithWhereUniqueWithoutProductVariantInput!]
  upsert: [ProductVariantInventoryLevelUpsertWithWhereUniqueWithoutProductVariantInput!]
  deleteMany: [ProductVariantInventoryLevelScalarWhereInput!]
  updateMany: [ProductVariantInventoryLevelUpdateManyWithWhereNestedInput!]
}

input ProductVariantInventoryLevelUpdateManyWithWhereNestedInput {
  where: ProductVariantInventoryLevelScalarWhereInput!
  data: ProductVariantInventoryLevelUpdateManyDataInput!
}

input ProductVariantInventoryLevelUpdateOneInput {
  create: ProductVariantInventoryLevelCreateInput
  update: ProductVariantInventoryLevelUpdateDataInput
  upsert: ProductVariantInventoryLevelUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductVariantInventoryLevelWhereUniqueInput
}

input ProductVariantInventoryLevelUpdateWithoutProductVariantDataInput {
  product: ProductUpdateOneRequiredInput
  nonReservablePhysicalProducts: Int
  reservablePhysicalProducts: Int
  reservedPhysicalProducts: Int
}

input ProductVariantInventoryLevelUpdateWithWhereUniqueWithoutProductVariantInput {
  where: ProductVariantInventoryLevelWhereUniqueInput!
  data: ProductVariantInventoryLevelUpdateWithoutProductVariantDataInput!
}

input ProductVariantInventoryLevelUpsertNestedInput {
  update: ProductVariantInventoryLevelUpdateDataInput!
  create: ProductVariantInventoryLevelCreateInput!
}

input ProductVariantInventoryLevelUpsertWithWhereUniqueWithoutProductVariantInput {
  where: ProductVariantInventoryLevelWhereUniqueInput!
  update: ProductVariantInventoryLevelUpdateWithoutProductVariantDataInput!
  create: ProductVariantInventoryLevelCreateWithoutProductVariantInput!
}

input ProductVariantInventoryLevelWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  productVariant: ProductVariantWhereInput
  nonReservablePhysicalProducts: Int
  nonReservablePhysicalProducts_not: Int
  nonReservablePhysicalProducts_in: [Int!]
  nonReservablePhysicalProducts_not_in: [Int!]
  nonReservablePhysicalProducts_lt: Int
  nonReservablePhysicalProducts_lte: Int
  nonReservablePhysicalProducts_gt: Int
  nonReservablePhysicalProducts_gte: Int
  reservablePhysicalProducts: Int
  reservablePhysicalProducts_not: Int
  reservablePhysicalProducts_in: [Int!]
  reservablePhysicalProducts_not_in: [Int!]
  reservablePhysicalProducts_lt: Int
  reservablePhysicalProducts_lte: Int
  reservablePhysicalProducts_gt: Int
  reservablePhysicalProducts_gte: Int
  reservedPhysicalProducts: Int
  reservedPhysicalProducts_not: Int
  reservedPhysicalProducts_in: [Int!]
  reservedPhysicalProducts_not_in: [Int!]
  reservedPhysicalProducts_lt: Int
  reservedPhysicalProducts_lte: Int
  reservedPhysicalProducts_gt: Int
  reservedPhysicalProducts_gte: Int
  AND: [ProductVariantInventoryLevelWhereInput!]
  OR: [ProductVariantInventoryLevelWhereInput!]
  NOT: [ProductVariantInventoryLevelWhereInput!]
}

input ProductVariantInventoryLevelWhereUniqueInput {
  id: ID
}

enum ProductVariantOrderByInput {
  id_ASC
  id_DESC
  sku_ASC
  sku_DESC
  upc_ASC
  upc_DESC
  weight_ASC
  weight_DESC
  height_ASC
  height_DESC
  retailPrice_ASC
  retailPrice_DESC
  images_ASC
  images_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductVariantPreviousValues {
  id: ID!
  sku: String
  upc: Int
  weight: Int
  height: Int
  retailPrice: Int
  images: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductVariantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  upc: Int
  upc_not: Int
  upc_in: [Int!]
  upc_not_in: [Int!]
  upc_lt: Int
  upc_lte: Int
  upc_gt: Int
  upc_gte: Int
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantScalarWhereInput!]
  OR: [ProductVariantScalarWhereInput!]
  NOT: [ProductVariantScalarWhereInput!]
}

type ProductVariantSubscriptionPayload {
  mutation: MutationType!
  node: ProductVariant
  updatedFields: [String!]
  previousValues: ProductVariantPreviousValues
}

input ProductVariantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductVariantWhereInput
  AND: [ProductVariantSubscriptionWhereInput!]
  OR: [ProductVariantSubscriptionWhereInput!]
  NOT: [ProductVariantSubscriptionWhereInput!]
}

input ProductVariantUpdateDataInput {
  sku: String
  upc: Int
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  images: Json
  inventoryLevels: ProductVariantInventoryLevelUpdateManyWithoutProductVariantInput
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateInput {
  sku: String
  upc: Int
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  images: Json
  inventoryLevels: ProductVariantInventoryLevelUpdateManyWithoutProductVariantInput
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateManyDataInput {
  sku: String
  upc: Int
  weight: Int
  height: Int
  retailPrice: Int
  images: Json
}

input ProductVariantUpdateManyInput {
  create: [ProductVariantCreateInput!]
  update: [ProductVariantUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueNestedInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyMutationInput {
  sku: String
  upc: Int
  weight: Int
  height: Int
  retailPrice: Int
  images: Json
}

input ProductVariantUpdateManyWithoutColorInput {
  create: [ProductVariantCreateWithoutColorInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  update: [ProductVariantUpdateWithWhereUniqueWithoutColorInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueWithoutColorInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyWithWhereNestedInput {
  where: ProductVariantScalarWhereInput!
  data: ProductVariantUpdateManyDataInput!
}

input ProductVariantUpdateOneRequiredWithoutInventoryLevelsInput {
  create: ProductVariantCreateWithoutInventoryLevelsInput
  update: ProductVariantUpdateWithoutInventoryLevelsDataInput
  upsert: ProductVariantUpsertWithoutInventoryLevelsInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantUpdateOneWithoutPhysicalProductsInput {
  create: ProductVariantCreateWithoutPhysicalProductsInput
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput
  upsert: ProductVariantUpsertWithoutPhysicalProductsInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantUpdateWithoutColorDataInput {
  sku: String
  upc: Int
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  images: Json
  inventoryLevels: ProductVariantInventoryLevelUpdateManyWithoutProductVariantInput
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateWithoutInventoryLevelsDataInput {
  sku: String
  upc: Int
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  images: Json
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateWithoutPhysicalProductsDataInput {
  sku: String
  upc: Int
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  images: Json
  inventoryLevels: ProductVariantInventoryLevelUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateWithWhereUniqueNestedInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateDataInput!
}

input ProductVariantUpdateWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateWithoutColorDataInput!
}

input ProductVariantUpsertWithoutInventoryLevelsInput {
  update: ProductVariantUpdateWithoutInventoryLevelsDataInput!
  create: ProductVariantCreateWithoutInventoryLevelsInput!
}

input ProductVariantUpsertWithoutPhysicalProductsInput {
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput!
  create: ProductVariantCreateWithoutPhysicalProductsInput!
}

input ProductVariantUpsertWithWhereUniqueNestedInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateDataInput!
  create: ProductVariantCreateInput!
}

input ProductVariantUpsertWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateWithoutColorDataInput!
  create: ProductVariantCreateWithoutColorInput!
}

input ProductVariantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  upc: Int
  upc_not: Int
  upc_in: [Int!]
  upc_not_in: [Int!]
  upc_lt: Int
  upc_lte: Int
  upc_gt: Int
  upc_gte: Int
  color: ColorWhereInput
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  product: ProductWhereInput
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  inventoryLevels_every: ProductVariantInventoryLevelWhereInput
  inventoryLevels_some: ProductVariantInventoryLevelWhereInput
  inventoryLevels_none: ProductVariantInventoryLevelWhereInput
  physicalProducts_every: PhysicalProductWhereInput
  physicalProducts_some: PhysicalProductWhereInput
  physicalProducts_none: PhysicalProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantWhereInput!]
  OR: [ProductVariantWhereInput!]
  NOT: [ProductVariantWhereInput!]
}

input ProductVariantWhereUniqueInput {
  id: ID
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  brand: BrandWhereInput
  category: CategoryWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  externalUrl: String
  externalUrl_not: String
  externalUrl_in: [String!]
  externalUrl_not_in: [String!]
  externalUrl_lt: String
  externalUrl_lte: String
  externalUrl_gt: String
  externalUrl_gte: String
  externalUrl_contains: String
  externalUrl_not_contains: String
  externalUrl_starts_with: String
  externalUrl_not_starts_with: String
  externalUrl_ends_with: String
  externalUrl_not_ends_with: String
  modelHeight: Int
  modelHeight_not: Int
  modelHeight_in: [Int!]
  modelHeight_not_in: [Int!]
  modelHeight_lt: Int
  modelHeight_lte: Int
  modelHeight_gt: Int
  modelHeight_gte: Int
  modelSize: Int
  modelSize_not: Int
  modelSize_in: [Int!]
  modelSize_not_in: [Int!]
  modelSize_lt: Int
  modelSize_lte: Int
  modelSize_gt: Int
  modelSize_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
  name: String
}

type Query {
  bag(where: BagWhereUniqueInput!): Bag
  bags(where: BagWhereInput, orderBy: BagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bag]!
  bagsConnection(where: BagWhereInput, orderBy: BagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BagConnection!
  brand(where: BrandWhereUniqueInput!): Brand
  brands(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Brand]!
  brandsConnection(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BrandConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  color(where: ColorWhereUniqueInput!): Color
  colors(where: ColorWhereInput, orderBy: ColorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Color]!
  colorsConnection(where: ColorWhereInput, orderBy: ColorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ColorConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  physicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct]!
  physicalProductsConnection(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhysicalProductConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant]!
  productVariantsConnection(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductVariantConnection!
  productVariantInventoryLevel(where: ProductVariantInventoryLevelWhereUniqueInput!): ProductVariantInventoryLevel
  productVariantInventoryLevels(where: ProductVariantInventoryLevelWhereInput, orderBy: ProductVariantInventoryLevelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariantInventoryLevel]!
  productVariantInventoryLevelsConnection(where: ProductVariantInventoryLevelWhereInput, orderBy: ProductVariantInventoryLevelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductVariantInventoryLevelConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  bag(where: BagSubscriptionWhereInput): BagSubscriptionPayload
  brand(where: BrandSubscriptionWhereInput): BrandSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  color(where: ColorSubscriptionWhereInput): ColorSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  physicalProduct(where: PhysicalProductSubscriptionWhereInput): PhysicalProductSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productVariant(where: ProductVariantSubscriptionWhereInput): ProductVariantSubscriptionPayload
  productVariantInventoryLevel(where: ProductVariantInventoryLevelSubscriptionWhereInput): ProductVariantInventoryLevelSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  role: UserRole!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  role: UserRole
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  role: UserRole!
}

enum UserRole {
  Admin
  Customer
  Partner
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  firstName: String
  lastName: String
  password: String
  role: UserRole
}

input UserUpdateInput {
  email: String
  firstName: String
  lastName: String
  password: String
  role: UserRole
}

input UserUpdateManyMutationInput {
  email: String
  firstName: String
  lastName: String
  password: String
  role: UserRole
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`