// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBagItem {
  count: Int!
}

type AggregateBillingInfo {
  count: Int!
}

type AggregateBrand {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateCollection {
  count: Int!
}

type AggregateCollectionGroup {
  count: Int!
}

type AggregateColor {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateCustomerDetail {
  count: Int!
}

type AggregateHomepageProductRail {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateLabel {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePackage {
  count: Int!
}

type AggregatePhysicalProduct {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductFunction {
  count: Int!
}

type AggregateProductVariant {
  count: Int!
}

type AggregateReservation {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BagItem {
  id: ID!
  customer: Customer!
  productVariant: ProductVariant!
  position: Int
  saved: Boolean
}

type BagItemConnection {
  pageInfo: PageInfo!
  edges: [BagItemEdge]!
  aggregate: AggregateBagItem!
}

input BagItemCreateInput {
  id: ID
  customer: CustomerCreateOneInput!
  productVariant: ProductVariantCreateOneInput!
  position: Int
  saved: Boolean
}

type BagItemEdge {
  node: BagItem!
  cursor: String!
}

enum BagItemOrderByInput {
  id_ASC
  id_DESC
  position_ASC
  position_DESC
  saved_ASC
  saved_DESC
}

type BagItemPreviousValues {
  id: ID!
  position: Int
  saved: Boolean
}

type BagItemSubscriptionPayload {
  mutation: MutationType!
  node: BagItem
  updatedFields: [String!]
  previousValues: BagItemPreviousValues
}

input BagItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BagItemWhereInput
  AND: [BagItemSubscriptionWhereInput!]
  OR: [BagItemSubscriptionWhereInput!]
  NOT: [BagItemSubscriptionWhereInput!]
}

input BagItemUpdateInput {
  customer: CustomerUpdateOneRequiredInput
  productVariant: ProductVariantUpdateOneRequiredInput
  position: Int
  saved: Boolean
}

input BagItemUpdateManyMutationInput {
  position: Int
  saved: Boolean
}

input BagItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customer: CustomerWhereInput
  productVariant: ProductVariantWhereInput
  position: Int
  position_not: Int
  position_in: [Int!]
  position_not_in: [Int!]
  position_lt: Int
  position_lte: Int
  position_gt: Int
  position_gte: Int
  saved: Boolean
  saved_not: Boolean
  AND: [BagItemWhereInput!]
  OR: [BagItemWhereInput!]
  NOT: [BagItemWhereInput!]
}

input BagItemWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type BillingInfo {
  id: ID!
  brand: String!
  name: String
  last_digits: String!
  expiration_month: Int!
  expiration_year: Int!
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
}

type BillingInfoConnection {
  pageInfo: PageInfo!
  edges: [BillingInfoEdge]!
  aggregate: AggregateBillingInfo!
}

input BillingInfoCreateInput {
  id: ID
  brand: String!
  name: String
  last_digits: String!
  expiration_month: Int!
  expiration_year: Int!
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
}

input BillingInfoCreateOneInput {
  create: BillingInfoCreateInput
  connect: BillingInfoWhereUniqueInput
}

type BillingInfoEdge {
  node: BillingInfo!
  cursor: String!
}

enum BillingInfoOrderByInput {
  id_ASC
  id_DESC
  brand_ASC
  brand_DESC
  name_ASC
  name_DESC
  last_digits_ASC
  last_digits_DESC
  expiration_month_ASC
  expiration_month_DESC
  expiration_year_ASC
  expiration_year_DESC
  street1_ASC
  street1_DESC
  street2_ASC
  street2_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  country_ASC
  country_DESC
  postal_code_ASC
  postal_code_DESC
}

type BillingInfoPreviousValues {
  id: ID!
  brand: String!
  name: String
  last_digits: String!
  expiration_month: Int!
  expiration_year: Int!
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
}

type BillingInfoSubscriptionPayload {
  mutation: MutationType!
  node: BillingInfo
  updatedFields: [String!]
  previousValues: BillingInfoPreviousValues
}

input BillingInfoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BillingInfoWhereInput
  AND: [BillingInfoSubscriptionWhereInput!]
  OR: [BillingInfoSubscriptionWhereInput!]
  NOT: [BillingInfoSubscriptionWhereInput!]
}

input BillingInfoUpdateDataInput {
  brand: String
  name: String
  last_digits: String
  expiration_month: Int
  expiration_year: Int
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
}

input BillingInfoUpdateInput {
  brand: String
  name: String
  last_digits: String
  expiration_month: Int
  expiration_year: Int
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
}

input BillingInfoUpdateManyMutationInput {
  brand: String
  name: String
  last_digits: String
  expiration_month: Int
  expiration_year: Int
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postal_code: String
}

input BillingInfoUpdateOneInput {
  create: BillingInfoCreateInput
  update: BillingInfoUpdateDataInput
  upsert: BillingInfoUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BillingInfoWhereUniqueInput
}

input BillingInfoUpsertNestedInput {
  update: BillingInfoUpdateDataInput!
  create: BillingInfoCreateInput!
}

input BillingInfoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  brand: String
  brand_not: String
  brand_in: [String!]
  brand_not_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_gt: String
  brand_gte: String
  brand_contains: String
  brand_not_contains: String
  brand_starts_with: String
  brand_not_starts_with: String
  brand_ends_with: String
  brand_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  last_digits: String
  last_digits_not: String
  last_digits_in: [String!]
  last_digits_not_in: [String!]
  last_digits_lt: String
  last_digits_lte: String
  last_digits_gt: String
  last_digits_gte: String
  last_digits_contains: String
  last_digits_not_contains: String
  last_digits_starts_with: String
  last_digits_not_starts_with: String
  last_digits_ends_with: String
  last_digits_not_ends_with: String
  expiration_month: Int
  expiration_month_not: Int
  expiration_month_in: [Int!]
  expiration_month_not_in: [Int!]
  expiration_month_lt: Int
  expiration_month_lte: Int
  expiration_month_gt: Int
  expiration_month_gte: Int
  expiration_year: Int
  expiration_year_not: Int
  expiration_year_in: [Int!]
  expiration_year_not_in: [Int!]
  expiration_year_lt: Int
  expiration_year_lte: Int
  expiration_year_gt: Int
  expiration_year_gte: Int
  street1: String
  street1_not: String
  street1_in: [String!]
  street1_not_in: [String!]
  street1_lt: String
  street1_lte: String
  street1_gt: String
  street1_gte: String
  street1_contains: String
  street1_not_contains: String
  street1_starts_with: String
  street1_not_starts_with: String
  street1_ends_with: String
  street1_not_ends_with: String
  street2: String
  street2_not: String
  street2_in: [String!]
  street2_not_in: [String!]
  street2_lt: String
  street2_lte: String
  street2_gt: String
  street2_gte: String
  street2_contains: String
  street2_not_contains: String
  street2_starts_with: String
  street2_not_starts_with: String
  street2_ends_with: String
  street2_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  postal_code: String
  postal_code_not: String
  postal_code_in: [String!]
  postal_code_not_in: [String!]
  postal_code_lt: String
  postal_code_lte: String
  postal_code_gt: String
  postal_code_gte: String
  postal_code_contains: String
  postal_code_not_contains: String
  postal_code_starts_with: String
  postal_code_not_starts_with: String
  postal_code_ends_with: String
  postal_code_not_ends_with: String
  AND: [BillingInfoWhereInput!]
  OR: [BillingInfoWhereInput!]
  NOT: [BillingInfoWhereInput!]
}

input BillingInfoWhereUniqueInput {
  id: ID
}

type Brand {
  id: ID!
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean!
  logo: Json
  name: String!
  basedIn: String
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrandConnection {
  pageInfo: PageInfo!
  edges: [BrandEdge]!
  aggregate: AggregateBrand!
}

input BrandCreateInput {
  id: ID
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  basedIn: String
  products: ProductCreateManyWithoutBrandInput
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
}

input BrandCreateOneWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandCreateWithoutProductsInput {
  id: ID
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  basedIn: String
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
}

type BrandEdge {
  node: Brand!
  cursor: String!
}

enum BrandOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  brandCode_ASC
  brandCode_DESC
  description_ASC
  description_DESC
  isPrimaryBrand_ASC
  isPrimaryBrand_DESC
  logo_ASC
  logo_DESC
  name_ASC
  name_DESC
  basedIn_ASC
  basedIn_DESC
  since_ASC
  since_DESC
  tier_ASC
  tier_DESC
  websiteUrl_ASC
  websiteUrl_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BrandPreviousValues {
  id: ID!
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean!
  logo: Json
  name: String!
  basedIn: String
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrandSubscriptionPayload {
  mutation: MutationType!
  node: Brand
  updatedFields: [String!]
  previousValues: BrandPreviousValues
}

input BrandSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BrandWhereInput
  AND: [BrandSubscriptionWhereInput!]
  OR: [BrandSubscriptionWhereInput!]
  NOT: [BrandSubscriptionWhereInput!]
}

enum BrandTier {
  Tier0
  Tier1
  Tier2
  Niche
  Upcoming
  Retro
  Boutique
  Local
  Discovery
}

input BrandUpdateInput {
  slug: String
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  basedIn: String
  products: ProductUpdateManyWithoutBrandInput
  since: DateTime
  tier: BrandTier
  websiteUrl: String
}

input BrandUpdateManyMutationInput {
  slug: String
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  basedIn: String
  since: DateTime
  tier: BrandTier
  websiteUrl: String
}

input BrandUpdateOneRequiredWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  update: BrandUpdateWithoutProductsDataInput
  upsert: BrandUpsertWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandUpdateWithoutProductsDataInput {
  slug: String
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  basedIn: String
  since: DateTime
  tier: BrandTier
  websiteUrl: String
}

input BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput!
  create: BrandCreateWithoutProductsInput!
}

input BrandWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  brandCode: String
  brandCode_not: String
  brandCode_in: [String!]
  brandCode_not_in: [String!]
  brandCode_lt: String
  brandCode_lte: String
  brandCode_gt: String
  brandCode_gte: String
  brandCode_contains: String
  brandCode_not_contains: String
  brandCode_starts_with: String
  brandCode_not_starts_with: String
  brandCode_ends_with: String
  brandCode_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isPrimaryBrand: Boolean
  isPrimaryBrand_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  basedIn: String
  basedIn_not: String
  basedIn_in: [String!]
  basedIn_not_in: [String!]
  basedIn_lt: String
  basedIn_lte: String
  basedIn_gt: String
  basedIn_gte: String
  basedIn_contains: String
  basedIn_not_contains: String
  basedIn_starts_with: String
  basedIn_not_starts_with: String
  basedIn_ends_with: String
  basedIn_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  since: DateTime
  since_not: DateTime
  since_in: [DateTime!]
  since_not_in: [DateTime!]
  since_lt: DateTime
  since_lte: DateTime
  since_gt: DateTime
  since_gte: DateTime
  tier: BrandTier
  tier_not: BrandTier
  tier_in: [BrandTier!]
  tier_not_in: [BrandTier!]
  websiteUrl: String
  websiteUrl_not: String
  websiteUrl_in: [String!]
  websiteUrl_not_in: [String!]
  websiteUrl_lt: String
  websiteUrl_lte: String
  websiteUrl_gt: String
  websiteUrl_gte: String
  websiteUrl_contains: String
  websiteUrl_not_contains: String
  websiteUrl_starts_with: String
  websiteUrl_not_starts_with: String
  websiteUrl_ends_with: String
  websiteUrl_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BrandWhereInput!]
  OR: [BrandWhereInput!]
  NOT: [BrandWhereInput!]
}

input BrandWhereUniqueInput {
  id: ID
  slug: String
  brandCode: String
}

type Category {
  id: ID!
  slug: String!
  name: String!
  image: Json
  description: String
  visible: Boolean!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  children(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  slug: String!
  name: String!
  image: Json
  description: String
  visible: Boolean
  products: ProductCreateManyWithoutCategoryInput
  children: CategoryCreateManyWithoutChildrenInput
}

input CategoryCreateManyWithoutChildrenInput {
  create: [CategoryCreateWithoutChildrenInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutChildrenInput {
  id: ID
  slug: String!
  name: String!
  image: Json
  description: String
  visible: Boolean
  products: ProductCreateManyWithoutCategoryInput
}

input CategoryCreateWithoutProductsInput {
  id: ID
  slug: String!
  name: String!
  image: Json
  description: String
  visible: Boolean
  children: CategoryCreateManyWithoutChildrenInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  image_ASC
  image_DESC
  description_ASC
  description_DESC
  visible_ASC
  visible_DESC
}

type CategoryPreviousValues {
  id: ID!
  slug: String!
  name: String!
  image: Json
  description: String
  visible: Boolean!
}

input CategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  visible: Boolean
  visible_not: Boolean
  AND: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateInput {
  slug: String
  name: String
  image: Json
  description: String
  visible: Boolean
  products: ProductUpdateManyWithoutCategoryInput
  children: CategoryUpdateManyWithoutChildrenInput
}

input CategoryUpdateManyDataInput {
  slug: String
  name: String
  image: Json
  description: String
  visible: Boolean
}

input CategoryUpdateManyMutationInput {
  slug: String
  name: String
  image: Json
  description: String
  visible: Boolean
}

input CategoryUpdateManyWithoutChildrenInput {
  create: [CategoryCreateWithoutChildrenInput!]
  delete: [CategoryWhereUniqueInput!]
  connect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutChildrenInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutChildrenInput!]
  deleteMany: [CategoryScalarWhereInput!]
  updateMany: [CategoryUpdateManyWithWhereNestedInput!]
}

input CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput!
  data: CategoryUpdateManyDataInput!
}

input CategoryUpdateOneRequiredWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput
  update: CategoryUpdateWithoutProductsDataInput
  upsert: CategoryUpsertWithoutProductsInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutChildrenDataInput {
  slug: String
  name: String
  image: Json
  description: String
  visible: Boolean
  products: ProductUpdateManyWithoutCategoryInput
}

input CategoryUpdateWithoutProductsDataInput {
  slug: String
  name: String
  image: Json
  description: String
  visible: Boolean
  children: CategoryUpdateManyWithoutChildrenInput
}

input CategoryUpdateWithWhereUniqueWithoutChildrenInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutChildrenDataInput!
}

input CategoryUpsertWithoutProductsInput {
  update: CategoryUpdateWithoutProductsDataInput!
  create: CategoryCreateWithoutProductsInput!
}

input CategoryUpsertWithWhereUniqueWithoutChildrenInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutChildrenDataInput!
  create: CategoryCreateWithoutChildrenInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  visible: Boolean
  visible_not: Boolean
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  children_every: CategoryWhereInput
  children_some: CategoryWhereInput
  children_none: CategoryWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
  slug: String
  name: String
}

type Collection {
  id: ID!
  slug: String!
  images: Json!
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type CollectionConnection {
  pageInfo: PageInfo!
  edges: [CollectionEdge]!
  aggregate: AggregateCollection!
}

input CollectionCreateInput {
  id: ID
  slug: String!
  images: Json!
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
  products: ProductCreateManyInput
}

input CollectionCreateManyInput {
  create: [CollectionCreateInput!]
  connect: [CollectionWhereUniqueInput!]
}

type CollectionEdge {
  node: Collection!
  cursor: String!
}

type CollectionGroup {
  id: ID!
  slug: String!
  title: String
  collectionCount: Int
  collections(where: CollectionWhereInput, orderBy: CollectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Collection!]
}

type CollectionGroupConnection {
  pageInfo: PageInfo!
  edges: [CollectionGroupEdge]!
  aggregate: AggregateCollectionGroup!
}

input CollectionGroupCreateInput {
  id: ID
  slug: String!
  title: String
  collectionCount: Int
  collections: CollectionCreateManyInput
}

type CollectionGroupEdge {
  node: CollectionGroup!
  cursor: String!
}

enum CollectionGroupOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  title_ASC
  title_DESC
  collectionCount_ASC
  collectionCount_DESC
}

type CollectionGroupPreviousValues {
  id: ID!
  slug: String!
  title: String
  collectionCount: Int
}

type CollectionGroupSubscriptionPayload {
  mutation: MutationType!
  node: CollectionGroup
  updatedFields: [String!]
  previousValues: CollectionGroupPreviousValues
}

input CollectionGroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CollectionGroupWhereInput
  AND: [CollectionGroupSubscriptionWhereInput!]
  OR: [CollectionGroupSubscriptionWhereInput!]
  NOT: [CollectionGroupSubscriptionWhereInput!]
}

input CollectionGroupUpdateInput {
  slug: String
  title: String
  collectionCount: Int
  collections: CollectionUpdateManyInput
}

input CollectionGroupUpdateManyMutationInput {
  slug: String
  title: String
  collectionCount: Int
}

input CollectionGroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  collectionCount: Int
  collectionCount_not: Int
  collectionCount_in: [Int!]
  collectionCount_not_in: [Int!]
  collectionCount_lt: Int
  collectionCount_lte: Int
  collectionCount_gt: Int
  collectionCount_gte: Int
  collections_every: CollectionWhereInput
  collections_some: CollectionWhereInput
  collections_none: CollectionWhereInput
  AND: [CollectionGroupWhereInput!]
  OR: [CollectionGroupWhereInput!]
  NOT: [CollectionGroupWhereInput!]
}

input CollectionGroupWhereUniqueInput {
  id: ID
  slug: String
}

enum CollectionOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  images_ASC
  images_DESC
  title_ASC
  title_DESC
  subTitle_ASC
  subTitle_DESC
  descriptionTop_ASC
  descriptionTop_DESC
  descriptionBottom_ASC
  descriptionBottom_DESC
}

type CollectionPreviousValues {
  id: ID!
  slug: String!
  images: Json!
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
}

input CollectionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  subTitle: String
  subTitle_not: String
  subTitle_in: [String!]
  subTitle_not_in: [String!]
  subTitle_lt: String
  subTitle_lte: String
  subTitle_gt: String
  subTitle_gte: String
  subTitle_contains: String
  subTitle_not_contains: String
  subTitle_starts_with: String
  subTitle_not_starts_with: String
  subTitle_ends_with: String
  subTitle_not_ends_with: String
  descriptionTop: String
  descriptionTop_not: String
  descriptionTop_in: [String!]
  descriptionTop_not_in: [String!]
  descriptionTop_lt: String
  descriptionTop_lte: String
  descriptionTop_gt: String
  descriptionTop_gte: String
  descriptionTop_contains: String
  descriptionTop_not_contains: String
  descriptionTop_starts_with: String
  descriptionTop_not_starts_with: String
  descriptionTop_ends_with: String
  descriptionTop_not_ends_with: String
  descriptionBottom: String
  descriptionBottom_not: String
  descriptionBottom_in: [String!]
  descriptionBottom_not_in: [String!]
  descriptionBottom_lt: String
  descriptionBottom_lte: String
  descriptionBottom_gt: String
  descriptionBottom_gte: String
  descriptionBottom_contains: String
  descriptionBottom_not_contains: String
  descriptionBottom_starts_with: String
  descriptionBottom_not_starts_with: String
  descriptionBottom_ends_with: String
  descriptionBottom_not_ends_with: String
  AND: [CollectionScalarWhereInput!]
  OR: [CollectionScalarWhereInput!]
  NOT: [CollectionScalarWhereInput!]
}

type CollectionSubscriptionPayload {
  mutation: MutationType!
  node: Collection
  updatedFields: [String!]
  previousValues: CollectionPreviousValues
}

input CollectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CollectionWhereInput
  AND: [CollectionSubscriptionWhereInput!]
  OR: [CollectionSubscriptionWhereInput!]
  NOT: [CollectionSubscriptionWhereInput!]
}

input CollectionUpdateDataInput {
  slug: String
  images: Json
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
  products: ProductUpdateManyInput
}

input CollectionUpdateInput {
  slug: String
  images: Json
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
  products: ProductUpdateManyInput
}

input CollectionUpdateManyDataInput {
  slug: String
  images: Json
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
}

input CollectionUpdateManyInput {
  create: [CollectionCreateInput!]
  update: [CollectionUpdateWithWhereUniqueNestedInput!]
  upsert: [CollectionUpsertWithWhereUniqueNestedInput!]
  delete: [CollectionWhereUniqueInput!]
  connect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  disconnect: [CollectionWhereUniqueInput!]
  deleteMany: [CollectionScalarWhereInput!]
  updateMany: [CollectionUpdateManyWithWhereNestedInput!]
}

input CollectionUpdateManyMutationInput {
  slug: String
  images: Json
  title: String
  subTitle: String
  descriptionTop: String
  descriptionBottom: String
}

input CollectionUpdateManyWithWhereNestedInput {
  where: CollectionScalarWhereInput!
  data: CollectionUpdateManyDataInput!
}

input CollectionUpdateWithWhereUniqueNestedInput {
  where: CollectionWhereUniqueInput!
  data: CollectionUpdateDataInput!
}

input CollectionUpsertWithWhereUniqueNestedInput {
  where: CollectionWhereUniqueInput!
  update: CollectionUpdateDataInput!
  create: CollectionCreateInput!
}

input CollectionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  subTitle: String
  subTitle_not: String
  subTitle_in: [String!]
  subTitle_not_in: [String!]
  subTitle_lt: String
  subTitle_lte: String
  subTitle_gt: String
  subTitle_gte: String
  subTitle_contains: String
  subTitle_not_contains: String
  subTitle_starts_with: String
  subTitle_not_starts_with: String
  subTitle_ends_with: String
  subTitle_not_ends_with: String
  descriptionTop: String
  descriptionTop_not: String
  descriptionTop_in: [String!]
  descriptionTop_not_in: [String!]
  descriptionTop_lt: String
  descriptionTop_lte: String
  descriptionTop_gt: String
  descriptionTop_gte: String
  descriptionTop_contains: String
  descriptionTop_not_contains: String
  descriptionTop_starts_with: String
  descriptionTop_not_starts_with: String
  descriptionTop_ends_with: String
  descriptionTop_not_ends_with: String
  descriptionBottom: String
  descriptionBottom_not: String
  descriptionBottom_in: [String!]
  descriptionBottom_not_in: [String!]
  descriptionBottom_lt: String
  descriptionBottom_lte: String
  descriptionBottom_gt: String
  descriptionBottom_gte: String
  descriptionBottom_contains: String
  descriptionBottom_not_contains: String
  descriptionBottom_starts_with: String
  descriptionBottom_not_starts_with: String
  descriptionBottom_ends_with: String
  descriptionBottom_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  NOT: [CollectionWhereInput!]
}

input CollectionWhereUniqueInput {
  id: ID
  slug: String
}

type Color {
  id: ID!
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
}

type ColorConnection {
  pageInfo: PageInfo!
  edges: [ColorEdge]!
  aggregate: AggregateColor!
}

input ColorCreateInput {
  id: ID
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
  productVariants: ProductVariantCreateManyWithoutColorInput
}

input ColorCreateOneInput {
  create: ColorCreateInput
  connect: ColorWhereUniqueInput
}

input ColorCreateOneWithoutProductVariantsInput {
  create: ColorCreateWithoutProductVariantsInput
  connect: ColorWhereUniqueInput
}

input ColorCreateWithoutProductVariantsInput {
  id: ID
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
}

type ColorEdge {
  node: Color!
  cursor: String!
}

enum ColorOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  colorCode_ASC
  colorCode_DESC
  hexCode_ASC
  hexCode_DESC
}

type ColorPreviousValues {
  id: ID!
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
}

type ColorSubscriptionPayload {
  mutation: MutationType!
  node: Color
  updatedFields: [String!]
  previousValues: ColorPreviousValues
}

input ColorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ColorWhereInput
  AND: [ColorSubscriptionWhereInput!]
  OR: [ColorSubscriptionWhereInput!]
  NOT: [ColorSubscriptionWhereInput!]
}

input ColorUpdateDataInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
  productVariants: ProductVariantUpdateManyWithoutColorInput
}

input ColorUpdateInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
  productVariants: ProductVariantUpdateManyWithoutColorInput
}

input ColorUpdateManyMutationInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
}

input ColorUpdateOneInput {
  create: ColorCreateInput
  update: ColorUpdateDataInput
  upsert: ColorUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ColorWhereUniqueInput
}

input ColorUpdateOneRequiredInput {
  create: ColorCreateInput
  update: ColorUpdateDataInput
  upsert: ColorUpsertNestedInput
  connect: ColorWhereUniqueInput
}

input ColorUpdateOneRequiredWithoutProductVariantsInput {
  create: ColorCreateWithoutProductVariantsInput
  update: ColorUpdateWithoutProductVariantsDataInput
  upsert: ColorUpsertWithoutProductVariantsInput
  connect: ColorWhereUniqueInput
}

input ColorUpdateWithoutProductVariantsDataInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
}

input ColorUpsertNestedInput {
  update: ColorUpdateDataInput!
  create: ColorCreateInput!
}

input ColorUpsertWithoutProductVariantsInput {
  update: ColorUpdateWithoutProductVariantsDataInput!
  create: ColorCreateWithoutProductVariantsInput!
}

input ColorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  colorCode: String
  colorCode_not: String
  colorCode_in: [String!]
  colorCode_not_in: [String!]
  colorCode_lt: String
  colorCode_lte: String
  colorCode_gt: String
  colorCode_gte: String
  colorCode_contains: String
  colorCode_not_contains: String
  colorCode_starts_with: String
  colorCode_not_starts_with: String
  colorCode_ends_with: String
  colorCode_not_ends_with: String
  hexCode: String
  hexCode_not: String
  hexCode_in: [String!]
  hexCode_not_in: [String!]
  hexCode_lt: String
  hexCode_lte: String
  hexCode_gt: String
  hexCode_gte: String
  hexCode_contains: String
  hexCode_not_contains: String
  hexCode_starts_with: String
  hexCode_not_starts_with: String
  hexCode_ends_with: String
  hexCode_not_ends_with: String
  productVariants_every: ProductVariantWhereInput
  productVariants_some: ProductVariantWhereInput
  productVariants_none: ProductVariantWhereInput
  AND: [ColorWhereInput!]
  OR: [ColorWhereInput!]
  NOT: [ColorWhereInput!]
}

input ColorWhereUniqueInput {
  id: ID
  slug: String
  colorCode: String
}

type Customer {
  id: ID!
  user: User!
  status: CustomerStatus
  detail: CustomerDetail
  billingInfo: BillingInfo
  plan: Plan
  reservations(where: ReservationWhereInput, orderBy: ReservationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reservation!]
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  user: UserCreateOneInput!
  status: CustomerStatus
  detail: CustomerDetailCreateOneInput
  billingInfo: BillingInfoCreateOneInput
  plan: Plan
  reservations: ReservationCreateManyWithoutCustomerInput
}

input CustomerCreateOneInput {
  create: CustomerCreateInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateOneWithoutReservationsInput {
  create: CustomerCreateWithoutReservationsInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutReservationsInput {
  id: ID
  user: UserCreateOneInput!
  status: CustomerStatus
  detail: CustomerDetailCreateOneInput
  billingInfo: BillingInfoCreateOneInput
  plan: Plan
}

type CustomerDetail {
  id: ID!
  phoneNumber: String
  birthday: DateTime
  height: Int
  weight: String
  bodyType: String
  averageTopSize: String
  averageWaistSize: String
  averagePantLength: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  style: String
  commuteStyle: String
  shippingAddress: Location
  phoneOS: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerDetailConnection {
  pageInfo: PageInfo!
  edges: [CustomerDetailEdge]!
  aggregate: AggregateCustomerDetail!
}

input CustomerDetailCreateInput {
  id: ID
  phoneNumber: String
  birthday: DateTime
  height: Int
  weight: String
  bodyType: String
  averageTopSize: String
  averageWaistSize: String
  averagePantLength: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  style: String
  commuteStyle: String
  shippingAddress: LocationCreateOneInput
  phoneOS: String
}

input CustomerDetailCreateOneInput {
  create: CustomerDetailCreateInput
  connect: CustomerDetailWhereUniqueInput
}

type CustomerDetailEdge {
  node: CustomerDetail!
  cursor: String!
}

enum CustomerDetailOrderByInput {
  id_ASC
  id_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  birthday_ASC
  birthday_DESC
  height_ASC
  height_DESC
  weight_ASC
  weight_DESC
  bodyType_ASC
  bodyType_DESC
  averageTopSize_ASC
  averageTopSize_DESC
  averageWaistSize_ASC
  averageWaistSize_DESC
  averagePantLength_ASC
  averagePantLength_DESC
  preferredPronouns_ASC
  preferredPronouns_DESC
  profession_ASC
  profession_DESC
  partyFrequency_ASC
  partyFrequency_DESC
  travelFrequency_ASC
  travelFrequency_DESC
  shoppingFrequency_ASC
  shoppingFrequency_DESC
  averageSpend_ASC
  averageSpend_DESC
  style_ASC
  style_DESC
  commuteStyle_ASC
  commuteStyle_DESC
  phoneOS_ASC
  phoneOS_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CustomerDetailPreviousValues {
  id: ID!
  phoneNumber: String
  birthday: DateTime
  height: Int
  weight: String
  bodyType: String
  averageTopSize: String
  averageWaistSize: String
  averagePantLength: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  style: String
  commuteStyle: String
  phoneOS: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerDetailSubscriptionPayload {
  mutation: MutationType!
  node: CustomerDetail
  updatedFields: [String!]
  previousValues: CustomerDetailPreviousValues
}

input CustomerDetailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerDetailWhereInput
  AND: [CustomerDetailSubscriptionWhereInput!]
  OR: [CustomerDetailSubscriptionWhereInput!]
  NOT: [CustomerDetailSubscriptionWhereInput!]
}

input CustomerDetailUpdateDataInput {
  phoneNumber: String
  birthday: DateTime
  height: Int
  weight: String
  bodyType: String
  averageTopSize: String
  averageWaistSize: String
  averagePantLength: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  style: String
  commuteStyle: String
  shippingAddress: LocationUpdateOneInput
  phoneOS: String
}

input CustomerDetailUpdateInput {
  phoneNumber: String
  birthday: DateTime
  height: Int
  weight: String
  bodyType: String
  averageTopSize: String
  averageWaistSize: String
  averagePantLength: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  style: String
  commuteStyle: String
  shippingAddress: LocationUpdateOneInput
  phoneOS: String
}

input CustomerDetailUpdateManyMutationInput {
  phoneNumber: String
  birthday: DateTime
  height: Int
  weight: String
  bodyType: String
  averageTopSize: String
  averageWaistSize: String
  averagePantLength: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  style: String
  commuteStyle: String
  phoneOS: String
}

input CustomerDetailUpdateOneInput {
  create: CustomerDetailCreateInput
  update: CustomerDetailUpdateDataInput
  upsert: CustomerDetailUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CustomerDetailWhereUniqueInput
}

input CustomerDetailUpsertNestedInput {
  update: CustomerDetailUpdateDataInput!
  create: CustomerDetailCreateInput!
}

input CustomerDetailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  birthday: DateTime
  birthday_not: DateTime
  birthday_in: [DateTime!]
  birthday_not_in: [DateTime!]
  birthday_lt: DateTime
  birthday_lte: DateTime
  birthday_gt: DateTime
  birthday_gte: DateTime
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  weight: String
  weight_not: String
  weight_in: [String!]
  weight_not_in: [String!]
  weight_lt: String
  weight_lte: String
  weight_gt: String
  weight_gte: String
  weight_contains: String
  weight_not_contains: String
  weight_starts_with: String
  weight_not_starts_with: String
  weight_ends_with: String
  weight_not_ends_with: String
  bodyType: String
  bodyType_not: String
  bodyType_in: [String!]
  bodyType_not_in: [String!]
  bodyType_lt: String
  bodyType_lte: String
  bodyType_gt: String
  bodyType_gte: String
  bodyType_contains: String
  bodyType_not_contains: String
  bodyType_starts_with: String
  bodyType_not_starts_with: String
  bodyType_ends_with: String
  bodyType_not_ends_with: String
  averageTopSize: String
  averageTopSize_not: String
  averageTopSize_in: [String!]
  averageTopSize_not_in: [String!]
  averageTopSize_lt: String
  averageTopSize_lte: String
  averageTopSize_gt: String
  averageTopSize_gte: String
  averageTopSize_contains: String
  averageTopSize_not_contains: String
  averageTopSize_starts_with: String
  averageTopSize_not_starts_with: String
  averageTopSize_ends_with: String
  averageTopSize_not_ends_with: String
  averageWaistSize: String
  averageWaistSize_not: String
  averageWaistSize_in: [String!]
  averageWaistSize_not_in: [String!]
  averageWaistSize_lt: String
  averageWaistSize_lte: String
  averageWaistSize_gt: String
  averageWaistSize_gte: String
  averageWaistSize_contains: String
  averageWaistSize_not_contains: String
  averageWaistSize_starts_with: String
  averageWaistSize_not_starts_with: String
  averageWaistSize_ends_with: String
  averageWaistSize_not_ends_with: String
  averagePantLength: String
  averagePantLength_not: String
  averagePantLength_in: [String!]
  averagePantLength_not_in: [String!]
  averagePantLength_lt: String
  averagePantLength_lte: String
  averagePantLength_gt: String
  averagePantLength_gte: String
  averagePantLength_contains: String
  averagePantLength_not_contains: String
  averagePantLength_starts_with: String
  averagePantLength_not_starts_with: String
  averagePantLength_ends_with: String
  averagePantLength_not_ends_with: String
  preferredPronouns: String
  preferredPronouns_not: String
  preferredPronouns_in: [String!]
  preferredPronouns_not_in: [String!]
  preferredPronouns_lt: String
  preferredPronouns_lte: String
  preferredPronouns_gt: String
  preferredPronouns_gte: String
  preferredPronouns_contains: String
  preferredPronouns_not_contains: String
  preferredPronouns_starts_with: String
  preferredPronouns_not_starts_with: String
  preferredPronouns_ends_with: String
  preferredPronouns_not_ends_with: String
  profession: String
  profession_not: String
  profession_in: [String!]
  profession_not_in: [String!]
  profession_lt: String
  profession_lte: String
  profession_gt: String
  profession_gte: String
  profession_contains: String
  profession_not_contains: String
  profession_starts_with: String
  profession_not_starts_with: String
  profession_ends_with: String
  profession_not_ends_with: String
  partyFrequency: String
  partyFrequency_not: String
  partyFrequency_in: [String!]
  partyFrequency_not_in: [String!]
  partyFrequency_lt: String
  partyFrequency_lte: String
  partyFrequency_gt: String
  partyFrequency_gte: String
  partyFrequency_contains: String
  partyFrequency_not_contains: String
  partyFrequency_starts_with: String
  partyFrequency_not_starts_with: String
  partyFrequency_ends_with: String
  partyFrequency_not_ends_with: String
  travelFrequency: String
  travelFrequency_not: String
  travelFrequency_in: [String!]
  travelFrequency_not_in: [String!]
  travelFrequency_lt: String
  travelFrequency_lte: String
  travelFrequency_gt: String
  travelFrequency_gte: String
  travelFrequency_contains: String
  travelFrequency_not_contains: String
  travelFrequency_starts_with: String
  travelFrequency_not_starts_with: String
  travelFrequency_ends_with: String
  travelFrequency_not_ends_with: String
  shoppingFrequency: String
  shoppingFrequency_not: String
  shoppingFrequency_in: [String!]
  shoppingFrequency_not_in: [String!]
  shoppingFrequency_lt: String
  shoppingFrequency_lte: String
  shoppingFrequency_gt: String
  shoppingFrequency_gte: String
  shoppingFrequency_contains: String
  shoppingFrequency_not_contains: String
  shoppingFrequency_starts_with: String
  shoppingFrequency_not_starts_with: String
  shoppingFrequency_ends_with: String
  shoppingFrequency_not_ends_with: String
  averageSpend: String
  averageSpend_not: String
  averageSpend_in: [String!]
  averageSpend_not_in: [String!]
  averageSpend_lt: String
  averageSpend_lte: String
  averageSpend_gt: String
  averageSpend_gte: String
  averageSpend_contains: String
  averageSpend_not_contains: String
  averageSpend_starts_with: String
  averageSpend_not_starts_with: String
  averageSpend_ends_with: String
  averageSpend_not_ends_with: String
  style: String
  style_not: String
  style_in: [String!]
  style_not_in: [String!]
  style_lt: String
  style_lte: String
  style_gt: String
  style_gte: String
  style_contains: String
  style_not_contains: String
  style_starts_with: String
  style_not_starts_with: String
  style_ends_with: String
  style_not_ends_with: String
  commuteStyle: String
  commuteStyle_not: String
  commuteStyle_in: [String!]
  commuteStyle_not_in: [String!]
  commuteStyle_lt: String
  commuteStyle_lte: String
  commuteStyle_gt: String
  commuteStyle_gte: String
  commuteStyle_contains: String
  commuteStyle_not_contains: String
  commuteStyle_starts_with: String
  commuteStyle_not_starts_with: String
  commuteStyle_ends_with: String
  commuteStyle_not_ends_with: String
  shippingAddress: LocationWhereInput
  phoneOS: String
  phoneOS_not: String
  phoneOS_in: [String!]
  phoneOS_not_in: [String!]
  phoneOS_lt: String
  phoneOS_lte: String
  phoneOS_gt: String
  phoneOS_gte: String
  phoneOS_contains: String
  phoneOS_not_contains: String
  phoneOS_starts_with: String
  phoneOS_not_starts_with: String
  phoneOS_ends_with: String
  phoneOS_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CustomerDetailWhereInput!]
  OR: [CustomerDetailWhereInput!]
  NOT: [CustomerDetailWhereInput!]
}

input CustomerDetailWhereUniqueInput {
  id: ID
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  plan_ASC
  plan_DESC
}

type CustomerPreviousValues {
  id: ID!
  status: CustomerStatus
  plan: Plan
}

enum CustomerStatus {
  Invited
  Created
  Waitlisted
  Authorized
  Active
  Suspended
  Paused
  Deactivated
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateDataInput {
  user: UserUpdateOneRequiredInput
  status: CustomerStatus
  detail: CustomerDetailUpdateOneInput
  billingInfo: BillingInfoUpdateOneInput
  plan: Plan
  reservations: ReservationUpdateManyWithoutCustomerInput
}

input CustomerUpdateInput {
  user: UserUpdateOneRequiredInput
  status: CustomerStatus
  detail: CustomerDetailUpdateOneInput
  billingInfo: BillingInfoUpdateOneInput
  plan: Plan
  reservations: ReservationUpdateManyWithoutCustomerInput
}

input CustomerUpdateManyMutationInput {
  status: CustomerStatus
  plan: Plan
}

input CustomerUpdateOneRequiredInput {
  create: CustomerCreateInput
  update: CustomerUpdateDataInput
  upsert: CustomerUpsertNestedInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateOneRequiredWithoutReservationsInput {
  create: CustomerCreateWithoutReservationsInput
  update: CustomerUpdateWithoutReservationsDataInput
  upsert: CustomerUpsertWithoutReservationsInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutReservationsDataInput {
  user: UserUpdateOneRequiredInput
  status: CustomerStatus
  detail: CustomerDetailUpdateOneInput
  billingInfo: BillingInfoUpdateOneInput
  plan: Plan
}

input CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput!
  create: CustomerCreateInput!
}

input CustomerUpsertWithoutReservationsInput {
  update: CustomerUpdateWithoutReservationsDataInput!
  create: CustomerCreateWithoutReservationsInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  status: CustomerStatus
  status_not: CustomerStatus
  status_in: [CustomerStatus!]
  status_not_in: [CustomerStatus!]
  detail: CustomerDetailWhereInput
  billingInfo: BillingInfoWhereInput
  plan: Plan
  plan_not: Plan
  plan_in: [Plan!]
  plan_not_in: [Plan!]
  reservations_every: ReservationWhereInput
  reservations_some: ReservationWhereInput
  reservations_none: ReservationWhereInput
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

type HomepageProductRail {
  id: ID!
  slug: String!
  name: String!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type HomepageProductRailConnection {
  pageInfo: PageInfo!
  edges: [HomepageProductRailEdge]!
  aggregate: AggregateHomepageProductRail!
}

input HomepageProductRailCreateInput {
  id: ID
  slug: String!
  name: String!
  products: ProductCreateManyInput
}

type HomepageProductRailEdge {
  node: HomepageProductRail!
  cursor: String!
}

enum HomepageProductRailOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
}

type HomepageProductRailPreviousValues {
  id: ID!
  slug: String!
  name: String!
}

type HomepageProductRailSubscriptionPayload {
  mutation: MutationType!
  node: HomepageProductRail
  updatedFields: [String!]
  previousValues: HomepageProductRailPreviousValues
}

input HomepageProductRailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HomepageProductRailWhereInput
  AND: [HomepageProductRailSubscriptionWhereInput!]
  OR: [HomepageProductRailSubscriptionWhereInput!]
  NOT: [HomepageProductRailSubscriptionWhereInput!]
}

input HomepageProductRailUpdateInput {
  slug: String
  name: String
  products: ProductUpdateManyInput
}

input HomepageProductRailUpdateManyMutationInput {
  slug: String
  name: String
}

input HomepageProductRailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [HomepageProductRailWhereInput!]
  OR: [HomepageProductRailWhereInput!]
  NOT: [HomepageProductRailWhereInput!]
}

input HomepageProductRailWhereUniqueInput {
  id: ID
  slug: String
}

type Image {
  id: ID!
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: ID
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  caption_ASC
  caption_DESC
  originalHeight_ASC
  originalHeight_DESC
  originalUrl_ASC
  originalUrl_DESC
  originalWidth_ASC
  originalWidth_DESC
  resizedUrl_ASC
  resizedUrl_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ImagePreviousValues {
  id: ID!
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateInput {
  caption: String
  originalHeight: Int
  originalUrl: String
  originalWidth: Int
  resizedUrl: String
  title: String
}

input ImageUpdateManyMutationInput {
  caption: String
  originalHeight: Int
  originalUrl: String
  originalWidth: Int
  resizedUrl: String
  title: String
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  originalHeight: Int
  originalHeight_not: Int
  originalHeight_in: [Int!]
  originalHeight_not_in: [Int!]
  originalHeight_lt: Int
  originalHeight_lte: Int
  originalHeight_gt: Int
  originalHeight_gte: Int
  originalUrl: String
  originalUrl_not: String
  originalUrl_in: [String!]
  originalUrl_not_in: [String!]
  originalUrl_lt: String
  originalUrl_lte: String
  originalUrl_gt: String
  originalUrl_gte: String
  originalUrl_contains: String
  originalUrl_not_contains: String
  originalUrl_starts_with: String
  originalUrl_not_starts_with: String
  originalUrl_ends_with: String
  originalUrl_not_ends_with: String
  originalWidth: Int
  originalWidth_not: Int
  originalWidth_in: [Int!]
  originalWidth_not_in: [Int!]
  originalWidth_lt: Int
  originalWidth_lte: Int
  originalWidth_gt: Int
  originalWidth_gte: Int
  resizedUrl: String
  resizedUrl_not: String
  resizedUrl_in: [String!]
  resizedUrl_not_in: [String!]
  resizedUrl_lt: String
  resizedUrl_lte: String
  resizedUrl_gt: String
  resizedUrl_gte: String
  resizedUrl_contains: String
  resizedUrl_not_contains: String
  resizedUrl_starts_with: String
  resizedUrl_not_starts_with: String
  resizedUrl_ends_with: String
  resizedUrl_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

enum InventoryStatus {
  NonReservable
  Reservable
  Reserved
}

scalar Json

type Label {
  id: ID!
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

type LabelConnection {
  pageInfo: PageInfo!
  edges: [LabelEdge]!
  aggregate: AggregateLabel!
}

input LabelCreateInput {
  id: ID
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

input LabelCreateOneInput {
  create: LabelCreateInput
  connect: LabelWhereUniqueInput
}

type LabelEdge {
  node: Label!
  cursor: String!
}

enum LabelOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  image_ASC
  image_DESC
  trackingNumber_ASC
  trackingNumber_DESC
  trackingURL_ASC
  trackingURL_DESC
}

type LabelPreviousValues {
  id: ID!
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

type LabelSubscriptionPayload {
  mutation: MutationType!
  node: Label
  updatedFields: [String!]
  previousValues: LabelPreviousValues
}

input LabelSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LabelWhereInput
  AND: [LabelSubscriptionWhereInput!]
  OR: [LabelSubscriptionWhereInput!]
  NOT: [LabelSubscriptionWhereInput!]
}

input LabelUpdateDataInput {
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

input LabelUpdateInput {
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

input LabelUpdateManyMutationInput {
  name: String
  image: String
  trackingNumber: String
  trackingURL: String
}

input LabelUpdateOneRequiredInput {
  create: LabelCreateInput
  update: LabelUpdateDataInput
  upsert: LabelUpsertNestedInput
  connect: LabelWhereUniqueInput
}

input LabelUpsertNestedInput {
  update: LabelUpdateDataInput!
  create: LabelCreateInput!
}

input LabelWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  trackingNumber: String
  trackingNumber_not: String
  trackingNumber_in: [String!]
  trackingNumber_not_in: [String!]
  trackingNumber_lt: String
  trackingNumber_lte: String
  trackingNumber_gt: String
  trackingNumber_gte: String
  trackingNumber_contains: String
  trackingNumber_not_contains: String
  trackingNumber_starts_with: String
  trackingNumber_not_starts_with: String
  trackingNumber_ends_with: String
  trackingNumber_not_ends_with: String
  trackingURL: String
  trackingURL_not: String
  trackingURL_in: [String!]
  trackingURL_not_in: [String!]
  trackingURL_lt: String
  trackingURL_lte: String
  trackingURL_gt: String
  trackingURL_gte: String
  trackingURL_contains: String
  trackingURL_not_contains: String
  trackingURL_starts_with: String
  trackingURL_not_starts_with: String
  trackingURL_ends_with: String
  trackingURL_not_ends_with: String
  AND: [LabelWhereInput!]
  OR: [LabelWhereInput!]
  NOT: [LabelWhereInput!]
}

input LabelWhereUniqueInput {
  id: ID
}

type Location {
  id: ID!
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  user: User
  lat: Float
  lng: Float
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  user: UserCreateOneInput
  lat: Float
  lng: Float
  physicalProducts: PhysicalProductCreateManyWithoutLocationInput
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

input LocationCreateOneWithoutPhysicalProductsInput {
  create: LocationCreateWithoutPhysicalProductsInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutPhysicalProductsInput {
  id: ID
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  user: UserCreateOneInput
  lat: Float
  lng: Float
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  company_ASC
  company_DESC
  description_ASC
  description_DESC
  address1_ASC
  address1_DESC
  address2_ASC
  address2_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  zipCode_ASC
  zipCode_DESC
  locationType_ASC
  locationType_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LocationPreviousValues {
  id: ID!
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  lat: Float
  lng: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

enum LocationType {
  Office
  Warehouse
  Cleaner
  Customer
}

input LocationUpdateDataInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  user: UserUpdateOneInput
  lat: Float
  lng: Float
  physicalProducts: PhysicalProductUpdateManyWithoutLocationInput
}

input LocationUpdateInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  user: UserUpdateOneInput
  lat: Float
  lng: Float
  physicalProducts: PhysicalProductUpdateManyWithoutLocationInput
}

input LocationUpdateManyMutationInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  lat: Float
  lng: Float
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneRequiredInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneRequiredWithoutPhysicalProductsInput {
  create: LocationCreateWithoutPhysicalProductsInput
  update: LocationUpdateWithoutPhysicalProductsDataInput
  upsert: LocationUpsertWithoutPhysicalProductsInput
  connect: LocationWhereUniqueInput
}

input LocationUpdateWithoutPhysicalProductsDataInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  user: UserUpdateOneInput
  lat: Float
  lng: Float
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithoutPhysicalProductsInput {
  update: LocationUpdateWithoutPhysicalProductsDataInput!
  create: LocationCreateWithoutPhysicalProductsInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  address1: String
  address1_not: String
  address1_in: [String!]
  address1_not_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_gt: String
  address1_gte: String
  address1_contains: String
  address1_not_contains: String
  address1_starts_with: String
  address1_not_starts_with: String
  address1_ends_with: String
  address1_not_ends_with: String
  address2: String
  address2_not: String
  address2_in: [String!]
  address2_not_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_gt: String
  address2_gte: String
  address2_contains: String
  address2_not_contains: String
  address2_starts_with: String
  address2_not_starts_with: String
  address2_ends_with: String
  address2_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  locationType: LocationType
  locationType_not: LocationType
  locationType_in: [LocationType!]
  locationType_not_in: [LocationType!]
  user: UserWhereInput
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  physicalProducts_every: PhysicalProductWhereInput
  physicalProducts_some: PhysicalProductWhereInput
  physicalProducts_none: PhysicalProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
  slug: String
}

scalar Long

enum Material {
  Acetate
  Acrylic
  Alpaca
  CalfLeather
  CamelHair
  Camel
  Cashmere
  Cotton
  CowLeather
  Cupro
  DuckFeathers
  Elastane
  Esterlane
  Feather
  FeatherDown
  GooseDown
  LambLeather
  LambSkin
  Leather
  Lyocell
  MerinoWool
  Modacrylic
  Nylon
  OrganicCotton
  Polyamide
  Polyester
  Polyurethane
  PolyurethanicResin
  Rayon
  RecycledWool
  Silk
  Suede
  SheepLeather
  Spandex
  Taffeta
  Tartan
  VirginWool
  Viscose
  Velcro
  WaxCoating
  WhiteDuckDown
  WhiteGooseDown
  Wool
  Mesh
  Denim
}

type Mutation {
  createBagItem(data: BagItemCreateInput!): BagItem!
  updateBagItem(data: BagItemUpdateInput!, where: BagItemWhereUniqueInput!): BagItem
  updateManyBagItems(data: BagItemUpdateManyMutationInput!, where: BagItemWhereInput): BatchPayload!
  upsertBagItem(where: BagItemWhereUniqueInput!, create: BagItemCreateInput!, update: BagItemUpdateInput!): BagItem!
  deleteBagItem(where: BagItemWhereUniqueInput!): BagItem
  deleteManyBagItems(where: BagItemWhereInput): BatchPayload!
  createBillingInfo(data: BillingInfoCreateInput!): BillingInfo!
  updateBillingInfo(data: BillingInfoUpdateInput!, where: BillingInfoWhereUniqueInput!): BillingInfo
  updateManyBillingInfoes(data: BillingInfoUpdateManyMutationInput!, where: BillingInfoWhereInput): BatchPayload!
  upsertBillingInfo(where: BillingInfoWhereUniqueInput!, create: BillingInfoCreateInput!, update: BillingInfoUpdateInput!): BillingInfo!
  deleteBillingInfo(where: BillingInfoWhereUniqueInput!): BillingInfo
  deleteManyBillingInfoes(where: BillingInfoWhereInput): BatchPayload!
  createBrand(data: BrandCreateInput!): Brand!
  updateBrand(data: BrandUpdateInput!, where: BrandWhereUniqueInput!): Brand
  updateManyBrands(data: BrandUpdateManyMutationInput!, where: BrandWhereInput): BatchPayload!
  upsertBrand(where: BrandWhereUniqueInput!, create: BrandCreateInput!, update: BrandUpdateInput!): Brand!
  deleteBrand(where: BrandWhereUniqueInput!): Brand
  deleteManyBrands(where: BrandWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createCollection(data: CollectionCreateInput!): Collection!
  updateCollection(data: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection
  updateManyCollections(data: CollectionUpdateManyMutationInput!, where: CollectionWhereInput): BatchPayload!
  upsertCollection(where: CollectionWhereUniqueInput!, create: CollectionCreateInput!, update: CollectionUpdateInput!): Collection!
  deleteCollection(where: CollectionWhereUniqueInput!): Collection
  deleteManyCollections(where: CollectionWhereInput): BatchPayload!
  createCollectionGroup(data: CollectionGroupCreateInput!): CollectionGroup!
  updateCollectionGroup(data: CollectionGroupUpdateInput!, where: CollectionGroupWhereUniqueInput!): CollectionGroup
  updateManyCollectionGroups(data: CollectionGroupUpdateManyMutationInput!, where: CollectionGroupWhereInput): BatchPayload!
  upsertCollectionGroup(where: CollectionGroupWhereUniqueInput!, create: CollectionGroupCreateInput!, update: CollectionGroupUpdateInput!): CollectionGroup!
  deleteCollectionGroup(where: CollectionGroupWhereUniqueInput!): CollectionGroup
  deleteManyCollectionGroups(where: CollectionGroupWhereInput): BatchPayload!
  createColor(data: ColorCreateInput!): Color!
  updateColor(data: ColorUpdateInput!, where: ColorWhereUniqueInput!): Color
  updateManyColors(data: ColorUpdateManyMutationInput!, where: ColorWhereInput): BatchPayload!
  upsertColor(where: ColorWhereUniqueInput!, create: ColorCreateInput!, update: ColorUpdateInput!): Color!
  deleteColor(where: ColorWhereUniqueInput!): Color
  deleteManyColors(where: ColorWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createCustomerDetail(data: CustomerDetailCreateInput!): CustomerDetail!
  updateCustomerDetail(data: CustomerDetailUpdateInput!, where: CustomerDetailWhereUniqueInput!): CustomerDetail
  updateManyCustomerDetails(data: CustomerDetailUpdateManyMutationInput!, where: CustomerDetailWhereInput): BatchPayload!
  upsertCustomerDetail(where: CustomerDetailWhereUniqueInput!, create: CustomerDetailCreateInput!, update: CustomerDetailUpdateInput!): CustomerDetail!
  deleteCustomerDetail(where: CustomerDetailWhereUniqueInput!): CustomerDetail
  deleteManyCustomerDetails(where: CustomerDetailWhereInput): BatchPayload!
  createHomepageProductRail(data: HomepageProductRailCreateInput!): HomepageProductRail!
  updateHomepageProductRail(data: HomepageProductRailUpdateInput!, where: HomepageProductRailWhereUniqueInput!): HomepageProductRail
  updateManyHomepageProductRails(data: HomepageProductRailUpdateManyMutationInput!, where: HomepageProductRailWhereInput): BatchPayload!
  upsertHomepageProductRail(where: HomepageProductRailWhereUniqueInput!, create: HomepageProductRailCreateInput!, update: HomepageProductRailUpdateInput!): HomepageProductRail!
  deleteHomepageProductRail(where: HomepageProductRailWhereUniqueInput!): HomepageProductRail
  deleteManyHomepageProductRails(where: HomepageProductRailWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createLabel(data: LabelCreateInput!): Label!
  updateLabel(data: LabelUpdateInput!, where: LabelWhereUniqueInput!): Label
  updateManyLabels(data: LabelUpdateManyMutationInput!, where: LabelWhereInput): BatchPayload!
  upsertLabel(where: LabelWhereUniqueInput!, create: LabelCreateInput!, update: LabelUpdateInput!): Label!
  deleteLabel(where: LabelWhereUniqueInput!): Label
  deleteManyLabels(where: LabelWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPackage(data: PackageCreateInput!): Package!
  updatePackage(data: PackageUpdateInput!, where: PackageWhereUniqueInput!): Package
  updateManyPackages(data: PackageUpdateManyMutationInput!, where: PackageWhereInput): BatchPayload!
  upsertPackage(where: PackageWhereUniqueInput!, create: PackageCreateInput!, update: PackageUpdateInput!): Package!
  deletePackage(where: PackageWhereUniqueInput!): Package
  deleteManyPackages(where: PackageWhereInput): BatchPayload!
  createPhysicalProduct(data: PhysicalProductCreateInput!): PhysicalProduct!
  updatePhysicalProduct(data: PhysicalProductUpdateInput!, where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  updateManyPhysicalProducts(data: PhysicalProductUpdateManyMutationInput!, where: PhysicalProductWhereInput): BatchPayload!
  upsertPhysicalProduct(where: PhysicalProductWhereUniqueInput!, create: PhysicalProductCreateInput!, update: PhysicalProductUpdateInput!): PhysicalProduct!
  deletePhysicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  deleteManyPhysicalProducts(where: PhysicalProductWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductFunction(data: ProductFunctionCreateInput!): ProductFunction!
  updateProductFunction(data: ProductFunctionUpdateInput!, where: ProductFunctionWhereUniqueInput!): ProductFunction
  updateManyProductFunctions(data: ProductFunctionUpdateManyMutationInput!, where: ProductFunctionWhereInput): BatchPayload!
  upsertProductFunction(where: ProductFunctionWhereUniqueInput!, create: ProductFunctionCreateInput!, update: ProductFunctionUpdateInput!): ProductFunction!
  deleteProductFunction(where: ProductFunctionWhereUniqueInput!): ProductFunction
  deleteManyProductFunctions(where: ProductFunctionWhereInput): BatchPayload!
  createProductVariant(data: ProductVariantCreateInput!): ProductVariant!
  updateProductVariant(data: ProductVariantUpdateInput!, where: ProductVariantWhereUniqueInput!): ProductVariant
  updateManyProductVariants(data: ProductVariantUpdateManyMutationInput!, where: ProductVariantWhereInput): BatchPayload!
  upsertProductVariant(where: ProductVariantWhereUniqueInput!, create: ProductVariantCreateInput!, update: ProductVariantUpdateInput!): ProductVariant!
  deleteProductVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  deleteManyProductVariants(where: ProductVariantWhereInput): BatchPayload!
  createReservation(data: ReservationCreateInput!): Reservation!
  updateReservation(data: ReservationUpdateInput!, where: ReservationWhereUniqueInput!): Reservation
  updateManyReservations(data: ReservationUpdateManyMutationInput!, where: ReservationWhereInput): BatchPayload!
  upsertReservation(where: ReservationWhereUniqueInput!, create: ReservationCreateInput!, update: ReservationUpdateInput!): Reservation!
  deleteReservation(where: ReservationWhereUniqueInput!): Reservation
  deleteManyReservations(where: ReservationWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
}

type OrderPreviousValues {
  id: ID!
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type Package {
  id: ID!
  items(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  shippingLabel: Label!
  fromAddress: Location!
  toAddress: Location!
  weight: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PackageConnection {
  pageInfo: PageInfo!
  edges: [PackageEdge]!
  aggregate: AggregatePackage!
}

input PackageCreateInput {
  id: ID
  items: PhysicalProductCreateManyInput
  shippingLabel: LabelCreateOneInput!
  fromAddress: LocationCreateOneInput!
  toAddress: LocationCreateOneInput!
  weight: Float
}

input PackageCreateOneInput {
  create: PackageCreateInput
  connect: PackageWhereUniqueInput
}

type PackageEdge {
  node: Package!
  cursor: String!
}

enum PackageOrderByInput {
  id_ASC
  id_DESC
  weight_ASC
  weight_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PackagePreviousValues {
  id: ID!
  weight: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PackageSubscriptionPayload {
  mutation: MutationType!
  node: Package
  updatedFields: [String!]
  previousValues: PackagePreviousValues
}

input PackageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PackageWhereInput
  AND: [PackageSubscriptionWhereInput!]
  OR: [PackageSubscriptionWhereInput!]
  NOT: [PackageSubscriptionWhereInput!]
}

input PackageUpdateDataInput {
  items: PhysicalProductUpdateManyInput
  shippingLabel: LabelUpdateOneRequiredInput
  fromAddress: LocationUpdateOneRequiredInput
  toAddress: LocationUpdateOneRequiredInput
  weight: Float
}

input PackageUpdateInput {
  items: PhysicalProductUpdateManyInput
  shippingLabel: LabelUpdateOneRequiredInput
  fromAddress: LocationUpdateOneRequiredInput
  toAddress: LocationUpdateOneRequiredInput
  weight: Float
}

input PackageUpdateManyMutationInput {
  weight: Float
}

input PackageUpdateOneInput {
  create: PackageCreateInput
  update: PackageUpdateDataInput
  upsert: PackageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PackageWhereUniqueInput
}

input PackageUpsertNestedInput {
  update: PackageUpdateDataInput!
  create: PackageCreateInput!
}

input PackageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  items_every: PhysicalProductWhereInput
  items_some: PhysicalProductWhereInput
  items_none: PhysicalProductWhereInput
  shippingLabel: LabelWhereInput
  fromAddress: LocationWhereInput
  toAddress: LocationWhereInput
  weight: Float
  weight_not: Float
  weight_in: [Float!]
  weight_not_in: [Float!]
  weight_lt: Float
  weight_lte: Float
  weight_gt: Float
  weight_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PackageWhereInput!]
  OR: [PackageWhereInput!]
  NOT: [PackageWhereInput!]
}

input PackageWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PhysicalProduct {
  id: ID!
  seasonsUID: String!
  location: Location!
  productVariant: ProductVariant!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhysicalProductConnection {
  pageInfo: PageInfo!
  edges: [PhysicalProductEdge]!
  aggregate: AggregatePhysicalProduct!
}

input PhysicalProductCreateInput {
  id: ID
  seasonsUID: String!
  location: LocationCreateOneWithoutPhysicalProductsInput!
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
}

input PhysicalProductCreateManyInput {
  create: [PhysicalProductCreateInput!]
  connect: [PhysicalProductWhereUniqueInput!]
}

input PhysicalProductCreateManyWithoutLocationInput {
  create: [PhysicalProductCreateWithoutLocationInput!]
  connect: [PhysicalProductWhereUniqueInput!]
}

input PhysicalProductCreateManyWithoutProductVariantInput {
  create: [PhysicalProductCreateWithoutProductVariantInput!]
  connect: [PhysicalProductWhereUniqueInput!]
}

input PhysicalProductCreateWithoutLocationInput {
  id: ID
  seasonsUID: String!
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
}

input PhysicalProductCreateWithoutProductVariantInput {
  id: ID
  seasonsUID: String!
  location: LocationCreateOneWithoutPhysicalProductsInput!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
}

type PhysicalProductEdge {
  node: PhysicalProduct!
  cursor: String!
}

enum PhysicalProductOrderByInput {
  id_ASC
  id_DESC
  seasonsUID_ASC
  seasonsUID_DESC
  inventoryStatus_ASC
  inventoryStatus_DESC
  productStatus_ASC
  productStatus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhysicalProductPreviousValues {
  id: ID!
  seasonsUID: String!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PhysicalProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seasonsUID: String
  seasonsUID_not: String
  seasonsUID_in: [String!]
  seasonsUID_not_in: [String!]
  seasonsUID_lt: String
  seasonsUID_lte: String
  seasonsUID_gt: String
  seasonsUID_gte: String
  seasonsUID_contains: String
  seasonsUID_not_contains: String
  seasonsUID_starts_with: String
  seasonsUID_not_starts_with: String
  seasonsUID_ends_with: String
  seasonsUID_not_ends_with: String
  inventoryStatus: InventoryStatus
  inventoryStatus_not: InventoryStatus
  inventoryStatus_in: [InventoryStatus!]
  inventoryStatus_not_in: [InventoryStatus!]
  productStatus: PhysicalProductStatus
  productStatus_not: PhysicalProductStatus
  productStatus_in: [PhysicalProductStatus!]
  productStatus_not_in: [PhysicalProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhysicalProductScalarWhereInput!]
  OR: [PhysicalProductScalarWhereInput!]
  NOT: [PhysicalProductScalarWhereInput!]
}

enum PhysicalProductStatus {
  New
  Used
  Damaged
  Clean
}

type PhysicalProductSubscriptionPayload {
  mutation: MutationType!
  node: PhysicalProduct
  updatedFields: [String!]
  previousValues: PhysicalProductPreviousValues
}

input PhysicalProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhysicalProductWhereInput
  AND: [PhysicalProductSubscriptionWhereInput!]
  OR: [PhysicalProductSubscriptionWhereInput!]
  NOT: [PhysicalProductSubscriptionWhereInput!]
}

input PhysicalProductUpdateDataInput {
  seasonsUID: String
  location: LocationUpdateOneRequiredWithoutPhysicalProductsInput
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateInput {
  seasonsUID: String
  location: LocationUpdateOneRequiredWithoutPhysicalProductsInput
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateManyDataInput {
  seasonsUID: String
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateManyInput {
  create: [PhysicalProductCreateInput!]
  update: [PhysicalProductUpdateWithWhereUniqueNestedInput!]
  upsert: [PhysicalProductUpsertWithWhereUniqueNestedInput!]
  delete: [PhysicalProductWhereUniqueInput!]
  connect: [PhysicalProductWhereUniqueInput!]
  set: [PhysicalProductWhereUniqueInput!]
  disconnect: [PhysicalProductWhereUniqueInput!]
  deleteMany: [PhysicalProductScalarWhereInput!]
  updateMany: [PhysicalProductUpdateManyWithWhereNestedInput!]
}

input PhysicalProductUpdateManyMutationInput {
  seasonsUID: String
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateManyWithoutLocationInput {
  create: [PhysicalProductCreateWithoutLocationInput!]
  delete: [PhysicalProductWhereUniqueInput!]
  connect: [PhysicalProductWhereUniqueInput!]
  set: [PhysicalProductWhereUniqueInput!]
  disconnect: [PhysicalProductWhereUniqueInput!]
  update: [PhysicalProductUpdateWithWhereUniqueWithoutLocationInput!]
  upsert: [PhysicalProductUpsertWithWhereUniqueWithoutLocationInput!]
  deleteMany: [PhysicalProductScalarWhereInput!]
  updateMany: [PhysicalProductUpdateManyWithWhereNestedInput!]
}

input PhysicalProductUpdateManyWithoutProductVariantInput {
  create: [PhysicalProductCreateWithoutProductVariantInput!]
  delete: [PhysicalProductWhereUniqueInput!]
  connect: [PhysicalProductWhereUniqueInput!]
  set: [PhysicalProductWhereUniqueInput!]
  disconnect: [PhysicalProductWhereUniqueInput!]
  update: [PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput!]
  upsert: [PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput!]
  deleteMany: [PhysicalProductScalarWhereInput!]
  updateMany: [PhysicalProductUpdateManyWithWhereNestedInput!]
}

input PhysicalProductUpdateManyWithWhereNestedInput {
  where: PhysicalProductScalarWhereInput!
  data: PhysicalProductUpdateManyDataInput!
}

input PhysicalProductUpdateWithoutLocationDataInput {
  seasonsUID: String
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateWithoutProductVariantDataInput {
  seasonsUID: String
  location: LocationUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput!
  data: PhysicalProductUpdateDataInput!
}

input PhysicalProductUpdateWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput!
  data: PhysicalProductUpdateWithoutLocationDataInput!
}

input PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput!
  data: PhysicalProductUpdateWithoutProductVariantDataInput!
}

input PhysicalProductUpsertWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput!
  update: PhysicalProductUpdateDataInput!
  create: PhysicalProductCreateInput!
}

input PhysicalProductUpsertWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput!
  update: PhysicalProductUpdateWithoutLocationDataInput!
  create: PhysicalProductCreateWithoutLocationInput!
}

input PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput!
  update: PhysicalProductUpdateWithoutProductVariantDataInput!
  create: PhysicalProductCreateWithoutProductVariantInput!
}

input PhysicalProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seasonsUID: String
  seasonsUID_not: String
  seasonsUID_in: [String!]
  seasonsUID_not_in: [String!]
  seasonsUID_lt: String
  seasonsUID_lte: String
  seasonsUID_gt: String
  seasonsUID_gte: String
  seasonsUID_contains: String
  seasonsUID_not_contains: String
  seasonsUID_starts_with: String
  seasonsUID_not_starts_with: String
  seasonsUID_ends_with: String
  seasonsUID_not_ends_with: String
  location: LocationWhereInput
  productVariant: ProductVariantWhereInput
  inventoryStatus: InventoryStatus
  inventoryStatus_not: InventoryStatus
  inventoryStatus_in: [InventoryStatus!]
  inventoryStatus_not_in: [InventoryStatus!]
  productStatus: PhysicalProductStatus
  productStatus_not: PhysicalProductStatus
  productStatus_in: [PhysicalProductStatus!]
  productStatus_not_in: [PhysicalProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhysicalProductWhereInput!]
  OR: [PhysicalProductWhereInput!]
  NOT: [PhysicalProductWhereInput!]
}

input PhysicalProductWhereUniqueInput {
  id: ID
  seasonsUID: String
}

enum Plan {
  AllAccess
  Essential
}

type Product {
  id: ID!
  slug: String!
  name: String!
  brand: Brand!
  category: Category!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: Color!
  secondaryColor: Color
  tags: Json
  functions(where: ProductFunctionWhereInput, orderBy: ProductFunctionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductFunction!]
  availableSizes: [Size!]!
  innerMaterials: [Material!]!
  outerMaterials: [Material!]!
  variants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
  status: ProductStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateavailableSizesInput {
  set: [Size!]
}

input ProductCreateinnerMaterialsInput {
  set: [Material!]
}

input ProductCreateInput {
  id: ID
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  category: CategoryCreateOneWithoutProductsInput!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorCreateOneInput!
  secondaryColor: ColorCreateOneInput
  tags: Json
  functions: ProductFunctionCreateManyInput
  availableSizes: ProductCreateavailableSizesInput
  innerMaterials: ProductCreateinnerMaterialsInput
  outerMaterials: ProductCreateouterMaterialsInput
  variants: ProductVariantCreateManyWithoutProductInput
  status: ProductStatus
}

input ProductCreateManyInput {
  create: [ProductCreateInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneWithoutVariantsInput {
  create: ProductCreateWithoutVariantsInput
  connect: ProductWhereUniqueInput
}

input ProductCreateouterMaterialsInput {
  set: [Material!]
}

input ProductCreateWithoutBrandInput {
  id: ID
  slug: String!
  name: String!
  category: CategoryCreateOneWithoutProductsInput!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorCreateOneInput!
  secondaryColor: ColorCreateOneInput
  tags: Json
  functions: ProductFunctionCreateManyInput
  availableSizes: ProductCreateavailableSizesInput
  innerMaterials: ProductCreateinnerMaterialsInput
  outerMaterials: ProductCreateouterMaterialsInput
  variants: ProductVariantCreateManyWithoutProductInput
  status: ProductStatus
}

input ProductCreateWithoutCategoryInput {
  id: ID
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorCreateOneInput!
  secondaryColor: ColorCreateOneInput
  tags: Json
  functions: ProductFunctionCreateManyInput
  availableSizes: ProductCreateavailableSizesInput
  innerMaterials: ProductCreateinnerMaterialsInput
  outerMaterials: ProductCreateouterMaterialsInput
  variants: ProductVariantCreateManyWithoutProductInput
  status: ProductStatus
}

input ProductCreateWithoutVariantsInput {
  id: ID
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  category: CategoryCreateOneWithoutProductsInput!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorCreateOneInput!
  secondaryColor: ColorCreateOneInput
  tags: Json
  functions: ProductFunctionCreateManyInput
  availableSizes: ProductCreateavailableSizesInput
  innerMaterials: ProductCreateinnerMaterialsInput
  outerMaterials: ProductCreateouterMaterialsInput
  status: ProductStatus
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type ProductFunction {
  id: ID!
  name: String
}

type ProductFunctionConnection {
  pageInfo: PageInfo!
  edges: [ProductFunctionEdge]!
  aggregate: AggregateProductFunction!
}

input ProductFunctionCreateInput {
  id: ID
  name: String
}

input ProductFunctionCreateManyInput {
  create: [ProductFunctionCreateInput!]
  connect: [ProductFunctionWhereUniqueInput!]
}

type ProductFunctionEdge {
  node: ProductFunction!
  cursor: String!
}

enum ProductFunctionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ProductFunctionPreviousValues {
  id: ID!
  name: String
}

input ProductFunctionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ProductFunctionScalarWhereInput!]
  OR: [ProductFunctionScalarWhereInput!]
  NOT: [ProductFunctionScalarWhereInput!]
}

type ProductFunctionSubscriptionPayload {
  mutation: MutationType!
  node: ProductFunction
  updatedFields: [String!]
  previousValues: ProductFunctionPreviousValues
}

input ProductFunctionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductFunctionWhereInput
  AND: [ProductFunctionSubscriptionWhereInput!]
  OR: [ProductFunctionSubscriptionWhereInput!]
  NOT: [ProductFunctionSubscriptionWhereInput!]
}

input ProductFunctionUpdateDataInput {
  name: String
}

input ProductFunctionUpdateInput {
  name: String
}

input ProductFunctionUpdateManyDataInput {
  name: String
}

input ProductFunctionUpdateManyInput {
  create: [ProductFunctionCreateInput!]
  update: [ProductFunctionUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductFunctionUpsertWithWhereUniqueNestedInput!]
  delete: [ProductFunctionWhereUniqueInput!]
  connect: [ProductFunctionWhereUniqueInput!]
  set: [ProductFunctionWhereUniqueInput!]
  disconnect: [ProductFunctionWhereUniqueInput!]
  deleteMany: [ProductFunctionScalarWhereInput!]
  updateMany: [ProductFunctionUpdateManyWithWhereNestedInput!]
}

input ProductFunctionUpdateManyMutationInput {
  name: String
}

input ProductFunctionUpdateManyWithWhereNestedInput {
  where: ProductFunctionScalarWhereInput!
  data: ProductFunctionUpdateManyDataInput!
}

input ProductFunctionUpdateWithWhereUniqueNestedInput {
  where: ProductFunctionWhereUniqueInput!
  data: ProductFunctionUpdateDataInput!
}

input ProductFunctionUpsertWithWhereUniqueNestedInput {
  where: ProductFunctionWhereUniqueInput!
  update: ProductFunctionUpdateDataInput!
  create: ProductFunctionCreateInput!
}

input ProductFunctionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ProductFunctionWhereInput!]
  OR: [ProductFunctionWhereInput!]
  NOT: [ProductFunctionWhereInput!]
}

input ProductFunctionWhereUniqueInput {
  id: ID
  name: String
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  externalURL_ASC
  externalURL_DESC
  images_ASC
  images_DESC
  modelHeight_ASC
  modelHeight_DESC
  modelSize_ASC
  modelSize_DESC
  retailPrice_ASC
  retailPrice_DESC
  tags_ASC
  tags_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  slug: String!
  name: String!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  tags: Json
  availableSizes: [Size!]!
  innerMaterials: [Material!]!
  outerMaterials: [Material!]!
  status: ProductStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  externalURL: String
  externalURL_not: String
  externalURL_in: [String!]
  externalURL_not_in: [String!]
  externalURL_lt: String
  externalURL_lte: String
  externalURL_gt: String
  externalURL_gte: String
  externalURL_contains: String
  externalURL_not_contains: String
  externalURL_starts_with: String
  externalURL_not_starts_with: String
  externalURL_ends_with: String
  externalURL_not_ends_with: String
  modelHeight: Int
  modelHeight_not: Int
  modelHeight_in: [Int!]
  modelHeight_not_in: [Int!]
  modelHeight_lt: Int
  modelHeight_lte: Int
  modelHeight_gt: Int
  modelHeight_gte: Int
  modelSize: Size
  modelSize_not: Size
  modelSize_in: [Size!]
  modelSize_not_in: [Size!]
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  status: ProductStatus
  status_not: ProductStatus
  status_in: [ProductStatus!]
  status_not_in: [ProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

enum ProductStatus {
  Available
  NotAvailable
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateavailableSizesInput {
  set: [Size!]
}

input ProductUpdateDataInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductFunctionUpdateManyInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  variants: ProductVariantUpdateManyWithoutProductInput
  status: ProductStatus
}

input ProductUpdateinnerMaterialsInput {
  set: [Material!]
}

input ProductUpdateInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductFunctionUpdateManyInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  variants: ProductVariantUpdateManyWithoutProductInput
  status: ProductStatus
}

input ProductUpdateManyDataInput {
  slug: String
  name: String
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  tags: Json
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateManyInput {
  create: [ProductCreateInput!]
  update: [ProductUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductUpsertWithWhereUniqueNestedInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyMutationInput {
  slug: String
  name: String
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  tags: Json
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutBrandInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutBrandInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateOneRequiredWithoutVariantsInput {
  create: ProductCreateWithoutVariantsInput
  update: ProductUpdateWithoutVariantsDataInput
  upsert: ProductUpsertWithoutVariantsInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateouterMaterialsInput {
  set: [Material!]
}

input ProductUpdateWithoutBrandDataInput {
  slug: String
  name: String
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductFunctionUpdateManyInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  variants: ProductVariantUpdateManyWithoutProductInput
  status: ProductStatus
}

input ProductUpdateWithoutCategoryDataInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductFunctionUpdateManyInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  variants: ProductVariantUpdateManyWithoutProductInput
  status: ProductStatus
}

input ProductUpdateWithoutVariantsDataInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductFunctionUpdateManyInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateDataInput!
}

input ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutBrandDataInput!
}

input ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCategoryDataInput!
}

input ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput!
  create: ProductCreateWithoutVariantsInput!
}

input ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutBrandDataInput!
  create: ProductCreateWithoutBrandInput!
}

input ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCategoryDataInput!
  create: ProductCreateWithoutCategoryInput!
}

type ProductVariant {
  id: ID!
  sku: String
  color: Color!
  size: Size!
  weight: Float
  height: Float
  productID: String!
  product: Product!
  retailPrice: Float
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductVariantConnection {
  pageInfo: PageInfo!
  edges: [ProductVariantEdge]!
  aggregate: AggregateProductVariant!
}

input ProductVariantCreateInput {
  id: ID
  sku: String
  color: ColorCreateOneWithoutProductVariantsInput!
  size: Size!
  weight: Float
  height: Float
  productID: String!
  product: ProductCreateOneWithoutVariantsInput!
  retailPrice: Float
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

input ProductVariantCreateManyWithoutColorInput {
  create: [ProductVariantCreateWithoutColorInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateManyWithoutProductInput {
  create: [ProductVariantCreateWithoutProductInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateOneInput {
  create: ProductVariantCreateInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantCreateOneWithoutPhysicalProductsInput {
  create: ProductVariantCreateWithoutPhysicalProductsInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantCreateWithoutColorInput {
  id: ID
  sku: String
  size: Size!
  weight: Float
  height: Float
  productID: String!
  product: ProductCreateOneWithoutVariantsInput!
  retailPrice: Float
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

input ProductVariantCreateWithoutPhysicalProductsInput {
  id: ID
  sku: String
  color: ColorCreateOneWithoutProductVariantsInput!
  size: Size!
  weight: Float
  height: Float
  productID: String!
  product: ProductCreateOneWithoutVariantsInput!
  retailPrice: Float
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

input ProductVariantCreateWithoutProductInput {
  id: ID
  sku: String
  color: ColorCreateOneWithoutProductVariantsInput!
  size: Size!
  weight: Float
  height: Float
  productID: String!
  retailPrice: Float
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

type ProductVariantEdge {
  node: ProductVariant!
  cursor: String!
}

enum ProductVariantOrderByInput {
  id_ASC
  id_DESC
  sku_ASC
  sku_DESC
  size_ASC
  size_DESC
  weight_ASC
  weight_DESC
  height_ASC
  height_DESC
  productID_ASC
  productID_DESC
  retailPrice_ASC
  retailPrice_DESC
  total_ASC
  total_DESC
  reservable_ASC
  reservable_DESC
  reserved_ASC
  reserved_DESC
  nonReservable_ASC
  nonReservable_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductVariantPreviousValues {
  id: ID!
  sku: String
  size: Size!
  weight: Float
  height: Float
  productID: String!
  retailPrice: Float
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductVariantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  size: Size
  size_not: Size
  size_in: [Size!]
  size_not_in: [Size!]
  weight: Float
  weight_not: Float
  weight_in: [Float!]
  weight_not_in: [Float!]
  weight_lt: Float
  weight_lte: Float
  weight_gt: Float
  weight_gte: Float
  height: Float
  height_not: Float
  height_in: [Float!]
  height_not_in: [Float!]
  height_lt: Float
  height_lte: Float
  height_gt: Float
  height_gte: Float
  productID: String
  productID_not: String
  productID_in: [String!]
  productID_not_in: [String!]
  productID_lt: String
  productID_lte: String
  productID_gt: String
  productID_gte: String
  productID_contains: String
  productID_not_contains: String
  productID_starts_with: String
  productID_not_starts_with: String
  productID_ends_with: String
  productID_not_ends_with: String
  retailPrice: Float
  retailPrice_not: Float
  retailPrice_in: [Float!]
  retailPrice_not_in: [Float!]
  retailPrice_lt: Float
  retailPrice_lte: Float
  retailPrice_gt: Float
  retailPrice_gte: Float
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  reservable: Int
  reservable_not: Int
  reservable_in: [Int!]
  reservable_not_in: [Int!]
  reservable_lt: Int
  reservable_lte: Int
  reservable_gt: Int
  reservable_gte: Int
  reserved: Int
  reserved_not: Int
  reserved_in: [Int!]
  reserved_not_in: [Int!]
  reserved_lt: Int
  reserved_lte: Int
  reserved_gt: Int
  reserved_gte: Int
  nonReservable: Int
  nonReservable_not: Int
  nonReservable_in: [Int!]
  nonReservable_not_in: [Int!]
  nonReservable_lt: Int
  nonReservable_lte: Int
  nonReservable_gt: Int
  nonReservable_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantScalarWhereInput!]
  OR: [ProductVariantScalarWhereInput!]
  NOT: [ProductVariantScalarWhereInput!]
}

type ProductVariantSubscriptionPayload {
  mutation: MutationType!
  node: ProductVariant
  updatedFields: [String!]
  previousValues: ProductVariantPreviousValues
}

input ProductVariantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductVariantWhereInput
  AND: [ProductVariantSubscriptionWhereInput!]
  OR: [ProductVariantSubscriptionWhereInput!]
  NOT: [ProductVariantSubscriptionWhereInput!]
}

input ProductVariantUpdateDataInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  size: Size
  weight: Float
  height: Float
  productID: String
  product: ProductUpdateOneRequiredWithoutVariantsInput
  retailPrice: Float
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input ProductVariantUpdateInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  size: Size
  weight: Float
  height: Float
  productID: String
  product: ProductUpdateOneRequiredWithoutVariantsInput
  retailPrice: Float
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input ProductVariantUpdateManyDataInput {
  sku: String
  size: Size
  weight: Float
  height: Float
  productID: String
  retailPrice: Float
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input ProductVariantUpdateManyMutationInput {
  sku: String
  size: Size
  weight: Float
  height: Float
  productID: String
  retailPrice: Float
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input ProductVariantUpdateManyWithoutColorInput {
  create: [ProductVariantCreateWithoutColorInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  update: [ProductVariantUpdateWithWhereUniqueWithoutColorInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueWithoutColorInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyWithoutProductInput {
  create: [ProductVariantCreateWithoutProductInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  update: [ProductVariantUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyWithWhereNestedInput {
  where: ProductVariantScalarWhereInput!
  data: ProductVariantUpdateManyDataInput!
}

input ProductVariantUpdateOneRequiredInput {
  create: ProductVariantCreateInput
  update: ProductVariantUpdateDataInput
  upsert: ProductVariantUpsertNestedInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput {
  create: ProductVariantCreateWithoutPhysicalProductsInput
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput
  upsert: ProductVariantUpsertWithoutPhysicalProductsInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantUpdateWithoutColorDataInput {
  sku: String
  size: Size
  weight: Float
  height: Float
  productID: String
  product: ProductUpdateOneRequiredWithoutVariantsInput
  retailPrice: Float
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input ProductVariantUpdateWithoutPhysicalProductsDataInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  size: Size
  weight: Float
  height: Float
  productID: String
  product: ProductUpdateOneRequiredWithoutVariantsInput
  retailPrice: Float
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input ProductVariantUpdateWithoutProductDataInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  size: Size
  weight: Float
  height: Float
  productID: String
  retailPrice: Float
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input ProductVariantUpdateWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateWithoutColorDataInput!
}

input ProductVariantUpdateWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateWithoutProductDataInput!
}

input ProductVariantUpsertNestedInput {
  update: ProductVariantUpdateDataInput!
  create: ProductVariantCreateInput!
}

input ProductVariantUpsertWithoutPhysicalProductsInput {
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput!
  create: ProductVariantCreateWithoutPhysicalProductsInput!
}

input ProductVariantUpsertWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateWithoutColorDataInput!
  create: ProductVariantCreateWithoutColorInput!
}

input ProductVariantUpsertWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateWithoutProductDataInput!
  create: ProductVariantCreateWithoutProductInput!
}

input ProductVariantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  color: ColorWhereInput
  size: Size
  size_not: Size
  size_in: [Size!]
  size_not_in: [Size!]
  weight: Float
  weight_not: Float
  weight_in: [Float!]
  weight_not_in: [Float!]
  weight_lt: Float
  weight_lte: Float
  weight_gt: Float
  weight_gte: Float
  height: Float
  height_not: Float
  height_in: [Float!]
  height_not_in: [Float!]
  height_lt: Float
  height_lte: Float
  height_gt: Float
  height_gte: Float
  productID: String
  productID_not: String
  productID_in: [String!]
  productID_not_in: [String!]
  productID_lt: String
  productID_lte: String
  productID_gt: String
  productID_gte: String
  productID_contains: String
  productID_not_contains: String
  productID_starts_with: String
  productID_not_starts_with: String
  productID_ends_with: String
  productID_not_ends_with: String
  product: ProductWhereInput
  retailPrice: Float
  retailPrice_not: Float
  retailPrice_in: [Float!]
  retailPrice_not_in: [Float!]
  retailPrice_lt: Float
  retailPrice_lte: Float
  retailPrice_gt: Float
  retailPrice_gte: Float
  physicalProducts_every: PhysicalProductWhereInput
  physicalProducts_some: PhysicalProductWhereInput
  physicalProducts_none: PhysicalProductWhereInput
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  reservable: Int
  reservable_not: Int
  reservable_in: [Int!]
  reservable_not_in: [Int!]
  reservable_lt: Int
  reservable_lte: Int
  reservable_gt: Int
  reservable_gte: Int
  reserved: Int
  reserved_not: Int
  reserved_in: [Int!]
  reserved_not_in: [Int!]
  reserved_lt: Int
  reserved_lte: Int
  reserved_gt: Int
  reserved_gte: Int
  nonReservable: Int
  nonReservable_not: Int
  nonReservable_in: [Int!]
  nonReservable_not_in: [Int!]
  nonReservable_lt: Int
  nonReservable_lte: Int
  nonReservable_gt: Int
  nonReservable_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantWhereInput!]
  OR: [ProductVariantWhereInput!]
  NOT: [ProductVariantWhereInput!]
}

input ProductVariantWhereUniqueInput {
  id: ID
  sku: String
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  brand: BrandWhereInput
  category: CategoryWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  externalURL: String
  externalURL_not: String
  externalURL_in: [String!]
  externalURL_not_in: [String!]
  externalURL_lt: String
  externalURL_lte: String
  externalURL_gt: String
  externalURL_gte: String
  externalURL_contains: String
  externalURL_not_contains: String
  externalURL_starts_with: String
  externalURL_not_starts_with: String
  externalURL_ends_with: String
  externalURL_not_ends_with: String
  modelHeight: Int
  modelHeight_not: Int
  modelHeight_in: [Int!]
  modelHeight_not_in: [Int!]
  modelHeight_lt: Int
  modelHeight_lte: Int
  modelHeight_gt: Int
  modelHeight_gte: Int
  modelSize: Size
  modelSize_not: Size
  modelSize_in: [Size!]
  modelSize_not_in: [Size!]
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  color: ColorWhereInput
  secondaryColor: ColorWhereInput
  functions_every: ProductFunctionWhereInput
  functions_some: ProductFunctionWhereInput
  functions_none: ProductFunctionWhereInput
  variants_every: ProductVariantWhereInput
  variants_some: ProductVariantWhereInput
  variants_none: ProductVariantWhereInput
  status: ProductStatus
  status_not: ProductStatus
  status_in: [ProductStatus!]
  status_not_in: [ProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
  slug: String
}

type Query {
  bagItem(where: BagItemWhereUniqueInput!): BagItem
  bagItems(where: BagItemWhereInput, orderBy: BagItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BagItem]!
  bagItemsConnection(where: BagItemWhereInput, orderBy: BagItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BagItemConnection!
  billingInfo(where: BillingInfoWhereUniqueInput!): BillingInfo
  billingInfoes(where: BillingInfoWhereInput, orderBy: BillingInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BillingInfo]!
  billingInfoesConnection(where: BillingInfoWhereInput, orderBy: BillingInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BillingInfoConnection!
  brand(where: BrandWhereUniqueInput!): Brand
  brands(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Brand]!
  brandsConnection(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BrandConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  collection(where: CollectionWhereUniqueInput!): Collection
  collections(where: CollectionWhereInput, orderBy: CollectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Collection]!
  collectionsConnection(where: CollectionWhereInput, orderBy: CollectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CollectionConnection!
  collectionGroup(where: CollectionGroupWhereUniqueInput!): CollectionGroup
  collectionGroups(where: CollectionGroupWhereInput, orderBy: CollectionGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CollectionGroup]!
  collectionGroupsConnection(where: CollectionGroupWhereInput, orderBy: CollectionGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CollectionGroupConnection!
  color(where: ColorWhereUniqueInput!): Color
  colors(where: ColorWhereInput, orderBy: ColorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Color]!
  colorsConnection(where: ColorWhereInput, orderBy: ColorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ColorConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  customerDetail(where: CustomerDetailWhereUniqueInput!): CustomerDetail
  customerDetails(where: CustomerDetailWhereInput, orderBy: CustomerDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CustomerDetail]!
  customerDetailsConnection(where: CustomerDetailWhereInput, orderBy: CustomerDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerDetailConnection!
  homepageProductRail(where: HomepageProductRailWhereUniqueInput!): HomepageProductRail
  homepageProductRails(where: HomepageProductRailWhereInput, orderBy: HomepageProductRailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HomepageProductRail]!
  homepageProductRailsConnection(where: HomepageProductRailWhereInput, orderBy: HomepageProductRailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HomepageProductRailConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  label(where: LabelWhereUniqueInput!): Label
  labels(where: LabelWhereInput, orderBy: LabelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Label]!
  labelsConnection(where: LabelWhereInput, orderBy: LabelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LabelConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  package(where: PackageWhereUniqueInput!): Package
  packages(where: PackageWhereInput, orderBy: PackageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Package]!
  packagesConnection(where: PackageWhereInput, orderBy: PackageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PackageConnection!
  physicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct]!
  physicalProductsConnection(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhysicalProductConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productFunction(where: ProductFunctionWhereUniqueInput!): ProductFunction
  productFunctions(where: ProductFunctionWhereInput, orderBy: ProductFunctionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductFunction]!
  productFunctionsConnection(where: ProductFunctionWhereInput, orderBy: ProductFunctionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductFunctionConnection!
  productVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant]!
  productVariantsConnection(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductVariantConnection!
  reservation(where: ReservationWhereUniqueInput!): Reservation
  reservations(where: ReservationWhereInput, orderBy: ReservationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reservation]!
  reservationsConnection(where: ReservationWhereInput, orderBy: ReservationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReservationConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Reservation {
  id: ID!
  user: User!
  customer: Customer!
  sentPackage: Package
  returnedPackage: Package
  location: Location
  products(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  reservationNumber: Int!
  shipped: Boolean!
  status: ReservationStatus!
  shippedAt: DateTime
  receivedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReservationConnection {
  pageInfo: PageInfo!
  edges: [ReservationEdge]!
  aggregate: AggregateReservation!
}

input ReservationCreateInput {
  id: ID
  user: UserCreateOneInput!
  customer: CustomerCreateOneWithoutReservationsInput!
  sentPackage: PackageCreateOneInput
  returnedPackage: PackageCreateOneInput
  location: LocationCreateOneInput
  products: PhysicalProductCreateManyInput
  reservationNumber: Int!
  shipped: Boolean!
  status: ReservationStatus!
  shippedAt: DateTime
  receivedAt: DateTime
}

input ReservationCreateManyWithoutCustomerInput {
  create: [ReservationCreateWithoutCustomerInput!]
  connect: [ReservationWhereUniqueInput!]
}

input ReservationCreateWithoutCustomerInput {
  id: ID
  user: UserCreateOneInput!
  sentPackage: PackageCreateOneInput
  returnedPackage: PackageCreateOneInput
  location: LocationCreateOneInput
  products: PhysicalProductCreateManyInput
  reservationNumber: Int!
  shipped: Boolean!
  status: ReservationStatus!
  shippedAt: DateTime
  receivedAt: DateTime
}

type ReservationEdge {
  node: Reservation!
  cursor: String!
}

enum ReservationOrderByInput {
  id_ASC
  id_DESC
  reservationNumber_ASC
  reservationNumber_DESC
  shipped_ASC
  shipped_DESC
  status_ASC
  status_DESC
  shippedAt_ASC
  shippedAt_DESC
  receivedAt_ASC
  receivedAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReservationPreviousValues {
  id: ID!
  reservationNumber: Int!
  shipped: Boolean!
  status: ReservationStatus!
  shippedAt: DateTime
  receivedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ReservationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reservationNumber: Int
  reservationNumber_not: Int
  reservationNumber_in: [Int!]
  reservationNumber_not_in: [Int!]
  reservationNumber_lt: Int
  reservationNumber_lte: Int
  reservationNumber_gt: Int
  reservationNumber_gte: Int
  shipped: Boolean
  shipped_not: Boolean
  status: ReservationStatus
  status_not: ReservationStatus
  status_in: [ReservationStatus!]
  status_not_in: [ReservationStatus!]
  shippedAt: DateTime
  shippedAt_not: DateTime
  shippedAt_in: [DateTime!]
  shippedAt_not_in: [DateTime!]
  shippedAt_lt: DateTime
  shippedAt_lte: DateTime
  shippedAt_gt: DateTime
  shippedAt_gte: DateTime
  receivedAt: DateTime
  receivedAt_not: DateTime
  receivedAt_in: [DateTime!]
  receivedAt_not_in: [DateTime!]
  receivedAt_lt: DateTime
  receivedAt_lte: DateTime
  receivedAt_gt: DateTime
  receivedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReservationScalarWhereInput!]
  OR: [ReservationScalarWhereInput!]
  NOT: [ReservationScalarWhereInput!]
}

enum ReservationStatus {
  New
  InQueue
  OnHold
  Packed
  Shipped
  InTransit
  Received
  Cancelled
  Completed
}

type ReservationSubscriptionPayload {
  mutation: MutationType!
  node: Reservation
  updatedFields: [String!]
  previousValues: ReservationPreviousValues
}

input ReservationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReservationWhereInput
  AND: [ReservationSubscriptionWhereInput!]
  OR: [ReservationSubscriptionWhereInput!]
  NOT: [ReservationSubscriptionWhereInput!]
}

input ReservationUpdateInput {
  user: UserUpdateOneRequiredInput
  customer: CustomerUpdateOneRequiredWithoutReservationsInput
  sentPackage: PackageUpdateOneInput
  returnedPackage: PackageUpdateOneInput
  location: LocationUpdateOneInput
  products: PhysicalProductUpdateManyInput
  reservationNumber: Int
  shipped: Boolean
  status: ReservationStatus
  shippedAt: DateTime
  receivedAt: DateTime
}

input ReservationUpdateManyDataInput {
  reservationNumber: Int
  shipped: Boolean
  status: ReservationStatus
  shippedAt: DateTime
  receivedAt: DateTime
}

input ReservationUpdateManyMutationInput {
  reservationNumber: Int
  shipped: Boolean
  status: ReservationStatus
  shippedAt: DateTime
  receivedAt: DateTime
}

input ReservationUpdateManyWithoutCustomerInput {
  create: [ReservationCreateWithoutCustomerInput!]
  delete: [ReservationWhereUniqueInput!]
  connect: [ReservationWhereUniqueInput!]
  set: [ReservationWhereUniqueInput!]
  disconnect: [ReservationWhereUniqueInput!]
  update: [ReservationUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [ReservationUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [ReservationScalarWhereInput!]
  updateMany: [ReservationUpdateManyWithWhereNestedInput!]
}

input ReservationUpdateManyWithWhereNestedInput {
  where: ReservationScalarWhereInput!
  data: ReservationUpdateManyDataInput!
}

input ReservationUpdateWithoutCustomerDataInput {
  user: UserUpdateOneRequiredInput
  sentPackage: PackageUpdateOneInput
  returnedPackage: PackageUpdateOneInput
  location: LocationUpdateOneInput
  products: PhysicalProductUpdateManyInput
  reservationNumber: Int
  shipped: Boolean
  status: ReservationStatus
  shippedAt: DateTime
  receivedAt: DateTime
}

input ReservationUpdateWithWhereUniqueWithoutCustomerInput {
  where: ReservationWhereUniqueInput!
  data: ReservationUpdateWithoutCustomerDataInput!
}

input ReservationUpsertWithWhereUniqueWithoutCustomerInput {
  where: ReservationWhereUniqueInput!
  update: ReservationUpdateWithoutCustomerDataInput!
  create: ReservationCreateWithoutCustomerInput!
}

input ReservationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  customer: CustomerWhereInput
  sentPackage: PackageWhereInput
  returnedPackage: PackageWhereInput
  location: LocationWhereInput
  products_every: PhysicalProductWhereInput
  products_some: PhysicalProductWhereInput
  products_none: PhysicalProductWhereInput
  reservationNumber: Int
  reservationNumber_not: Int
  reservationNumber_in: [Int!]
  reservationNumber_not_in: [Int!]
  reservationNumber_lt: Int
  reservationNumber_lte: Int
  reservationNumber_gt: Int
  reservationNumber_gte: Int
  shipped: Boolean
  shipped_not: Boolean
  status: ReservationStatus
  status_not: ReservationStatus
  status_in: [ReservationStatus!]
  status_not_in: [ReservationStatus!]
  shippedAt: DateTime
  shippedAt_not: DateTime
  shippedAt_in: [DateTime!]
  shippedAt_not_in: [DateTime!]
  shippedAt_lt: DateTime
  shippedAt_lte: DateTime
  shippedAt_gt: DateTime
  shippedAt_gte: DateTime
  receivedAt: DateTime
  receivedAt_not: DateTime
  receivedAt_in: [DateTime!]
  receivedAt_not_in: [DateTime!]
  receivedAt_lt: DateTime
  receivedAt_lte: DateTime
  receivedAt_gt: DateTime
  receivedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReservationWhereInput!]
  OR: [ReservationWhereInput!]
  NOT: [ReservationWhereInput!]
}

input ReservationWhereUniqueInput {
  id: ID
  reservationNumber: Int
}

enum Size {
  XS
  S
  M
  L
  XL
}

type Subscription {
  bagItem(where: BagItemSubscriptionWhereInput): BagItemSubscriptionPayload
  billingInfo(where: BillingInfoSubscriptionWhereInput): BillingInfoSubscriptionPayload
  brand(where: BrandSubscriptionWhereInput): BrandSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  collection(where: CollectionSubscriptionWhereInput): CollectionSubscriptionPayload
  collectionGroup(where: CollectionGroupSubscriptionWhereInput): CollectionGroupSubscriptionPayload
  color(where: ColorSubscriptionWhereInput): ColorSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  customerDetail(where: CustomerDetailSubscriptionWhereInput): CustomerDetailSubscriptionPayload
  homepageProductRail(where: HomepageProductRailSubscriptionWhereInput): HomepageProductRailSubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  label(where: LabelSubscriptionWhereInput): LabelSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  package(where: PackageSubscriptionWhereInput): PackageSubscriptionPayload
  physicalProduct(where: PhysicalProductSubscriptionWhereInput): PhysicalProductSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productFunction(where: ProductFunctionSubscriptionWhereInput): ProductFunctionSubscriptionPayload
  productVariant(where: ProductVariantSubscriptionWhereInput): ProductVariantSubscriptionPayload
  reservation(where: ReservationSubscriptionWhereInput): ReservationSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  auth0Id: String!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  auth0Id: String!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  auth0Id_ASC
  auth0Id_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  auth0Id: String!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum UserRole {
  Admin
  Customer
  Partner
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  auth0Id: String
  email: String
  firstName: String
  lastName: String
  role: UserRole
}

input UserUpdateInput {
  auth0Id: String
  email: String
  firstName: String
  lastName: String
  role: UserRole
}

input UserUpdateManyMutationInput {
  auth0Id: String
  email: String
  firstName: String
  lastName: String
  role: UserRole
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  auth0Id: String
  auth0Id_not: String
  auth0Id_in: [String!]
  auth0Id_not_in: [String!]
  auth0Id_lt: String
  auth0Id_lte: String
  auth0Id_gt: String
  auth0Id_gte: String
  auth0Id_contains: String
  auth0Id_not_contains: String
  auth0Id_starts_with: String
  auth0Id_not_starts_with: String
  auth0Id_ends_with: String
  auth0Id_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  auth0Id: String
  email: String
}
`