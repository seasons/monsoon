// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBag {
  count: Int!
}

type AggregateBrand {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateColor {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateCustomerDetail {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateInventoryLevel {
  count: Int!
}

type AggregateLabel {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePhysicalProduct {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductVariant {
  count: Int!
}

type AggregateReservation {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Bag {
  id: ID!
  items(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
  customer: Customer!
}

type BagConnection {
  pageInfo: PageInfo!
  edges: [BagEdge]!
  aggregate: AggregateBag!
}

input BagCreateInput {
  id: ID
  items: ProductVariantCreateManyInput
  customer: CustomerCreateOneWithoutBagInput!
}

input BagCreateOneWithoutCustomerInput {
  create: BagCreateWithoutCustomerInput
  connect: BagWhereUniqueInput
}

input BagCreateWithoutCustomerInput {
  id: ID
  items: ProductVariantCreateManyInput
}

type BagEdge {
  node: Bag!
  cursor: String!
}

enum BagOrderByInput {
  id_ASC
  id_DESC
}

type BagPreviousValues {
  id: ID!
}

type BagSubscriptionPayload {
  mutation: MutationType!
  node: Bag
  updatedFields: [String!]
  previousValues: BagPreviousValues
}

input BagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BagWhereInput
  AND: [BagSubscriptionWhereInput!]
  OR: [BagSubscriptionWhereInput!]
  NOT: [BagSubscriptionWhereInput!]
}

input BagUpdateInput {
  items: ProductVariantUpdateManyInput
  customer: CustomerUpdateOneRequiredWithoutBagInput
}

input BagUpdateOneRequiredWithoutCustomerInput {
  create: BagCreateWithoutCustomerInput
  update: BagUpdateWithoutCustomerDataInput
  upsert: BagUpsertWithoutCustomerInput
  connect: BagWhereUniqueInput
}

input BagUpdateWithoutCustomerDataInput {
  items: ProductVariantUpdateManyInput
}

input BagUpsertWithoutCustomerInput {
  update: BagUpdateWithoutCustomerDataInput!
  create: BagCreateWithoutCustomerInput!
}

input BagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  items_every: ProductVariantWhereInput
  items_some: ProductVariantWhereInput
  items_none: ProductVariantWhereInput
  customer: CustomerWhereInput
  AND: [BagWhereInput!]
  OR: [BagWhereInput!]
  NOT: [BagWhereInput!]
}

input BagWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Brand {
  id: ID!
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrandConnection {
  pageInfo: PageInfo!
  edges: [BrandEdge]!
  aggregate: AggregateBrand!
}

input BrandCreateInput {
  id: ID
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  products: ProductCreateManyWithoutBrandInput
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
}

input BrandCreateOneWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandCreateWithoutProductsInput {
  id: ID
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
}

type BrandEdge {
  node: Brand!
  cursor: String!
}

enum BrandOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  brandCode_ASC
  brandCode_DESC
  description_ASC
  description_DESC
  isPrimaryBrand_ASC
  isPrimaryBrand_DESC
  logo_ASC
  logo_DESC
  name_ASC
  name_DESC
  since_ASC
  since_DESC
  tier_ASC
  tier_DESC
  websiteUrl_ASC
  websiteUrl_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BrandPreviousValues {
  id: ID!
  slug: String!
  brandCode: String!
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String!
  since: DateTime
  tier: BrandTier!
  websiteUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrandSubscriptionPayload {
  mutation: MutationType!
  node: Brand
  updatedFields: [String!]
  previousValues: BrandPreviousValues
}

input BrandSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BrandWhereInput
  AND: [BrandSubscriptionWhereInput!]
  OR: [BrandSubscriptionWhereInput!]
  NOT: [BrandSubscriptionWhereInput!]
}

enum BrandTier {
  Tier0
  Tier1
  Tier2
  Niche
  Upcoming
  Retro
  Boutique
  Local
}

input BrandUpdateInput {
  slug: String
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  products: ProductUpdateManyWithoutBrandInput
  since: DateTime
  tier: BrandTier
  websiteUrl: String
}

input BrandUpdateManyMutationInput {
  slug: String
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  since: DateTime
  tier: BrandTier
  websiteUrl: String
}

input BrandUpdateOneRequiredWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  update: BrandUpdateWithoutProductsDataInput
  upsert: BrandUpsertWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandUpdateWithoutProductsDataInput {
  slug: String
  brandCode: String
  description: String
  isPrimaryBrand: Boolean
  logo: Json
  name: String
  since: DateTime
  tier: BrandTier
  websiteUrl: String
}

input BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput!
  create: BrandCreateWithoutProductsInput!
}

input BrandWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  brandCode: String
  brandCode_not: String
  brandCode_in: [String!]
  brandCode_not_in: [String!]
  brandCode_lt: String
  brandCode_lte: String
  brandCode_gt: String
  brandCode_gte: String
  brandCode_contains: String
  brandCode_not_contains: String
  brandCode_starts_with: String
  brandCode_not_starts_with: String
  brandCode_ends_with: String
  brandCode_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isPrimaryBrand: Boolean
  isPrimaryBrand_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  since: DateTime
  since_not: DateTime
  since_in: [DateTime!]
  since_not_in: [DateTime!]
  since_lt: DateTime
  since_lte: DateTime
  since_gt: DateTime
  since_gte: DateTime
  tier: BrandTier
  tier_not: BrandTier
  tier_in: [BrandTier!]
  tier_not_in: [BrandTier!]
  websiteUrl: String
  websiteUrl_not: String
  websiteUrl_in: [String!]
  websiteUrl_not_in: [String!]
  websiteUrl_lt: String
  websiteUrl_lte: String
  websiteUrl_gt: String
  websiteUrl_gte: String
  websiteUrl_contains: String
  websiteUrl_not_contains: String
  websiteUrl_starts_with: String
  websiteUrl_not_starts_with: String
  websiteUrl_ends_with: String
  websiteUrl_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BrandWhereInput!]
  OR: [BrandWhereInput!]
  NOT: [BrandWhereInput!]
}

input BrandWhereUniqueInput {
  id: ID
  slug: String
  brandCode: String
}

type Category {
  id: ID!
  slug: String!
  name: String!
  description: String
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  slug: String!
  name: String!
  description: String
  products: ProductCreateManyWithoutCategoryInput
}

input CategoryCreateOneWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutProductsInput {
  id: ID
  slug: String!
  name: String!
  description: String
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
}

type CategoryPreviousValues {
  id: ID!
  slug: String!
  name: String!
  description: String
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateInput {
  slug: String
  name: String
  description: String
  products: ProductUpdateManyWithoutCategoryInput
}

input CategoryUpdateManyMutationInput {
  slug: String
  name: String
  description: String
}

input CategoryUpdateOneRequiredWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput
  update: CategoryUpdateWithoutProductsDataInput
  upsert: CategoryUpsertWithoutProductsInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutProductsDataInput {
  slug: String
  name: String
  description: String
}

input CategoryUpsertWithoutProductsInput {
  update: CategoryUpdateWithoutProductsDataInput!
  create: CategoryCreateWithoutProductsInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
  slug: String
  name: String
}

type Color {
  id: ID!
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
}

type ColorConnection {
  pageInfo: PageInfo!
  edges: [ColorEdge]!
  aggregate: AggregateColor!
}

input ColorCreateInput {
  id: ID
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
  productVariants: ProductVariantCreateManyWithoutColorInput
}

input ColorCreateOneInput {
  create: ColorCreateInput
  connect: ColorWhereUniqueInput
}

input ColorCreateOneWithoutProductVariantsInput {
  create: ColorCreateWithoutProductVariantsInput
  connect: ColorWhereUniqueInput
}

input ColorCreateWithoutProductVariantsInput {
  id: ID
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
}

type ColorEdge {
  node: Color!
  cursor: String!
}

enum ColorOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  colorCode_ASC
  colorCode_DESC
  hexCode_ASC
  hexCode_DESC
}

type ColorPreviousValues {
  id: ID!
  slug: String!
  name: String!
  colorCode: String!
  hexCode: String!
}

type ColorSubscriptionPayload {
  mutation: MutationType!
  node: Color
  updatedFields: [String!]
  previousValues: ColorPreviousValues
}

input ColorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ColorWhereInput
  AND: [ColorSubscriptionWhereInput!]
  OR: [ColorSubscriptionWhereInput!]
  NOT: [ColorSubscriptionWhereInput!]
}

input ColorUpdateDataInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
  productVariants: ProductVariantUpdateManyWithoutColorInput
}

input ColorUpdateInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
  productVariants: ProductVariantUpdateManyWithoutColorInput
}

input ColorUpdateManyMutationInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
}

input ColorUpdateOneInput {
  create: ColorCreateInput
  update: ColorUpdateDataInput
  upsert: ColorUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ColorWhereUniqueInput
}

input ColorUpdateOneRequiredInput {
  create: ColorCreateInput
  update: ColorUpdateDataInput
  upsert: ColorUpsertNestedInput
  connect: ColorWhereUniqueInput
}

input ColorUpdateOneRequiredWithoutProductVariantsInput {
  create: ColorCreateWithoutProductVariantsInput
  update: ColorUpdateWithoutProductVariantsDataInput
  upsert: ColorUpsertWithoutProductVariantsInput
  connect: ColorWhereUniqueInput
}

input ColorUpdateWithoutProductVariantsDataInput {
  slug: String
  name: String
  colorCode: String
  hexCode: String
}

input ColorUpsertNestedInput {
  update: ColorUpdateDataInput!
  create: ColorCreateInput!
}

input ColorUpsertWithoutProductVariantsInput {
  update: ColorUpdateWithoutProductVariantsDataInput!
  create: ColorCreateWithoutProductVariantsInput!
}

input ColorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  colorCode: String
  colorCode_not: String
  colorCode_in: [String!]
  colorCode_not_in: [String!]
  colorCode_lt: String
  colorCode_lte: String
  colorCode_gt: String
  colorCode_gte: String
  colorCode_contains: String
  colorCode_not_contains: String
  colorCode_starts_with: String
  colorCode_not_starts_with: String
  colorCode_ends_with: String
  colorCode_not_ends_with: String
  hexCode: String
  hexCode_not: String
  hexCode_in: [String!]
  hexCode_not_in: [String!]
  hexCode_lt: String
  hexCode_lte: String
  hexCode_gt: String
  hexCode_gte: String
  hexCode_contains: String
  hexCode_not_contains: String
  hexCode_starts_with: String
  hexCode_not_starts_with: String
  hexCode_ends_with: String
  hexCode_not_ends_with: String
  productVariants_every: ProductVariantWhereInput
  productVariants_some: ProductVariantWhereInput
  productVariants_none: ProductVariantWhereInput
  AND: [ColorWhereInput!]
  OR: [ColorWhereInput!]
  NOT: [ColorWhereInput!]
}

input ColorWhereUniqueInput {
  id: ID
  slug: String
  colorCode: String
}

type Customer {
  id: ID!
  user: User!
  status: CustomerStatus
  detail: CustomerDetail
  bag: Bag!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  user: UserCreateOneInput!
  status: CustomerStatus
  detail: CustomerDetailCreateOneInput
  bag: BagCreateOneWithoutCustomerInput!
}

input CustomerCreateOneWithoutBagInput {
  create: CustomerCreateWithoutBagInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutBagInput {
  id: ID
  user: UserCreateOneInput!
  status: CustomerStatus
  detail: CustomerDetailCreateOneInput
}

type CustomerDetail {
  id: ID!
  phoneNumber: String
  birthday: DateTime
  height: Int
  bodyType: String
  averageTopSize: String
  averagePantSize: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  shippingAddress: Location
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerDetailConnection {
  pageInfo: PageInfo!
  edges: [CustomerDetailEdge]!
  aggregate: AggregateCustomerDetail!
}

input CustomerDetailCreateInput {
  id: ID
  phoneNumber: String
  birthday: DateTime
  height: Int
  bodyType: String
  averageTopSize: String
  averagePantSize: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  shippingAddress: LocationCreateOneInput
}

input CustomerDetailCreateOneInput {
  create: CustomerDetailCreateInput
  connect: CustomerDetailWhereUniqueInput
}

type CustomerDetailEdge {
  node: CustomerDetail!
  cursor: String!
}

enum CustomerDetailOrderByInput {
  id_ASC
  id_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  birthday_ASC
  birthday_DESC
  height_ASC
  height_DESC
  bodyType_ASC
  bodyType_DESC
  averageTopSize_ASC
  averageTopSize_DESC
  averagePantSize_ASC
  averagePantSize_DESC
  preferredPronouns_ASC
  preferredPronouns_DESC
  profession_ASC
  profession_DESC
  partyFrequency_ASC
  partyFrequency_DESC
  travelFrequency_ASC
  travelFrequency_DESC
  shoppingFrequency_ASC
  shoppingFrequency_DESC
  averageSpend_ASC
  averageSpend_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CustomerDetailPreviousValues {
  id: ID!
  phoneNumber: String
  birthday: DateTime
  height: Int
  bodyType: String
  averageTopSize: String
  averagePantSize: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerDetailSubscriptionPayload {
  mutation: MutationType!
  node: CustomerDetail
  updatedFields: [String!]
  previousValues: CustomerDetailPreviousValues
}

input CustomerDetailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerDetailWhereInput
  AND: [CustomerDetailSubscriptionWhereInput!]
  OR: [CustomerDetailSubscriptionWhereInput!]
  NOT: [CustomerDetailSubscriptionWhereInput!]
}

input CustomerDetailUpdateDataInput {
  phoneNumber: String
  birthday: DateTime
  height: Int
  bodyType: String
  averageTopSize: String
  averagePantSize: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  shippingAddress: LocationUpdateOneInput
}

input CustomerDetailUpdateInput {
  phoneNumber: String
  birthday: DateTime
  height: Int
  bodyType: String
  averageTopSize: String
  averagePantSize: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
  shippingAddress: LocationUpdateOneInput
}

input CustomerDetailUpdateManyMutationInput {
  phoneNumber: String
  birthday: DateTime
  height: Int
  bodyType: String
  averageTopSize: String
  averagePantSize: String
  preferredPronouns: String
  profession: String
  partyFrequency: String
  travelFrequency: String
  shoppingFrequency: String
  averageSpend: String
}

input CustomerDetailUpdateOneInput {
  create: CustomerDetailCreateInput
  update: CustomerDetailUpdateDataInput
  upsert: CustomerDetailUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CustomerDetailWhereUniqueInput
}

input CustomerDetailUpsertNestedInput {
  update: CustomerDetailUpdateDataInput!
  create: CustomerDetailCreateInput!
}

input CustomerDetailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  birthday: DateTime
  birthday_not: DateTime
  birthday_in: [DateTime!]
  birthday_not_in: [DateTime!]
  birthday_lt: DateTime
  birthday_lte: DateTime
  birthday_gt: DateTime
  birthday_gte: DateTime
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  bodyType: String
  bodyType_not: String
  bodyType_in: [String!]
  bodyType_not_in: [String!]
  bodyType_lt: String
  bodyType_lte: String
  bodyType_gt: String
  bodyType_gte: String
  bodyType_contains: String
  bodyType_not_contains: String
  bodyType_starts_with: String
  bodyType_not_starts_with: String
  bodyType_ends_with: String
  bodyType_not_ends_with: String
  averageTopSize: String
  averageTopSize_not: String
  averageTopSize_in: [String!]
  averageTopSize_not_in: [String!]
  averageTopSize_lt: String
  averageTopSize_lte: String
  averageTopSize_gt: String
  averageTopSize_gte: String
  averageTopSize_contains: String
  averageTopSize_not_contains: String
  averageTopSize_starts_with: String
  averageTopSize_not_starts_with: String
  averageTopSize_ends_with: String
  averageTopSize_not_ends_with: String
  averagePantSize: String
  averagePantSize_not: String
  averagePantSize_in: [String!]
  averagePantSize_not_in: [String!]
  averagePantSize_lt: String
  averagePantSize_lte: String
  averagePantSize_gt: String
  averagePantSize_gte: String
  averagePantSize_contains: String
  averagePantSize_not_contains: String
  averagePantSize_starts_with: String
  averagePantSize_not_starts_with: String
  averagePantSize_ends_with: String
  averagePantSize_not_ends_with: String
  preferredPronouns: String
  preferredPronouns_not: String
  preferredPronouns_in: [String!]
  preferredPronouns_not_in: [String!]
  preferredPronouns_lt: String
  preferredPronouns_lte: String
  preferredPronouns_gt: String
  preferredPronouns_gte: String
  preferredPronouns_contains: String
  preferredPronouns_not_contains: String
  preferredPronouns_starts_with: String
  preferredPronouns_not_starts_with: String
  preferredPronouns_ends_with: String
  preferredPronouns_not_ends_with: String
  profession: String
  profession_not: String
  profession_in: [String!]
  profession_not_in: [String!]
  profession_lt: String
  profession_lte: String
  profession_gt: String
  profession_gte: String
  profession_contains: String
  profession_not_contains: String
  profession_starts_with: String
  profession_not_starts_with: String
  profession_ends_with: String
  profession_not_ends_with: String
  partyFrequency: String
  partyFrequency_not: String
  partyFrequency_in: [String!]
  partyFrequency_not_in: [String!]
  partyFrequency_lt: String
  partyFrequency_lte: String
  partyFrequency_gt: String
  partyFrequency_gte: String
  partyFrequency_contains: String
  partyFrequency_not_contains: String
  partyFrequency_starts_with: String
  partyFrequency_not_starts_with: String
  partyFrequency_ends_with: String
  partyFrequency_not_ends_with: String
  travelFrequency: String
  travelFrequency_not: String
  travelFrequency_in: [String!]
  travelFrequency_not_in: [String!]
  travelFrequency_lt: String
  travelFrequency_lte: String
  travelFrequency_gt: String
  travelFrequency_gte: String
  travelFrequency_contains: String
  travelFrequency_not_contains: String
  travelFrequency_starts_with: String
  travelFrequency_not_starts_with: String
  travelFrequency_ends_with: String
  travelFrequency_not_ends_with: String
  shoppingFrequency: String
  shoppingFrequency_not: String
  shoppingFrequency_in: [String!]
  shoppingFrequency_not_in: [String!]
  shoppingFrequency_lt: String
  shoppingFrequency_lte: String
  shoppingFrequency_gt: String
  shoppingFrequency_gte: String
  shoppingFrequency_contains: String
  shoppingFrequency_not_contains: String
  shoppingFrequency_starts_with: String
  shoppingFrequency_not_starts_with: String
  shoppingFrequency_ends_with: String
  shoppingFrequency_not_ends_with: String
  averageSpend: String
  averageSpend_not: String
  averageSpend_in: [String!]
  averageSpend_not_in: [String!]
  averageSpend_lt: String
  averageSpend_lte: String
  averageSpend_gt: String
  averageSpend_gte: String
  averageSpend_contains: String
  averageSpend_not_contains: String
  averageSpend_starts_with: String
  averageSpend_not_starts_with: String
  averageSpend_ends_with: String
  averageSpend_not_ends_with: String
  shippingAddress: LocationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CustomerDetailWhereInput!]
  OR: [CustomerDetailWhereInput!]
  NOT: [CustomerDetailWhereInput!]
}

input CustomerDetailWhereUniqueInput {
  id: ID
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
}

type CustomerPreviousValues {
  id: ID!
  status: CustomerStatus
}

enum CustomerStatus {
  Invited
  Waitlisted
  Activated
  Suspended
  Deactivated
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  user: UserUpdateOneRequiredInput
  status: CustomerStatus
  detail: CustomerDetailUpdateOneInput
  bag: BagUpdateOneRequiredWithoutCustomerInput
}

input CustomerUpdateManyMutationInput {
  status: CustomerStatus
}

input CustomerUpdateOneRequiredWithoutBagInput {
  create: CustomerCreateWithoutBagInput
  update: CustomerUpdateWithoutBagDataInput
  upsert: CustomerUpsertWithoutBagInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutBagDataInput {
  user: UserUpdateOneRequiredInput
  status: CustomerStatus
  detail: CustomerDetailUpdateOneInput
}

input CustomerUpsertWithoutBagInput {
  update: CustomerUpdateWithoutBagDataInput!
  create: CustomerCreateWithoutBagInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  status: CustomerStatus
  status_not: CustomerStatus
  status_in: [CustomerStatus!]
  status_not_in: [CustomerStatus!]
  detail: CustomerDetailWhereInput
  bag: BagWhereInput
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

type Image {
  id: ID!
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: ID
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  caption_ASC
  caption_DESC
  originalHeight_ASC
  originalHeight_DESC
  originalUrl_ASC
  originalUrl_DESC
  originalWidth_ASC
  originalWidth_DESC
  resizedUrl_ASC
  resizedUrl_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ImagePreviousValues {
  id: ID!
  caption: String
  originalHeight: Int
  originalUrl: String!
  originalWidth: Int
  resizedUrl: String!
  title: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateInput {
  caption: String
  originalHeight: Int
  originalUrl: String
  originalWidth: Int
  resizedUrl: String
  title: String
}

input ImageUpdateManyMutationInput {
  caption: String
  originalHeight: Int
  originalUrl: String
  originalWidth: Int
  resizedUrl: String
  title: String
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  originalHeight: Int
  originalHeight_not: Int
  originalHeight_in: [Int!]
  originalHeight_not_in: [Int!]
  originalHeight_lt: Int
  originalHeight_lte: Int
  originalHeight_gt: Int
  originalHeight_gte: Int
  originalUrl: String
  originalUrl_not: String
  originalUrl_in: [String!]
  originalUrl_not_in: [String!]
  originalUrl_lt: String
  originalUrl_lte: String
  originalUrl_gt: String
  originalUrl_gte: String
  originalUrl_contains: String
  originalUrl_not_contains: String
  originalUrl_starts_with: String
  originalUrl_not_starts_with: String
  originalUrl_ends_with: String
  originalUrl_not_ends_with: String
  originalWidth: Int
  originalWidth_not: Int
  originalWidth_in: [Int!]
  originalWidth_not_in: [Int!]
  originalWidth_lt: Int
  originalWidth_lte: Int
  originalWidth_gt: Int
  originalWidth_gte: Int
  resizedUrl: String
  resizedUrl_not: String
  resizedUrl_in: [String!]
  resizedUrl_not_in: [String!]
  resizedUrl_lt: String
  resizedUrl_lte: String
  resizedUrl_gt: String
  resizedUrl_gte: String
  resizedUrl_contains: String
  resizedUrl_not_contains: String
  resizedUrl_starts_with: String
  resizedUrl_not_starts_with: String
  resizedUrl_ends_with: String
  resizedUrl_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

type InventoryLevel {
  id: ID!
  product: Product!
  productVariant: ProductVariant!
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

type InventoryLevelConnection {
  pageInfo: PageInfo!
  edges: [InventoryLevelEdge]!
  aggregate: AggregateInventoryLevel!
}

input InventoryLevelCreateInput {
  id: ID
  product: ProductCreateOneInput!
  productVariant: ProductVariantCreateOneWithoutInventoryLevelInput!
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

input InventoryLevelCreateOneWithoutProductVariantInput {
  create: InventoryLevelCreateWithoutProductVariantInput
  connect: InventoryLevelWhereUniqueInput
}

input InventoryLevelCreateWithoutProductVariantInput {
  id: ID
  product: ProductCreateOneInput!
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

type InventoryLevelEdge {
  node: InventoryLevel!
  cursor: String!
}

enum InventoryLevelOrderByInput {
  id_ASC
  id_DESC
  total_ASC
  total_DESC
  reservable_ASC
  reservable_DESC
  reserved_ASC
  reserved_DESC
  nonReservable_ASC
  nonReservable_DESC
}

type InventoryLevelPreviousValues {
  id: ID!
  total: Int!
  reservable: Int!
  reserved: Int!
  nonReservable: Int!
}

type InventoryLevelSubscriptionPayload {
  mutation: MutationType!
  node: InventoryLevel
  updatedFields: [String!]
  previousValues: InventoryLevelPreviousValues
}

input InventoryLevelSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryLevelWhereInput
  AND: [InventoryLevelSubscriptionWhereInput!]
  OR: [InventoryLevelSubscriptionWhereInput!]
  NOT: [InventoryLevelSubscriptionWhereInput!]
}

input InventoryLevelUpdateInput {
  product: ProductUpdateOneRequiredInput
  productVariant: ProductVariantUpdateOneRequiredWithoutInventoryLevelInput
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input InventoryLevelUpdateManyMutationInput {
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input InventoryLevelUpdateOneRequiredWithoutProductVariantInput {
  create: InventoryLevelCreateWithoutProductVariantInput
  update: InventoryLevelUpdateWithoutProductVariantDataInput
  upsert: InventoryLevelUpsertWithoutProductVariantInput
  connect: InventoryLevelWhereUniqueInput
}

input InventoryLevelUpdateWithoutProductVariantDataInput {
  product: ProductUpdateOneRequiredInput
  total: Int
  reservable: Int
  reserved: Int
  nonReservable: Int
}

input InventoryLevelUpsertWithoutProductVariantInput {
  update: InventoryLevelUpdateWithoutProductVariantDataInput!
  create: InventoryLevelCreateWithoutProductVariantInput!
}

input InventoryLevelWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  productVariant: ProductVariantWhereInput
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  reservable: Int
  reservable_not: Int
  reservable_in: [Int!]
  reservable_not_in: [Int!]
  reservable_lt: Int
  reservable_lte: Int
  reservable_gt: Int
  reservable_gte: Int
  reserved: Int
  reserved_not: Int
  reserved_in: [Int!]
  reserved_not_in: [Int!]
  reserved_lt: Int
  reserved_lte: Int
  reserved_gt: Int
  reserved_gte: Int
  nonReservable: Int
  nonReservable_not: Int
  nonReservable_in: [Int!]
  nonReservable_not_in: [Int!]
  nonReservable_lt: Int
  nonReservable_lte: Int
  nonReservable_gt: Int
  nonReservable_gte: Int
  AND: [InventoryLevelWhereInput!]
  OR: [InventoryLevelWhereInput!]
  NOT: [InventoryLevelWhereInput!]
}

input InventoryLevelWhereUniqueInput {
  id: ID
}

enum InventoryStatus {
  NonReservable
  Reservable
  Reserved
}

scalar Json

type Label {
  id: ID!
  name: String
  image: String
}

type LabelConnection {
  pageInfo: PageInfo!
  edges: [LabelEdge]!
  aggregate: AggregateLabel!
}

input LabelCreateInput {
  id: ID
  name: String
  image: String
}

input LabelCreateOneInput {
  create: LabelCreateInput
  connect: LabelWhereUniqueInput
}

type LabelEdge {
  node: Label!
  cursor: String!
}

enum LabelOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  image_ASC
  image_DESC
}

type LabelPreviousValues {
  id: ID!
  name: String
  image: String
}

type LabelSubscriptionPayload {
  mutation: MutationType!
  node: Label
  updatedFields: [String!]
  previousValues: LabelPreviousValues
}

input LabelSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LabelWhereInput
  AND: [LabelSubscriptionWhereInput!]
  OR: [LabelSubscriptionWhereInput!]
  NOT: [LabelSubscriptionWhereInput!]
}

input LabelUpdateDataInput {
  name: String
  image: String
}

input LabelUpdateInput {
  name: String
  image: String
}

input LabelUpdateManyMutationInput {
  name: String
  image: String
}

input LabelUpdateOneInput {
  create: LabelCreateInput
  update: LabelUpdateDataInput
  upsert: LabelUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LabelWhereUniqueInput
}

input LabelUpdateOneRequiredInput {
  create: LabelCreateInput
  update: LabelUpdateDataInput
  upsert: LabelUpsertNestedInput
  connect: LabelWhereUniqueInput
}

input LabelUpsertNestedInput {
  update: LabelUpdateDataInput!
  create: LabelCreateInput!
}

input LabelWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [LabelWhereInput!]
  OR: [LabelWhereInput!]
  NOT: [LabelWhereInput!]
}

input LabelWhereUniqueInput {
  id: ID
}

type Location {
  id: ID!
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String!
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  user: User
  lat: Float
  lng: Float
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String!
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  user: UserCreateOneInput
  lat: Float
  lng: Float
  physicalProducts: PhysicalProductCreateManyWithoutLocationInput
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

input LocationCreateOneWithoutPhysicalProductsInput {
  create: LocationCreateWithoutPhysicalProductsInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutPhysicalProductsInput {
  id: ID
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String!
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  user: UserCreateOneInput
  lat: Float
  lng: Float
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  company_ASC
  company_DESC
  description_ASC
  description_DESC
  address1_ASC
  address1_DESC
  address2_ASC
  address2_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  zipCode_ASC
  zipCode_DESC
  locationType_ASC
  locationType_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LocationPreviousValues {
  id: ID!
  slug: String!
  name: String!
  company: String
  description: String
  address1: String!
  address2: String!
  city: String!
  state: String!
  zipCode: String!
  locationType: LocationType
  lat: Float
  lng: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

enum LocationType {
  Office
  Warehouse
  Cleaner
  Customer
}

input LocationUpdateDataInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  user: UserUpdateOneInput
  lat: Float
  lng: Float
  physicalProducts: PhysicalProductUpdateManyWithoutLocationInput
}

input LocationUpdateInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  user: UserUpdateOneInput
  lat: Float
  lng: Float
  physicalProducts: PhysicalProductUpdateManyWithoutLocationInput
}

input LocationUpdateManyMutationInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  lat: Float
  lng: Float
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneWithoutPhysicalProductsInput {
  create: LocationCreateWithoutPhysicalProductsInput
  update: LocationUpdateWithoutPhysicalProductsDataInput
  upsert: LocationUpsertWithoutPhysicalProductsInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateWithoutPhysicalProductsDataInput {
  slug: String
  name: String
  company: String
  description: String
  address1: String
  address2: String
  city: String
  state: String
  zipCode: String
  locationType: LocationType
  user: UserUpdateOneInput
  lat: Float
  lng: Float
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithoutPhysicalProductsInput {
  update: LocationUpdateWithoutPhysicalProductsDataInput!
  create: LocationCreateWithoutPhysicalProductsInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  address1: String
  address1_not: String
  address1_in: [String!]
  address1_not_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_gt: String
  address1_gte: String
  address1_contains: String
  address1_not_contains: String
  address1_starts_with: String
  address1_not_starts_with: String
  address1_ends_with: String
  address1_not_ends_with: String
  address2: String
  address2_not: String
  address2_in: [String!]
  address2_not_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_gt: String
  address2_gte: String
  address2_contains: String
  address2_not_contains: String
  address2_starts_with: String
  address2_not_starts_with: String
  address2_ends_with: String
  address2_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  locationType: LocationType
  locationType_not: LocationType
  locationType_in: [LocationType!]
  locationType_not_in: [LocationType!]
  user: UserWhereInput
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  physicalProducts_every: PhysicalProductWhereInput
  physicalProducts_some: PhysicalProductWhereInput
  physicalProducts_none: PhysicalProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
  slug: String
  name: String
}

scalar Long

enum Material {
  Acetate
  Acrylic
  Alpaca
  CalfLeather
  CamelHair
  Cashmere
  Cotton
  CowLeather
  Cupro
  DuckFeathers
  Elastane
  Esterlane
  Feather
  FeatherDown
  GooseDown
  LambLeather
  Lyocell
  MerinoWool
  Nylon
  OrganicCotton
  Polyamide
  Polyester
  Polyurethane
  Rayon
  Silk
  SheepLeather
  Spandex
  Taffeta
  Tartan
  VirginWool
  Viscose
  WhiteDuckDown
  WhiteGooseDown
  Wool
  Mesh
  Denim
  Leather
}

type Mutation {
  createBag(data: BagCreateInput!): Bag!
  updateBag(data: BagUpdateInput!, where: BagWhereUniqueInput!): Bag
  upsertBag(where: BagWhereUniqueInput!, create: BagCreateInput!, update: BagUpdateInput!): Bag!
  deleteBag(where: BagWhereUniqueInput!): Bag
  deleteManyBags(where: BagWhereInput): BatchPayload!
  createBrand(data: BrandCreateInput!): Brand!
  updateBrand(data: BrandUpdateInput!, where: BrandWhereUniqueInput!): Brand
  updateManyBrands(data: BrandUpdateManyMutationInput!, where: BrandWhereInput): BatchPayload!
  upsertBrand(where: BrandWhereUniqueInput!, create: BrandCreateInput!, update: BrandUpdateInput!): Brand!
  deleteBrand(where: BrandWhereUniqueInput!): Brand
  deleteManyBrands(where: BrandWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createColor(data: ColorCreateInput!): Color!
  updateColor(data: ColorUpdateInput!, where: ColorWhereUniqueInput!): Color
  updateManyColors(data: ColorUpdateManyMutationInput!, where: ColorWhereInput): BatchPayload!
  upsertColor(where: ColorWhereUniqueInput!, create: ColorCreateInput!, update: ColorUpdateInput!): Color!
  deleteColor(where: ColorWhereUniqueInput!): Color
  deleteManyColors(where: ColorWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createCustomerDetail(data: CustomerDetailCreateInput!): CustomerDetail!
  updateCustomerDetail(data: CustomerDetailUpdateInput!, where: CustomerDetailWhereUniqueInput!): CustomerDetail
  updateManyCustomerDetails(data: CustomerDetailUpdateManyMutationInput!, where: CustomerDetailWhereInput): BatchPayload!
  upsertCustomerDetail(where: CustomerDetailWhereUniqueInput!, create: CustomerDetailCreateInput!, update: CustomerDetailUpdateInput!): CustomerDetail!
  deleteCustomerDetail(where: CustomerDetailWhereUniqueInput!): CustomerDetail
  deleteManyCustomerDetails(where: CustomerDetailWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createInventoryLevel(data: InventoryLevelCreateInput!): InventoryLevel!
  updateInventoryLevel(data: InventoryLevelUpdateInput!, where: InventoryLevelWhereUniqueInput!): InventoryLevel
  updateManyInventoryLevels(data: InventoryLevelUpdateManyMutationInput!, where: InventoryLevelWhereInput): BatchPayload!
  upsertInventoryLevel(where: InventoryLevelWhereUniqueInput!, create: InventoryLevelCreateInput!, update: InventoryLevelUpdateInput!): InventoryLevel!
  deleteInventoryLevel(where: InventoryLevelWhereUniqueInput!): InventoryLevel
  deleteManyInventoryLevels(where: InventoryLevelWhereInput): BatchPayload!
  createLabel(data: LabelCreateInput!): Label!
  updateLabel(data: LabelUpdateInput!, where: LabelWhereUniqueInput!): Label
  updateManyLabels(data: LabelUpdateManyMutationInput!, where: LabelWhereInput): BatchPayload!
  upsertLabel(where: LabelWhereUniqueInput!, create: LabelCreateInput!, update: LabelUpdateInput!): Label!
  deleteLabel(where: LabelWhereUniqueInput!): Label
  deleteManyLabels(where: LabelWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPhysicalProduct(data: PhysicalProductCreateInput!): PhysicalProduct!
  updatePhysicalProduct(data: PhysicalProductUpdateInput!, where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  updateManyPhysicalProducts(data: PhysicalProductUpdateManyMutationInput!, where: PhysicalProductWhereInput): BatchPayload!
  upsertPhysicalProduct(where: PhysicalProductWhereUniqueInput!, create: PhysicalProductCreateInput!, update: PhysicalProductUpdateInput!): PhysicalProduct!
  deletePhysicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  deleteManyPhysicalProducts(where: PhysicalProductWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductVariant(data: ProductVariantCreateInput!): ProductVariant!
  updateProductVariant(data: ProductVariantUpdateInput!, where: ProductVariantWhereUniqueInput!): ProductVariant
  updateManyProductVariants(data: ProductVariantUpdateManyMutationInput!, where: ProductVariantWhereInput): BatchPayload!
  upsertProductVariant(where: ProductVariantWhereUniqueInput!, create: ProductVariantCreateInput!, update: ProductVariantUpdateInput!): ProductVariant!
  deleteProductVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  deleteManyProductVariants(where: ProductVariantWhereInput): BatchPayload!
  createReservation(data: ReservationCreateInput!): Reservation!
  updateReservation(data: ReservationUpdateInput!, where: ReservationWhereUniqueInput!): Reservation
  updateManyReservations(data: ReservationUpdateManyMutationInput!, where: ReservationWhereInput): BatchPayload!
  upsertReservation(where: ReservationWhereUniqueInput!, create: ReservationCreateInput!, update: ReservationUpdateInput!): Reservation!
  deleteReservation(where: ReservationWhereUniqueInput!): Reservation
  deleteManyReservations(where: ReservationWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
}

type OrderPreviousValues {
  id: ID!
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PhysicalProduct {
  id: ID!
  seasonsUID: String!
  location: Location
  productVariant: ProductVariant!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhysicalProductConnection {
  pageInfo: PageInfo!
  edges: [PhysicalProductEdge]!
  aggregate: AggregatePhysicalProduct!
}

input PhysicalProductCreateInput {
  id: ID
  seasonsUID: String!
  location: LocationCreateOneWithoutPhysicalProductsInput
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
}

input PhysicalProductCreateManyInput {
  create: [PhysicalProductCreateInput!]
  connect: [PhysicalProductWhereUniqueInput!]
}

input PhysicalProductCreateManyWithoutLocationInput {
  create: [PhysicalProductCreateWithoutLocationInput!]
  connect: [PhysicalProductWhereUniqueInput!]
}

input PhysicalProductCreateManyWithoutProductVariantInput {
  create: [PhysicalProductCreateWithoutProductVariantInput!]
  connect: [PhysicalProductWhereUniqueInput!]
}

input PhysicalProductCreateWithoutLocationInput {
  id: ID
  seasonsUID: String!
  productVariant: ProductVariantCreateOneWithoutPhysicalProductsInput!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
}

input PhysicalProductCreateWithoutProductVariantInput {
  id: ID
  seasonsUID: String!
  location: LocationCreateOneWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
}

type PhysicalProductEdge {
  node: PhysicalProduct!
  cursor: String!
}

enum PhysicalProductOrderByInput {
  id_ASC
  id_DESC
  seasonsUID_ASC
  seasonsUID_DESC
  inventoryStatus_ASC
  inventoryStatus_DESC
  productStatus_ASC
  productStatus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhysicalProductPreviousValues {
  id: ID!
  seasonsUID: String!
  inventoryStatus: InventoryStatus!
  productStatus: PhysicalProductStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PhysicalProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seasonsUID: String
  seasonsUID_not: String
  seasonsUID_in: [String!]
  seasonsUID_not_in: [String!]
  seasonsUID_lt: String
  seasonsUID_lte: String
  seasonsUID_gt: String
  seasonsUID_gte: String
  seasonsUID_contains: String
  seasonsUID_not_contains: String
  seasonsUID_starts_with: String
  seasonsUID_not_starts_with: String
  seasonsUID_ends_with: String
  seasonsUID_not_ends_with: String
  inventoryStatus: InventoryStatus
  inventoryStatus_not: InventoryStatus
  inventoryStatus_in: [InventoryStatus!]
  inventoryStatus_not_in: [InventoryStatus!]
  productStatus: PhysicalProductStatus
  productStatus_not: PhysicalProductStatus
  productStatus_in: [PhysicalProductStatus!]
  productStatus_not_in: [PhysicalProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhysicalProductScalarWhereInput!]
  OR: [PhysicalProductScalarWhereInput!]
  NOT: [PhysicalProductScalarWhereInput!]
}

enum PhysicalProductStatus {
  New
  Used
  Damaged
  Clean
}

type PhysicalProductSubscriptionPayload {
  mutation: MutationType!
  node: PhysicalProduct
  updatedFields: [String!]
  previousValues: PhysicalProductPreviousValues
}

input PhysicalProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhysicalProductWhereInput
  AND: [PhysicalProductSubscriptionWhereInput!]
  OR: [PhysicalProductSubscriptionWhereInput!]
  NOT: [PhysicalProductSubscriptionWhereInput!]
}

input PhysicalProductUpdateDataInput {
  seasonsUID: String
  location: LocationUpdateOneWithoutPhysicalProductsInput
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateInput {
  seasonsUID: String
  location: LocationUpdateOneWithoutPhysicalProductsInput
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateManyDataInput {
  seasonsUID: String
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateManyInput {
  create: [PhysicalProductCreateInput!]
  update: [PhysicalProductUpdateWithWhereUniqueNestedInput!]
  upsert: [PhysicalProductUpsertWithWhereUniqueNestedInput!]
  delete: [PhysicalProductWhereUniqueInput!]
  connect: [PhysicalProductWhereUniqueInput!]
  set: [PhysicalProductWhereUniqueInput!]
  disconnect: [PhysicalProductWhereUniqueInput!]
  deleteMany: [PhysicalProductScalarWhereInput!]
  updateMany: [PhysicalProductUpdateManyWithWhereNestedInput!]
}

input PhysicalProductUpdateManyMutationInput {
  seasonsUID: String
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateManyWithoutLocationInput {
  create: [PhysicalProductCreateWithoutLocationInput!]
  delete: [PhysicalProductWhereUniqueInput!]
  connect: [PhysicalProductWhereUniqueInput!]
  set: [PhysicalProductWhereUniqueInput!]
  disconnect: [PhysicalProductWhereUniqueInput!]
  update: [PhysicalProductUpdateWithWhereUniqueWithoutLocationInput!]
  upsert: [PhysicalProductUpsertWithWhereUniqueWithoutLocationInput!]
  deleteMany: [PhysicalProductScalarWhereInput!]
  updateMany: [PhysicalProductUpdateManyWithWhereNestedInput!]
}

input PhysicalProductUpdateManyWithoutProductVariantInput {
  create: [PhysicalProductCreateWithoutProductVariantInput!]
  delete: [PhysicalProductWhereUniqueInput!]
  connect: [PhysicalProductWhereUniqueInput!]
  set: [PhysicalProductWhereUniqueInput!]
  disconnect: [PhysicalProductWhereUniqueInput!]
  update: [PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput!]
  upsert: [PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput!]
  deleteMany: [PhysicalProductScalarWhereInput!]
  updateMany: [PhysicalProductUpdateManyWithWhereNestedInput!]
}

input PhysicalProductUpdateManyWithWhereNestedInput {
  where: PhysicalProductScalarWhereInput!
  data: PhysicalProductUpdateManyDataInput!
}

input PhysicalProductUpdateWithoutLocationDataInput {
  seasonsUID: String
  productVariant: ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateWithoutProductVariantDataInput {
  seasonsUID: String
  location: LocationUpdateOneWithoutPhysicalProductsInput
  inventoryStatus: InventoryStatus
  productStatus: PhysicalProductStatus
}

input PhysicalProductUpdateWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput!
  data: PhysicalProductUpdateDataInput!
}

input PhysicalProductUpdateWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput!
  data: PhysicalProductUpdateWithoutLocationDataInput!
}

input PhysicalProductUpdateWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput!
  data: PhysicalProductUpdateWithoutProductVariantDataInput!
}

input PhysicalProductUpsertWithWhereUniqueNestedInput {
  where: PhysicalProductWhereUniqueInput!
  update: PhysicalProductUpdateDataInput!
  create: PhysicalProductCreateInput!
}

input PhysicalProductUpsertWithWhereUniqueWithoutLocationInput {
  where: PhysicalProductWhereUniqueInput!
  update: PhysicalProductUpdateWithoutLocationDataInput!
  create: PhysicalProductCreateWithoutLocationInput!
}

input PhysicalProductUpsertWithWhereUniqueWithoutProductVariantInput {
  where: PhysicalProductWhereUniqueInput!
  update: PhysicalProductUpdateWithoutProductVariantDataInput!
  create: PhysicalProductCreateWithoutProductVariantInput!
}

input PhysicalProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seasonsUID: String
  seasonsUID_not: String
  seasonsUID_in: [String!]
  seasonsUID_not_in: [String!]
  seasonsUID_lt: String
  seasonsUID_lte: String
  seasonsUID_gt: String
  seasonsUID_gte: String
  seasonsUID_contains: String
  seasonsUID_not_contains: String
  seasonsUID_starts_with: String
  seasonsUID_not_starts_with: String
  seasonsUID_ends_with: String
  seasonsUID_not_ends_with: String
  location: LocationWhereInput
  productVariant: ProductVariantWhereInput
  inventoryStatus: InventoryStatus
  inventoryStatus_not: InventoryStatus
  inventoryStatus_in: [InventoryStatus!]
  inventoryStatus_not_in: [InventoryStatus!]
  productStatus: PhysicalProductStatus
  productStatus_not: PhysicalProductStatus
  productStatus_in: [PhysicalProductStatus!]
  productStatus_not_in: [PhysicalProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhysicalProductWhereInput!]
  OR: [PhysicalProductWhereInput!]
  NOT: [PhysicalProductWhereInput!]
}

input PhysicalProductWhereUniqueInput {
  id: ID
  seasonsUID: String
}

type Product {
  id: ID!
  slug: String!
  name: String!
  brand: Brand!
  category: Category!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: Color!
  secondaryColor: Color
  tags: Json
  functions: [String!]!
  availableSizes: [Size!]!
  innerMaterials: [Material!]!
  outerMaterials: [Material!]!
  status: ProductStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateavailableSizesInput {
  set: [Size!]
}

input ProductCreatefunctionsInput {
  set: [String!]
}

input ProductCreateinnerMaterialsInput {
  set: [Material!]
}

input ProductCreateInput {
  id: ID
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  category: CategoryCreateOneWithoutProductsInput!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorCreateOneInput!
  secondaryColor: ColorCreateOneInput
  tags: Json
  functions: ProductCreatefunctionsInput
  availableSizes: ProductCreateavailableSizesInput
  innerMaterials: ProductCreateinnerMaterialsInput
  outerMaterials: ProductCreateouterMaterialsInput
  status: ProductStatus
}

input ProductCreateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

input ProductCreateouterMaterialsInput {
  set: [Material!]
}

input ProductCreateWithoutBrandInput {
  id: ID
  slug: String!
  name: String!
  category: CategoryCreateOneWithoutProductsInput!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorCreateOneInput!
  secondaryColor: ColorCreateOneInput
  tags: Json
  functions: ProductCreatefunctionsInput
  availableSizes: ProductCreateavailableSizesInput
  innerMaterials: ProductCreateinnerMaterialsInput
  outerMaterials: ProductCreateouterMaterialsInput
  status: ProductStatus
}

input ProductCreateWithoutCategoryInput {
  id: ID
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorCreateOneInput!
  secondaryColor: ColorCreateOneInput
  tags: Json
  functions: ProductCreatefunctionsInput
  availableSizes: ProductCreateavailableSizesInput
  innerMaterials: ProductCreateinnerMaterialsInput
  outerMaterials: ProductCreateouterMaterialsInput
  status: ProductStatus
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  externalURL_ASC
  externalURL_DESC
  images_ASC
  images_DESC
  modelHeight_ASC
  modelHeight_DESC
  modelSize_ASC
  modelSize_DESC
  retailPrice_ASC
  retailPrice_DESC
  tags_ASC
  tags_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  slug: String!
  name: String!
  description: String
  externalURL: String
  images: Json!
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  tags: Json
  functions: [String!]!
  availableSizes: [Size!]!
  innerMaterials: [Material!]!
  outerMaterials: [Material!]!
  status: ProductStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  externalURL: String
  externalURL_not: String
  externalURL_in: [String!]
  externalURL_not_in: [String!]
  externalURL_lt: String
  externalURL_lte: String
  externalURL_gt: String
  externalURL_gte: String
  externalURL_contains: String
  externalURL_not_contains: String
  externalURL_starts_with: String
  externalURL_not_starts_with: String
  externalURL_ends_with: String
  externalURL_not_ends_with: String
  modelHeight: Int
  modelHeight_not: Int
  modelHeight_in: [Int!]
  modelHeight_not_in: [Int!]
  modelHeight_lt: Int
  modelHeight_lte: Int
  modelHeight_gt: Int
  modelHeight_gte: Int
  modelSize: Size
  modelSize_not: Size
  modelSize_in: [Size!]
  modelSize_not_in: [Size!]
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  status: ProductStatus
  status_not: ProductStatus
  status_in: [ProductStatus!]
  status_not_in: [ProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

enum ProductStatus {
  Available
  NotAvailable
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateavailableSizesInput {
  set: [Size!]
}

input ProductUpdateDataInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductUpdatefunctionsInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdatefunctionsInput {
  set: [String!]
}

input ProductUpdateinnerMaterialsInput {
  set: [Material!]
}

input ProductUpdateInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductUpdatefunctionsInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateManyDataInput {
  slug: String
  name: String
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  tags: Json
  functions: ProductUpdatefunctionsInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateManyMutationInput {
  slug: String
  name: String
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  tags: Json
  functions: ProductUpdatefunctionsInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutBrandInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutBrandInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutCategoryInput {
  create: [ProductCreateWithoutCategoryInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateouterMaterialsInput {
  set: [Material!]
}

input ProductUpdateWithoutBrandDataInput {
  slug: String
  name: String
  category: CategoryUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductUpdatefunctionsInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateWithoutCategoryDataInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  description: String
  externalURL: String
  images: Json
  modelHeight: Int
  modelSize: Size
  retailPrice: Int
  color: ColorUpdateOneRequiredInput
  secondaryColor: ColorUpdateOneInput
  tags: Json
  functions: ProductUpdatefunctionsInput
  availableSizes: ProductUpdateavailableSizesInput
  innerMaterials: ProductUpdateinnerMaterialsInput
  outerMaterials: ProductUpdateouterMaterialsInput
  status: ProductStatus
}

input ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutBrandDataInput!
}

input ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCategoryDataInput!
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutBrandDataInput!
  create: ProductCreateWithoutBrandInput!
}

input ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCategoryDataInput!
  create: ProductCreateWithoutCategoryInput!
}

type ProductVariant {
  id: ID!
  sku: String
  color: Color!
  weight: Int
  height: Int
  product: Product!
  retailPrice: Int
  inventoryLevel: InventoryLevel!
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductVariantConnection {
  pageInfo: PageInfo!
  edges: [ProductVariantEdge]!
  aggregate: AggregateProductVariant!
}

input ProductVariantCreateInput {
  id: ID
  sku: String
  color: ColorCreateOneWithoutProductVariantsInput!
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  inventoryLevel: InventoryLevelCreateOneWithoutProductVariantInput!
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
}

input ProductVariantCreateManyInput {
  create: [ProductVariantCreateInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateManyWithoutColorInput {
  create: [ProductVariantCreateWithoutColorInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateOneWithoutInventoryLevelInput {
  create: ProductVariantCreateWithoutInventoryLevelInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantCreateOneWithoutPhysicalProductsInput {
  create: ProductVariantCreateWithoutPhysicalProductsInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantCreateWithoutColorInput {
  id: ID
  sku: String
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  inventoryLevel: InventoryLevelCreateOneWithoutProductVariantInput!
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
}

input ProductVariantCreateWithoutInventoryLevelInput {
  id: ID
  sku: String
  color: ColorCreateOneWithoutProductVariantsInput!
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  physicalProducts: PhysicalProductCreateManyWithoutProductVariantInput
}

input ProductVariantCreateWithoutPhysicalProductsInput {
  id: ID
  sku: String
  color: ColorCreateOneWithoutProductVariantsInput!
  weight: Int
  height: Int
  product: ProductCreateOneInput!
  retailPrice: Int
  inventoryLevel: InventoryLevelCreateOneWithoutProductVariantInput!
}

type ProductVariantEdge {
  node: ProductVariant!
  cursor: String!
}

enum ProductVariantOrderByInput {
  id_ASC
  id_DESC
  sku_ASC
  sku_DESC
  weight_ASC
  weight_DESC
  height_ASC
  height_DESC
  retailPrice_ASC
  retailPrice_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductVariantPreviousValues {
  id: ID!
  sku: String
  weight: Int
  height: Int
  retailPrice: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductVariantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantScalarWhereInput!]
  OR: [ProductVariantScalarWhereInput!]
  NOT: [ProductVariantScalarWhereInput!]
}

type ProductVariantSubscriptionPayload {
  mutation: MutationType!
  node: ProductVariant
  updatedFields: [String!]
  previousValues: ProductVariantPreviousValues
}

input ProductVariantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductVariantWhereInput
  AND: [ProductVariantSubscriptionWhereInput!]
  OR: [ProductVariantSubscriptionWhereInput!]
  NOT: [ProductVariantSubscriptionWhereInput!]
}

input ProductVariantUpdateDataInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  inventoryLevel: InventoryLevelUpdateOneRequiredWithoutProductVariantInput
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  inventoryLevel: InventoryLevelUpdateOneRequiredWithoutProductVariantInput
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateManyDataInput {
  sku: String
  weight: Int
  height: Int
  retailPrice: Int
}

input ProductVariantUpdateManyInput {
  create: [ProductVariantCreateInput!]
  update: [ProductVariantUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueNestedInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyMutationInput {
  sku: String
  weight: Int
  height: Int
  retailPrice: Int
}

input ProductVariantUpdateManyWithoutColorInput {
  create: [ProductVariantCreateWithoutColorInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  update: [ProductVariantUpdateWithWhereUniqueWithoutColorInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueWithoutColorInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyWithWhereNestedInput {
  where: ProductVariantScalarWhereInput!
  data: ProductVariantUpdateManyDataInput!
}

input ProductVariantUpdateOneRequiredWithoutInventoryLevelInput {
  create: ProductVariantCreateWithoutInventoryLevelInput
  update: ProductVariantUpdateWithoutInventoryLevelDataInput
  upsert: ProductVariantUpsertWithoutInventoryLevelInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantUpdateOneRequiredWithoutPhysicalProductsInput {
  create: ProductVariantCreateWithoutPhysicalProductsInput
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput
  upsert: ProductVariantUpsertWithoutPhysicalProductsInput
  connect: ProductVariantWhereUniqueInput
}

input ProductVariantUpdateWithoutColorDataInput {
  sku: String
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  inventoryLevel: InventoryLevelUpdateOneRequiredWithoutProductVariantInput
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateWithoutInventoryLevelDataInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  physicalProducts: PhysicalProductUpdateManyWithoutProductVariantInput
}

input ProductVariantUpdateWithoutPhysicalProductsDataInput {
  sku: String
  color: ColorUpdateOneRequiredWithoutProductVariantsInput
  weight: Int
  height: Int
  product: ProductUpdateOneRequiredInput
  retailPrice: Int
  inventoryLevel: InventoryLevelUpdateOneRequiredWithoutProductVariantInput
}

input ProductVariantUpdateWithWhereUniqueNestedInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateDataInput!
}

input ProductVariantUpdateWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateWithoutColorDataInput!
}

input ProductVariantUpsertWithoutInventoryLevelInput {
  update: ProductVariantUpdateWithoutInventoryLevelDataInput!
  create: ProductVariantCreateWithoutInventoryLevelInput!
}

input ProductVariantUpsertWithoutPhysicalProductsInput {
  update: ProductVariantUpdateWithoutPhysicalProductsDataInput!
  create: ProductVariantCreateWithoutPhysicalProductsInput!
}

input ProductVariantUpsertWithWhereUniqueNestedInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateDataInput!
  create: ProductVariantCreateInput!
}

input ProductVariantUpsertWithWhereUniqueWithoutColorInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateWithoutColorDataInput!
  create: ProductVariantCreateWithoutColorInput!
}

input ProductVariantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  color: ColorWhereInput
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  product: ProductWhereInput
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  inventoryLevel: InventoryLevelWhereInput
  physicalProducts_every: PhysicalProductWhereInput
  physicalProducts_some: PhysicalProductWhereInput
  physicalProducts_none: PhysicalProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantWhereInput!]
  OR: [ProductVariantWhereInput!]
  NOT: [ProductVariantWhereInput!]
}

input ProductVariantWhereUniqueInput {
  id: ID
  sku: String
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  brand: BrandWhereInput
  category: CategoryWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  externalURL: String
  externalURL_not: String
  externalURL_in: [String!]
  externalURL_not_in: [String!]
  externalURL_lt: String
  externalURL_lte: String
  externalURL_gt: String
  externalURL_gte: String
  externalURL_contains: String
  externalURL_not_contains: String
  externalURL_starts_with: String
  externalURL_not_starts_with: String
  externalURL_ends_with: String
  externalURL_not_ends_with: String
  modelHeight: Int
  modelHeight_not: Int
  modelHeight_in: [Int!]
  modelHeight_not_in: [Int!]
  modelHeight_lt: Int
  modelHeight_lte: Int
  modelHeight_gt: Int
  modelHeight_gte: Int
  modelSize: Size
  modelSize_not: Size
  modelSize_in: [Size!]
  modelSize_not_in: [Size!]
  retailPrice: Int
  retailPrice_not: Int
  retailPrice_in: [Int!]
  retailPrice_not_in: [Int!]
  retailPrice_lt: Int
  retailPrice_lte: Int
  retailPrice_gt: Int
  retailPrice_gte: Int
  color: ColorWhereInput
  secondaryColor: ColorWhereInput
  status: ProductStatus
  status_not: ProductStatus
  status_in: [ProductStatus!]
  status_not_in: [ProductStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
  slug: String
}

type Query {
  bag(where: BagWhereUniqueInput!): Bag
  bags(where: BagWhereInput, orderBy: BagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bag]!
  bagsConnection(where: BagWhereInput, orderBy: BagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BagConnection!
  brand(where: BrandWhereUniqueInput!): Brand
  brands(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Brand]!
  brandsConnection(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BrandConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  color(where: ColorWhereUniqueInput!): Color
  colors(where: ColorWhereInput, orderBy: ColorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Color]!
  colorsConnection(where: ColorWhereInput, orderBy: ColorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ColorConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  customerDetail(where: CustomerDetailWhereUniqueInput!): CustomerDetail
  customerDetails(where: CustomerDetailWhereInput, orderBy: CustomerDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CustomerDetail]!
  customerDetailsConnection(where: CustomerDetailWhereInput, orderBy: CustomerDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerDetailConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  inventoryLevel(where: InventoryLevelWhereUniqueInput!): InventoryLevel
  inventoryLevels(where: InventoryLevelWhereInput, orderBy: InventoryLevelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryLevel]!
  inventoryLevelsConnection(where: InventoryLevelWhereInput, orderBy: InventoryLevelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryLevelConnection!
  label(where: LabelWhereUniqueInput!): Label
  labels(where: LabelWhereInput, orderBy: LabelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Label]!
  labelsConnection(where: LabelWhereInput, orderBy: LabelOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LabelConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  physicalProduct(where: PhysicalProductWhereUniqueInput!): PhysicalProduct
  physicalProducts(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct]!
  physicalProductsConnection(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhysicalProductConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant]!
  productVariantsConnection(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductVariantConnection!
  reservation(where: ReservationWhereUniqueInput!): Reservation
  reservations(where: ReservationWhereInput, orderBy: ReservationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reservation]!
  reservationsConnection(where: ReservationWhereInput, orderBy: ReservationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReservationConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Reservation {
  id: ID!
  user: User!
  shippingLabel: Label!
  returnLabel: Label
  products(where: PhysicalProductWhereInput, orderBy: PhysicalProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhysicalProduct!]
  shipped: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReservationConnection {
  pageInfo: PageInfo!
  edges: [ReservationEdge]!
  aggregate: AggregateReservation!
}

input ReservationCreateInput {
  id: ID
  user: UserCreateOneInput!
  shippingLabel: LabelCreateOneInput!
  returnLabel: LabelCreateOneInput
  products: PhysicalProductCreateManyInput
  shipped: Boolean!
}

type ReservationEdge {
  node: Reservation!
  cursor: String!
}

enum ReservationOrderByInput {
  id_ASC
  id_DESC
  shipped_ASC
  shipped_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReservationPreviousValues {
  id: ID!
  shipped: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReservationSubscriptionPayload {
  mutation: MutationType!
  node: Reservation
  updatedFields: [String!]
  previousValues: ReservationPreviousValues
}

input ReservationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReservationWhereInput
  AND: [ReservationSubscriptionWhereInput!]
  OR: [ReservationSubscriptionWhereInput!]
  NOT: [ReservationSubscriptionWhereInput!]
}

input ReservationUpdateInput {
  user: UserUpdateOneRequiredInput
  shippingLabel: LabelUpdateOneRequiredInput
  returnLabel: LabelUpdateOneInput
  products: PhysicalProductUpdateManyInput
  shipped: Boolean
}

input ReservationUpdateManyMutationInput {
  shipped: Boolean
}

input ReservationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  shippingLabel: LabelWhereInput
  returnLabel: LabelWhereInput
  products_every: PhysicalProductWhereInput
  products_some: PhysicalProductWhereInput
  products_none: PhysicalProductWhereInput
  shipped: Boolean
  shipped_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReservationWhereInput!]
  OR: [ReservationWhereInput!]
  NOT: [ReservationWhereInput!]
}

input ReservationWhereUniqueInput {
  id: ID
}

enum Size {
  XS
  S
  M
  L
  XL
}

type Subscription {
  bag(where: BagSubscriptionWhereInput): BagSubscriptionPayload
  brand(where: BrandSubscriptionWhereInput): BrandSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  color(where: ColorSubscriptionWhereInput): ColorSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  customerDetail(where: CustomerDetailSubscriptionWhereInput): CustomerDetailSubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  inventoryLevel(where: InventoryLevelSubscriptionWhereInput): InventoryLevelSubscriptionPayload
  label(where: LabelSubscriptionWhereInput): LabelSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  physicalProduct(where: PhysicalProductSubscriptionWhereInput): PhysicalProductSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productVariant(where: ProductVariantSubscriptionWhereInput): ProductVariantSubscriptionPayload
  reservation(where: ReservationSubscriptionWhereInput): ReservationSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  auth0Id: String!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  auth0Id: String!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  auth0Id_ASC
  auth0Id_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  auth0Id: String!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum UserRole {
  Admin
  Customer
  Partner
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  auth0Id: String
  email: String
  firstName: String
  lastName: String
  role: UserRole
}

input UserUpdateInput {
  auth0Id: String
  email: String
  firstName: String
  lastName: String
  role: UserRole
}

input UserUpdateManyMutationInput {
  auth0Id: String
  email: String
  firstName: String
  lastName: String
  role: UserRole
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  auth0Id: String
  auth0Id_not: String
  auth0Id_in: [String!]
  auth0Id_not_in: [String!]
  auth0Id_lt: String
  auth0Id_lte: String
  auth0Id_gt: String
  auth0Id_gte: String
  auth0Id_contains: String
  auth0Id_not_contains: String
  auth0Id_starts_with: String
  auth0Id_not_starts_with: String
  auth0Id_ends_with: String
  auth0Id_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  auth0Id: String
  email: String
}
`